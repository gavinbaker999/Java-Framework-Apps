import java.applet.*;				
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.awt.datatransfer.*;
import java.awt.font.*;
import java.awt.color.*;				// ColorSpace
import java.awt.geom.*;					// AffineTransform
import java.sql.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.awt.List;
import java.awt.print.*;
import java.awt.geom.*;
import java.lang.reflect.*;
import java.util.Date;
import java.util.Map;
import java.text.*;
import java.beans.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.border.*;
import javax.swing.tree.*;
import javax.swing.table.*;
import javax.swing.Timer;
import javax.sound.sampled.*;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.*;
import javax.xml.transform.OutputKeys.*;
import javax.xml.ws.*;
import javax.xml.ws.handler.*;
import javax.xml.ws.handler.soap.*;
import javax.xml.soap.*;
import javax.xml.namespace.QName;
import javax.xml.ws.handler.Handler;
import org.w3c.dom.*;
import org.w3c.dom.traversal.*;
import org.xml.sax.*;
import org.xml.sax.helpers.*;
import javax.script.*;
import javax.swing.filechooser.*;
//import javax.xml.messaging.*;
import javax.xml.xpath.XPath; 
import javax.xml.xpath.XPathConstants; 
import javax.xml.xpath.XPathExpressionException; 
import javax.xml.xpath.XPathFactory;
import javax.xml.stream.EventFilter;
import javax.xml.stream.StreamFilter;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLReporter;
import javax.xml.stream.XMLResolver;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.util.XMLEventAllocator;
import javax.xml.transform.Source;

import javax.sound.sampled.*;
import sun.audio.*;

import javax.sound.sampled.DataLine;
import javax.sound.sampled.TargetDataLine;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.AudioFileFormat;
import javax.imageio.event.*;
import javax.imageio.metadata.*;
import javax.imageio.plugins.jpeg.*;
import javax.imageio.plugins.bmp.*;
import javax.imageio.spi.*;
import javax.imageio.stream.*;
import javax.imageio.*;
import javax.imageio.ImageReader;
import javax.imageio.ImageWriter;
import javax.activation.URLDataSource.*;

import java.awt.geom.Point2D;
import java.awt.geom.Point2D.*;
import javax.swing.text.*;
import javax.swing.text.html.*;
import javax.swing.text.html.parser.*;
import javax.swing.text.Utilities;
import javax.swing.text.html.HTMLEditorKit.*;
import javax.swing.text.html.ParagraphView;
import javax.swing.text.html.HTMLDocument.*;

import javax.swing.text.Element;
import javax.swing.text.StyledDocument;
import javax.swing.text.StyleConstants;
import javax.swing.text.MutableAttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.DefaultStyledDocument;

import java.sql.*;
//import javax.jms.*;
import javax.naming.*;

//import javax.xml.xquery.XQConnection;
//import javax.xml.xquery.XQDataSource;
//import javax.xml.xquery.XQException;
//import javax.xml.xquery.XQPreparedExpression;
//import javax.xml.xquery.XQResultSequence;
//import com.saxonica.xqj.SaxonXQDataSource;

public class hdlworkbench extends JApplet implements ChangeListener,Runnable
{
	public		boolean		bRemoteHosted = false;
	public 		String		dbHost = "localhost";
	public		String		dbName = "gavin_endhousesoftware";
	public 		String		dbUser = "root";
	public		String		dbPassword = "joidefoster";
	public		String		dataRelativePath = "..";
	public		String		remoteHostRelativePath = "..";
	
	protected	Thread		systemThread1;
	protected	mainCard	mainTab;
	protected 	designCard	designTab;
	protected	resultsCard	resultsTab;
	protected	helpCard	helpTab;

	protected 	CardLayout 	layout;
	protected 	Panel		cards;

	protected	FontMetrics	fm;
	protected 	int			charWidth;
	protected	int			charHeight;

	protected	registrationinfo systemUserReg;
	protected	mysqlJDBC	systemMysql;
	protected	sounds		systemAudioClips;
	protected	JToolBar	roomToolbar;
	
	protected	AppletContext	ac;
	protected	languageStrings	lStrings;
	protected	Container		contentPane;
	protected	boolean 		runThreads = true;	
	protected	Frame			parentFrame = null;
	
	protected	JTabbedPane	tabPane;

	protected 	helpDialog helpDlg = null;
	protected 	controlPanelDialog controlPanelDlg = null;

	protected	chatAVI	theProf;
	protected	profDialog profDlg;
	protected	int maxSoundID;
	protected	javax.swing.Action help,about;
	
	protected	hdlSystem hdlworkbench;
	
	protected Color navy = new Color(0,0,128);
	protected Color purple = new Color(128,0,128);
	protected Color maroon = new Color(128,0,0);
	protected Color lightyellow = new Color(255,255,170);
	protected String[] colors = {"black","blue","green","red","navy","purple","maroon","yellow","white","custom1","custom2"};
	protected Color[] colorCodes = {Color.black,Color.blue,Color.green,Color.red,navy,purple,maroon,Color.yellow,Color.white,Color.white,Color.white};
	protected String swords = "and,but,a,why,because,as,the,is,to,at,what,not,i,do,this,have";
	protected Vector smallWords;
	protected String machineID = "";
	
	protected	customIcon			ciHelp;
	
	protected	 int		TRACELEVEL = 4;
	protected	boolean					bSymbolDump = false;
	
	protected	static final int		sysThreadSleep = 1000;
	protected	static final int		systemSoundThreadPrioity = 8;
	protected	static final int		systemMsgThreadPrioity = 7;
	protected	static final int		bilSleepPeriod = 1000;
	protected	static final int		systemExtLockThreadPrioity = 8;
	protected	static final int		systemExtLockThreadSleep = 1000;

	protected	static final int		MaxX = 300;

	protected	static final int		userApplet = 0;
	protected	static final int		userWAP = 1;
	
	protected	static final int		ciMove = 0;
	protected	static final int		ciDraw = 1;
	protected	static final int		ciRect = 2;

	protected	static final int		windowXMax = 800;
	protected	static final int		windowYMax = 600;
	protected   static final int 		defaultDialogX = 150;
	protected	static final int 		defaultDialogY = 90;

	protected	static final int		numDirAvis = 5;
	
	protected	static final int		aviUser = 0;
	protected	static final int		aviTest = 1;
	protected	static final int		aviGlobal = 2;
	protected	static final int		chatAVISizeX = 73;
	protected	static final int		chatAVISizeY = 70;
	
	protected	static final int		roomPicture = 1;
	protected	static final int		noScaleX = -1;
	protected	static final int		noScaleY = -1;
	protected	static final int		normalMsg = 0;
	protected	static final int		imMsg = 1;
	protected	static final int		defaultMenuX = 100;
	protected	static final int		defaultMenuY =5;
	protected	static final int		profSoundID = 1;
	protected	static final int		extraSounds = 10;	

	protected	static final int		scnormalword = 0;
	protected	static final int		scaddword = 1;
	protected	static final int		scignoreword = 2;

	protected	static final int		strPadLeft = 0;
	protected 	static final int		strPadRight = 1;
	
	protected	static final int		dcTypeLine = 0;
	protected	static final int		dcTypeRect = 1;
	protected	static final int		dcTypeElispe = 2;
	protected	static final int		dcTypeImage = 3;
	protected	static final int		dcTypeText = 4;
	protected	static final int		dcTypeSelect = 5;
	protected	static final int		dcTypeConnector = 6;
	protected	static final int		dcTypeTextBox = 7;
	protected	static final int		dcTypeSwitchGCSheet = 8;
	protected	static final int		dcTypeTransTable = 9;
	protected	static final int		dcTypeBuiltInMaxId = 9;
	protected	static final int		dcTypeHDL = 10;
	protected	static final int		dcTypeHDLConn = 11;
	protected	static int		dcMaxX = windowXMax;
	protected	static int		dcMaxY = windowYMax;
	protected	static final int		dcGridSpaceX = 20;
	protected	static final int		dcGridSpaceY = 20;
	protected	static final int 		visibleDCWidthChars = 25;
	protected	static final int 		visibleDCHeightChars = 10;

	protected	static final int		DCMsg = 0;	
	protected	static final int		DCRefresh = 1;	
	protected	static final int		DCLoadFromDB = 0;
	protected	static final int		DCLoadFromXML = 1;

	protected	static final int		FeatureNone = 0;	
	protected	static final int		FeatureAdmin = 1;	

	protected	static final String		IDENTITY_XSLT = "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'" + " version='1.0'>" + "<xsl:template match='/'><xsl:copy-of select='.'/>" + "</xsl:template></xsl:stylesheet>";

	protected	static final int		aviRHS = 1;
	protected	static final int		aviLHS = -1;
	protected	static final String		registrationEmail="endhousesoftware999@gmail.com";
	protected	static final String		adminEmail="endhousesoftware999@gmail.com";
	protected	String		exHelpFile=dataRelativePath+"/"+appDirectory+"/"+"documents/help.xml";
	protected	static String			exFAQFile="";
	protected	static final String		appDirectory = "hdlworkbench";
	protected	static final String		appClassName = "hdlworkbench";
	protected	static final String		appBaseURL = "http://endhousesoftware.byethost11.com";
	
	public		String		splashJPG = dataRelativePath+"/"+appDirectory+"/hdlwb_logo.jpg";
	public		String		rotateJPG = dataRelativePath+"/"+appDirectory+"/rotate.png";

	protected	static final int		iconWidth = 16;
	protected	static final int		iconHeight = 16;
	
	public		static final int 		iNumberCharacetrsInHDLCodePopupWindowRow = 25;
	protected 	static final int		serverMode = 0;
	protected 	static final int		clientMode = 1;
	protected 	static final int		noneMode = 2;
	
	public		static final String		buildDate = "@@@Build Date: 8-March-2019 05:13 PM Build Number: 16@@@";
	public		static final String		frameworkBuildDate="###JAVA Framework (Version 1.41-RC3)###";
	public 		static final String		gitVersionInfo = "!!!Git Version : 22.1e71052.master-dirty.2019-03-08.17:13:41!!!";
	
	public		static final String VHDLTypes = "bit,std_logic,int,string,qsim_state_vector,std_logic_vector";
	public		static final String VerilogTypes = "bit";
	
	//public		static final String standVHDLFunctions = "write";
	//public		static final String standVerilogFunctions = "write";
	// keywords that contain spaces in the source code must appear in pairs
	public		static final String		VHDLReservedWords = "force,end block,endblock,end record,endrecord,end case,endcase,end fuction,endfunction,end procedure,endprocedure,end loop,endloop,end process,endprocess,end component,endcomponent,port map,portmap,use entity,useentity,end if,endif,abs,access,after,alias,all,and,architecture,array,assert,attribute,begin,block,body,buffer,bus,case,component,configuration,constant,disconnect,downto,else,elsif,end,entity,exit,file,for,function,generate,generic,group,guarded,if,impure,in,inertial,inout,is,label,library,linkage,literal,loop,map,mod,nand,new,next,nor,not,null,of,on,open,or,others,out,package,port,postponed,procedure,process,pure,range,record,register,reject,rem,report,return,rol,ror,select,severity,signal,shared,sia,sll,sra,srl,subtype,then,to,transport,type,unaffected,units,util,use,variable,wait,when,while,with,xnor,xor";
	public		static final String[]		VHDLNYSWords = {"shared","postponed","pure","impure","guarded","bus","register","transport","inertial","reject"};
	// appear in pairs, attribute string,transtext (In transtext, *1 = , and *2 = atrribute signal and *3 = Entity Name and *4 = Scope and *5 = Optional Param (int) and *6 = Optional Param)
	// trans text strings need to contain spaces as they would if they had been through preProcessLine(...)
	public		static final String		VHDLAttribs="event,event ( '*2' ),active,active ( '*2' ),last_value,last_value ( '*2' ),last_event,last_event ( '*2' ),last_active,last_active ( '*2' ),driving_value,driving_value ( '*2' ),driving,driving ( '*2' ),transaction,transaction ( '*2' ),delayed,delayed ( '*2' *1 *5 ),stable,stable ( '*2' *1 *5 ),quiet,quiet ( '*2' *1 *5 )";
	// keywords that contain spaces in the source code must appear in pairs
	// trans text strings need to contain spaces as they would if they had been through preProcessLine(...)
	public		static final String		VerilogReservedWords = "force,and,always,assign,begin,buf,bufif0,bufif1,case,casex,casez,cmos,deassign,default,defparam,disable,edge,else,end,endcase,endfunction,endprimitive,endmodule,endspecify,endtable,endtask,event,for,force,forever,fork,function,highz0,highz1,if,ifnone,initial,inout,input,integer,join,large,macromodule,medium,module,nad,negedge,nor,not,notif0,notif1,nmos,or,output,parameter,pmos,posedge,primitive,pulldown,pullup,pull0,pull1,rcmos,real,realtime,reg,release,repeat,rnmos,rpmos,rtran,rtranif0,rtranif1,scalared,small,specify,specparam,strength,string0,strong1,supply0,supply1,table,task,tran,tranif0,tranif1,time,tri,triand,trior,trireg,tri0,tri1,vectored,wait,wand,weak0,weak1,while,wire,wor,xnor,xor";
	public		static final String[]		VerilogNYSWords = {""};
	// appear in pairs, attribute string,transtext (In transtext, *1 = , and *2 = atrribute signal and *3 = Entity Name and *4 = Scope and *5 = Optional Param (int) and *6 = Optional Param)
	public		String		VerilogAttribs="attrib,transtext";
	public		String		VHDLTransTableName = ""+dataRelativePath+"/" + appDirectory + "/transtables/vhdl.ttd";
	public		String		VerilogTransTableName = ""+dataRelativePath+"/" + appDirectory + "/transtables/verilog.ttd";
	
	public		static boolean	bRunAppWithGUI = false;
	
	protected 	MediaTracker			bilmt = new MediaTracker(this);
	public		Component				lastPositionWindow = null;
	
	public		msg3Dialog				hdlCodeWindow = null;
	public 		msg3Dialog getHDLCodeWindow() {return hdlCodeWindow;}
	public 		void setHDLCodeWindow(msg3Dialog m3d) {hdlCodeWindow = m3d;}
	
	// these class member variables have been moved up to this level so that they can be accessed by other classes easily - naughty!!!
	public		String 				currentProcessName = "";
	public 		int 				passNumber;
	public		int					noNameProcessesID = 0;
	public		String				arrayNamesProcessed = "";

	public		int						ttDIWidth = 125;
	public		int						ttDIHeight = 30;
	public		Map<String,Vector>		transTableMap = new HashMap<String,Vector>();
	public		static final int		transTableNoJump = 99;
			
	public static final int			unconstrainedArrayValue = 9999;
	
	public		static boolean		bRunningAsApplication = false;
	public 		boolean				isApplication() {return bRunningAsApplication;}
	public 		boolean				isApplet() {return !isApplication();}
    public String COLLAPSIBLE_AREA_ELEMENT="collapsible_area_element";
	
	private	scrollableDrawingCanvas sDC = null;
	public drawingCanvas getDrawingCanvas() {
		if (sDC != null) {
			return sDC.getDC();
		}
		
		return (drawingCanvas)null;
	}

	public String getTTName() {
		return "";
	}
	public void displayTransTableEditor() {
		int xMax = 5000;
		int yMax = 5000;
		translationTable transTable = new translationTable();
		transTable.loadTranslationTable(getTTName());
		
		if (transTable != null) {
			JPanel keyPanel = new JPanel();
			ehsFile f = new ehsFile(dataRelativePath + "/" + appDirectory + "/documents/ttkey.txt");
			JTextArea text = new JTextArea(f.loadFile(),10,30);
			text.setEditable(false);
			text.setBackground(lightyellow);
			keyPanel.add(text);
			floatingWindow keyWindow = new floatingWindow(keyPanel,"Trans Table Key");
			keyWindow.setLocation(0,0);
			transTableCanvasDialog d = new transTableCanvasDialog(null,"Trans Table Editor","entity",xMax,yMax,transTable);			
			keyWindow.destory();
			if (d.isOK()) {
				xmlDataFile ttItems = new xmlDataFile();
				if (ttItems.openXMLDataFile(supportFunctions.getPathFilenameNoExt(getTTName()),"transtable",true)) {
					org.w3c.dom.Element root = ttItems.getRootElement();
					org.w3c.dom.Document doc = ttItems.getXMLDocument();
					for (Map.Entry<String, Vector> entry : transTableMap.entrySet()) {
						String key = entry.getKey();
						Vector value = entry.getValue();
						// assume first DI item is the keyword
						transTableDrawingItem di = (transTableDrawingItem)value.elementAt(0);
						org.w3c.dom.Element keywordnode = doc.createElement("ttkeyword");
						keywordnode.setAttribute("keyword",key);
						root.appendChild(keywordnode);
						
						if (value.size() > 1) {
							for (int i=1;i<value.size();i++) {
								di = (transTableDrawingItem)value.elementAt(i);
								org.w3c.dom.Element node = doc.createElement("ttentry");
								node.setAttribute("syntax",di.getText());
								node.setAttribute("transtext",di.getTransText());
								node.setAttribute("flags",di.getFlags());
								node.setAttribute("prestring",di.getPreString());
								node.setAttribute("poststring",di.getPostString());
								node.setAttribute("groupid",String.valueOf(di.getTTGroupID()));
								keywordnode.appendChild(node);
							}
						}
					}
					
					ttItems.saveXMLDataFile();
					ttItems.closeXMLDataFile();
					displayDialog("XML Translation Table File Saved, Tokens:" 
							+ String.valueOf(transTableMap.size()));
				}
			}
		} else {
			displayDialog("Can not load translation table");
		}
	}

	/**
 * This implementation of the Stroke interface draws a text along the path of 
 * the stroked Shape. Optionally, the text can be cycled along the path. That is,
 * the text is repeats the text along the shape as many times as needed to cover 
 * the full Shape path. Otherwise, the text is drawn only once.
 *
 * @author     Vincent Hardy
 * @version    1.0, 09/09/98
 */
public class TextStroke implements Stroke{
  static final String ERROR_INVALID_TEXT_ARGUMENT = "Error : text should be non null and contain non white-space characters";
  final FontRenderContext frc = new FontRenderContext(null, true, true);
  static final int FLATTENESS = 1;

  /**
   * 
  /**
   * Holds the description of the Text glyphs which are drawn along the stroked
   * Shapes path.
   */
  private GlyphVector glyphVector;

  /**
   * Ascent for the glyphVector
   */
  private float ascent;

  /**
   * Number of glyphs in Vector
   */
  private int nGlyphs;

  /**
   * Controls whether or not the text should be repeated
   */
  private boolean cycle;

  /**
   * Size of the spacing between two iterations of the text string
   */
  private float cycleGap;

  /**
   * Text drawn along the stroked shapes's path
   */
  private String text;

  /**
   * Font used to draw text along stroked shapes
   */
  private Font font;

  /**
   * @param text the text to be drawn along the path of stroked Shapes.
   * @param font the font used to create the text glyphs.
   * @param cycle true if the text should be repeated as many times as needed along
   *        the stroked paths.
   * @param cycleGap size of the gap between cycles of text. Ignored if cycle is false.
   *        if cycleGap is negative, it defaults to the font size.
   */
  public TextStroke(String text, Font font, boolean cycle, float cycleGap){
    if(text==null || text.trim().length()==0)
      throw new IllegalArgumentException(ERROR_INVALID_TEXT_ARGUMENT);

    if(font==null)
      throw new NullPointerException();

    glyphVector = font.createGlyphVector(frc, text);
    glyphVector.performDefaultLayout();
    nGlyphs = glyphVector.getNumGlyphs();
    LineMetrics metrics = font.getLineMetrics(text, frc);
    this.ascent = metrics.getAscent();
    this.cycle = cycle;
    this.cycleGap = cycleGap;
    if(cycleGap<0)
      this.cycleGap = font.getSize();

    this.text = text;
    this.font = font;
  }

  /**
   * Stroke interface implementation. 
   */
  public Shape createStrokedShape(Shape shape){
    // Flatten path.
    PathIterator pi = new FlatteningPathIterator(shape.getPathIterator(new AffineTransform()), FLATTENESS);

    // Iterate through the path and process each
    // line segment.
    float seg[] = new float[6];
    int segType = 0;
    ProcessSegmentControl ctl = new ProcessSegmentControl();
    boolean stop = false;

    while(!pi.isDone()){
      segType = pi.currentSegment(seg);
      switch(segType){
      case PathIterator.SEG_MOVETO:
	// Moving to a new start.
	ctl.x = seg[0];
	ctl.y = seg[1];
	ctl.mx = ctl.x;
	ctl.my = ctl.y;
	ctl.start = true;
	break;
      case PathIterator.SEG_LINETO:
	// New line segment, try to add glyphs on the path.
	ctl.dx = seg[0];
	ctl.dy = seg[1];
	stop = processSegment(ctl);
	ctl.start = false;
	break;
	
      case PathIterator.SEG_CLOSE:
	// Closing to the last move to position.
	ctl.dx = ctl.mx;
	ctl.dy = ctl.my;
	stop = processSegment(ctl);
	break;
	
      case PathIterator.SEG_QUADTO:
      case PathIterator.SEG_CUBICTO:
      default:
	// This should never happen because we are using a FlatteningPathIterator
	throw new Error("Illegal seg type : " + segType);
      }
      pi.next();
      if(stop)
	break;
    }    

    return ctl.s;
  }

  /**
   * Process a new segment of the stroked shape
   */
  private boolean processSegment(ProcessSegmentControl ctl){
    boolean stop = false;

    // Process current segment length
    float segLength = (float)Point2D.distance(ctl.x, ctl.y, 
					      ctl.dx, ctl.dy);

    // Segment slope factors
    float dx = (ctl.dx-ctl.x)/segLength;
    float dy = (ctl.dy-ctl.y)/segLength;

    // Adjust start position
    ctl.x -= dx*ctl.startCredit;
    ctl.y -= dy*ctl.startCredit;

    // Initial insert point
    float insertDist = ctl.ngx-ctl.d;
    float x = ctl.x + insertDist*dx;
    float y = ctl.y + insertDist*dy;

    // Angle the current segment makes with the x-axis
    float rotationAngle = (float)Math.atan2(ctl.dy-ctl.y, ctl.dx-ctl.x);

    // Check if this segment overlaps with the previous one.
    float shiftDistance = 0;
    if(!ctl.start){ 
      // Do not perform check in case this is the first segment after a moveTo
      // because the previous segment is considered non-relevant.
      float deltaAngle = rotationAngle - ctl.previousAngle;
      if(deltaAngle<-Math.PI) deltaAngle += 2*(float)Math.PI;
      if(deltaAngle>Math.PI) deltaAngle -= 2*(float)Math.PI;

      if(deltaAngle<0){
	// The current segment overlaps with the previous one
	// Shift starting point to avoid overlapping.
	shiftDistance = Math.abs(ascent*(float)Math.tan(deltaAngle/2));
	segLength -= shiftDistance;
	x += shiftDistance*dx;
	y += shiftDistance*dy;
      }
    }

    // Only process if the next insert point is within the segment
    // and the glyph to insert fits in segment
    if( (ctl.d + ctl.startCredit + segLength)> (ctl.ngx + ctl.glyphWidth) ){  
      // Update the previousAngle if a glyph is actuall inserted.
      ctl.previousAngle = rotationAngle;

      // Process the rotation which should be applied to glyphs
      // prior to inserting them into the stroked path.
      // The rotation is centered about the insert point
      // and its angle is that of the segment with the x axis.
      AffineTransform at = new AffineTransform();

      // Translate glyphs so that the baseline is on the current segment
      at.translate(x-ctl.ngx, y-ctl.ngy);      
      at.rotate(rotationAngle, ctl.ngx, ctl.ngy);
      at.concatenate(ctl.defaultTransform);

      // Used to store the remaining length in current segment
      float remainingSegLength = segLength + ctl.startCredit;

      // Transform used to position glyph
      AffineTransform glyphTransform = new AffineTransform();

      // Controls whether the next glyph fits on current segment
      boolean fits = true;
      while(fits){
	// Add glyph to stroked path
	Point2D glyphPos = glyphVector.getGlyphPosition(ctl.glyphIndex);
	glyphTransform.setToIdentity();
	glyphTransform.concatenate(at);
	glyphTransform.translate(glyphPos.getX(), glyphPos.getY());
	ctl.s.append( glyphTransform.createTransformedShape(glyphVector.getGlyphOutline(ctl.glyphIndex)), false );

	// Update 'used' distance
	// ctl.d += ctl.glyphWidth;
	float newD = (float)ctl.defaultTransform.getTranslateX() + (float)glyphPos.getX() + ctl.glyphWidth;

	// Some of the current segment has been used...
	remainingSegLength -= (newD - ctl.d); // ctl.glyphWidth;

	ctl.d = newD;

	// Update segment starting point
	ctl.x += ctl.glyphWidth*dx;
	ctl.y += ctl.glyphWidth*dy;

	// Update next glyph's index : stop if not cycling
	// and end has been reached.
	ctl.glyphIndex++;
	if(ctl.glyphIndex>=nGlyphs){
	  if(!cycle){
	    stop = true;
	    fits = false;
	  }
	  else{
	    // We have reached the end of the text. We are going to cycle.
	    // Adjust the default transform to take that into account.
	    ctl.defaultTransform.translate((float)glyphVector.getVisualBounds().getWidth() + cycleGap, 0);
	    at.translate((float)glyphVector.getVisualBounds().getWidth() + cycleGap, 0);
	  }
	}

	if(!stop){
	  ctl.glyphIndex %= nGlyphs;
	  
	  // Distance at wich the next insert will happen
	  ctl.ngx = (float)ctl.defaultTransform.getTranslateX() + (float)glyphVector.getGlyphPosition(ctl.glyphIndex).getX();
	  ctl.ngy = (float)glyphVector.getGlyphPosition(ctl.glyphIndex).getY();

	  // Width of the next glyph
	  // ctl.glyphWidth = glyphVector.getGlyphOutline(ctl.glyphIndex).getBounds().width;
	  ctl.glyphWidth = glyphVector.getGlyphLogicalBounds(ctl.glyphIndex).getBounds().width;
	  
	  // Check if next glyph fits
	  fits = (ctl.d + remainingSegLength)> (ctl.ngx + ctl.glyphWidth);
	}
      }

      ctl.x = ctl.dx;
      ctl.y = ctl.dy;
      ctl.startCredit = remainingSegLength;
    }

    return stop;
  }

  public String getText(){
    return text;
  }

  public Font getFont(){
    return font;
  }

  public boolean isCycle(){
    return cycle;
  }

  public float getCycleGap(){
    return cycleGap;
  }

  /*
   * Class used to hold information about the path currently being
   * stroked.
   */
  class ProcessSegmentControl{
    /** Current segment start */
    float x, y;

    /** Last move coordinates */
    float mx, my;

    /** Current segment end */
    float dx, dy;

    /** Used when iterating through a path to store the amount of space not
     * used which can be used in the following segment.
     */
    float startCredit;

    /** Current cumulated distance of 'used' path.*/
    float d;

    /** Next insert can happen at this cummulated distance*/
    float ngx;

    /** Next insert can happen at this elevation */
    float ngy;

    /** Width of the next glyph to be inserted */
    int glyphWidth;

    /** Index of the next glyph to place on path */
    int glyphIndex;

    /** Controls if the current segment is the first one after a moveTo */
    boolean start;

    /** Angle that the previous segment makes with the x-axis. This is used 
     *  to detect situations where the text of one segment might overlap on
     *  the previous one.
     */
    float previousAngle;

    /** Stroked path */
    GeneralPath s = new GeneralPath();

    /** Used to adjust glyphVector position when the text is repeated over
     * the stroked shape.
     */
    AffineTransform defaultTransform = new AffineTransform();

    /**
     * Constructor 
     */
    public ProcessSegmentControl(){
      glyphWidth = glyphVector.getGlyphOutline(0).getBounds().width;
    }
  }
}

	static appletframe theApp = null;
	Properties commandLineArgs = new Properties();
	public void extraStatusInfo() {
		
	}
	public void applicationCode(String[] args) {				
		boolean updateHelpSystem = false;
		int argID = 0;
		TRACELEVEL = 999;
		boolean bStatus = false;
		for (int i=0;i<args.length;i++) {
			if (args[i].equals("trace")) {
				TRACELEVEL = 4;
				continue;
			}
			if (args[i].equals("status")) {
				bStatus = true;
			}
			if (args[i].equals("updatehelp")) {
				updateHelpSystem = true;
				continue;
			}
			if (args[i].equals("symboldump")) {
				bSymbolDump = true;
				continue;
			}
			if (args[i].equals("about")) {
				BufferedReader br = null;
				try {
					String sCurrentLine;
					br = new BufferedReader(new FileReader(dataRelativePath+"/"+appDirectory+"/readme.txt"));
					while ((sCurrentLine = br.readLine()) != null) {
						System.out.println(sCurrentLine);
					}
				} catch (IOException e) {
					e.printStackTrace();
				} finally {
					try {
						if (br != null)br.close();
					} catch (IOException ex) {
						ex.printStackTrace();
					}
				}
				continue;
			}
			StringTokenizer st = new StringTokenizer(args[i],"=");
			Vector v = new Vector();
			while(st.hasMoreTokens()) {
				v.addElement(st.nextToken());
			}
			if (v.size() == 1) {v.insertElementAt("arg"+String.valueOf(argID++),0);}
			String opt = (String)v.elementAt(0);
			//if (opt.charAt(0) == '-') {opt = opt.substring(1);} // remove - character
			commandLineArgs.put(opt,(String)v.elementAt(1));
		}
		
		systemUserReg = new registrationinfo("HDL Work Bench","HDL Work Bench (Application)","WB1000","01.63.0000.00","01/02/18","(c) End House Software 2007-2019",bRemoteHosted);
		System.out.println(systemUserReg.getApplicationInfoText() + "\n");
		systemMysql = new mysqlJDBC();
		systemMysql.connect();
		systemUserReg.registerUser();

		if (bStatus) {
			if (systemMysql.getConnection() == null) {
				System.out.println("Database Status: FAILED");
			} else {
				System.out.println("Database Status: OK");
				System.out.println("Database Product: " + systemMysql.getDatabaseProduct());
				System.out.println("Database Version:" + systemMysql.getDatabaseVersion());				
			}
			System.out.println("Registered To: " + systemUserReg.getUserName());

			extraStatusInfo();
			
			systemMysql.disconnect();
			System.exit(0);			
		}

		lStrings = new languageStrings();
		writeHitRecord("hdlwb");
		if (updateHelpSystem == true) {
			System.out.println("Updating Help System...");
			updateHelpTopics(systemUserReg.getAppName(),exHelpFile,true);
		}
		String file = (String)commandLineArgs.get("arg0");
		if (file != null) {
				hdlworkbench = new hdlSystem();
				//file = "..\\..\\applications\\" + appDirectory + "\\" + file;
				System.out.println("Compiling " + file + " ...\n");
				hdlworkbench.resetSystemState();
				hdlworkbench.setSystemName(file);
				hdlworkbench.setSystemModified(false);
				hdlworkbench.setSystemFile(new ehsFile(file));
				if (hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).compile(hdlworkbench.getSystemName())) {
					System.out.println("Compile successful.\n");
				} else {
					System.out.println(hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getErrorString() + "\n");
				}
				if (bSymbolDump) {
					HDLCompiler hdlComp = (HDLCompiler)hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex());
					System.out.println("\n" + hdlComp.getAllSymbolTable().dumpSymbols());
				}
		} else {
			System.out.println("Usage: java -jar hdlworkbench.jar [status] [gui] [trace] [about] [symboldump] [updatehelp] filename\n");
		}
		
		systemMysql.disconnect();
		System.exit(0);
	}
	public static void main(String[] args) {
		bRunningAsApplication = true;
		for (int i=0;i<args.length;i++) {
			if (args[i].equals("gui")) {
				bRunAppWithGUI = true;
			}
		}
		if (bRunAppWithGUI) {
			new appletframe(new hdlworkbench(),windowXMax,windowYMax);
		} else {
			theApp = new appletframe(new hdlworkbench());
			hdlworkbench tmp = (hdlworkbench)theApp.getApplet();
			tmp.applicationCode(args);
		}
	}

	public void start() {
		TRACE("start() called",3);
		runThreads = true;
		systemThread1 = new Thread(this);
		systemThread1.setPriority(systemMsgThreadPrioity);
		systemThread1.setName("HDL Work Bench - System Message Thread 1");
		systemThread1.start();
	}

	public void stop() {
		TRACE("stop() called",3);
		runThreads = false;
	}

	public void destroySystem() {
		
		destroyApplication();
	}
	public void destroyApplication() {	
		runThreads = false;
		finishPerApplicationProcess();
		systemAudioClips.unloadAllSounds();
		systemMysql.disconnect();
	}
	public void destroy() {
		TRACE("destroy() called",4);
		destroySystem();
	}

	public void run() {
		while (runThreads) {
			try {
				systemThread1.sleep(sysThreadSleep);
			} catch (InterruptedException e) {break;}	
		}
	}	

	public Color getColorCode(String colorName) {
		   for (int i=0;i<colors.length;i++) {
		   	   if (colorName.equalsIgnoreCase(colors[i])) {
			   	  return colorCodes[i];
			   }
		   }
		   return (Color)null;
	  }
	  public String getColorName(Color c) {
		  for (int i=0;i<colorCodes.length;i++) {
			  if (c == colorCodes[i]) {return colors[i];}
		  }
		  return "";
	  }
	  
	public void boxCenterText(Graphics g,Color back,String s1,String s2,int x,int y,int w,int h) {
		boxCenterText(g,back,s1,s2,x,y,w,h,true);
	}
	public void boxCenterText(Graphics g,Color back,String s1,String s2,int x,int y,int w,int h,boolean bRect) {
		Font orgFont = g.getFont();
		int height,ascent;
		int width1=0,width2=0,x0=0,x1=0,y0=0,y1=0;
		float size = g.getFont().getSize();
		size = size + 1;
		do { // reduce the font size until the text fits in the bounding box
			Font newFont = g.getFont().deriveFont(size - 1);
			g.setFont(newFont);
			FontMetrics fm1 = getFontMetrics(newFont);
			width1 = fm1.stringWidth(s1);
			if (s2.length() != 0) width2 = fm1.stringWidth(s2);
			height = fm1.getHeight();
			ascent = fm1.getAscent();
			size = size - 1;
		}
		while(((width1 > w) || (width2  > w)) && size > 0);
		x0 = x + (w - width1) / 2;
		x1 = x + (w - width2) / 2;
		if (s2.length() == 0) {
			y0 = y + (h - height) / 2 + ascent;
		} else {
			y0 = y + (h - (int)(height * 2.2)) / 2 + ascent;
			y1 = y0 + (int)(height * 1.2);
		}
		g.setColor(Color.black);
		if (bRect) {
			g.setColor(back);
			g.fillRoundRect(x,y,w,h,20,20);
			g.setColor(Color.black);
			g.drawRoundRect(x,y,w,h,20,20);
		}
		g.drawString(s1,x0,y0);
		if (s2.length() != 0) {
			g.drawString(s2,x1,y1);
		}
		g.setFont(orgFont);
	}
	
	public void exec(String s,boolean b) {}
	
	public void boxCenterText(Graphics g,Color back,String s1,int x,int y,int w,int h) {
		boxCenterText(g,back,s1,"",x,y,w,h);
	}
	public void boxCenterText(Graphics g,Color back,String s1,int x,int y,int w,int h,boolean bRect) {
		boxCenterText(g,back,s1,"",x,y,w,h,bRect);
	}
	public void centerTextAtPoint(Graphics2D g,String text,int x,int y) {
		int width = fm.stringWidth(text);
		g.drawString(text,x - (width / 2),y);
	}
	public void centerTextAtBox(Graphics2D g,String text,int x,int y,int w,int h) {
		centerTextAtPoint(g,text,x + (w / 2),y + (h / 2));
	}
	public void centerTextAtBox(Graphics2D g,String text,Rectangle r) {
		centerTextAtBox(g,text,(int)r.getX(),(int)r.getY(),(int)r.getWidth(),(int)r.getHeight());
	}

	public int rand(int max) {return rand(0,max);}
	public int rand(int min, int max) {
		return (int)(Math.round(max * Math.random())) + min;
	}

	public boolean valueOf(String s) {
		if(s.equals("1")) {return true;}
		return false;
	}
	public String onOff(boolean b) {
		if(b) {return "On";} else {return "Off";}
	}
	public String valueOf(boolean b) {
		if(b) {return "1";} else {return "0";}
	}
	public Vector union(Vector v1,Vector v2) {
		String s1=reasembleTokens(v1);
		String s2=reasembleTokens(v2);
		String s = removeDupTokens(s1+s2);
		Vector v = supportFunctions.splitIntoTokens(s);
		return v;
	}
	public Vector intersect(Vector v1,Vector v2) {
		Vector v = new Vector();
		for(int i=0;i<v1.size();i++) {
			if(v2.contains((String)v1.elementAt(i))) {
				v.addElement((String)v1.elementAt(i));
			}
		}
		return v;
	}
	public Vector notIntersect(Vector v1,Vector v2) {
		Vector v = new Vector();
		for(int i=0;i<v1.size();i++) {
			if(!v2.contains((String)v1.elementAt(i))) {
				v.addElement((String)v1.elementAt(i));
			}
		}
		return v;
	}

	public int getSystemVar(String name, int defValue) {
		String data = "";
//		if(!systemUserReg.getUseDatabase()) {
//			data = getSystemVar(name,String.valueOf(defValue));
//		} else {
			data=systemMysql.executeSQLQuery("SELECT chatVarValue FROM chatvariables WHERE chatVarName='" + name + "'",String.valueOf(defValue));
//		}
		
		TRACE("data (getSystemVar) is " + data + " length="+String.valueOf(data.length()),3);
		if(data.length() == 0) {
			setSystemVar(name,defValue);
			return defValue;
		}

		int val = 0;
		try {
		   val = Integer.parseInt(data);
		} catch(Exception e) {e.printStackTrace();}
		return val;
	}

	public boolean getSystemVar(String name, boolean defValue) {
		String data="";
//		if(!systemUserReg.getUseDatabase()) {
//			data = getSystemVar(name,valueOf(defValue));
//		} else {
			data = systemMysql.executeSQLQuery("SELECT chatVarValue FROM chatvariables WHERE chatVarName='" + name + "'",valueOf(defValue));
//		}
		
		if(data.length() == 0) {
			setSystemVar(name,defValue);
			return defValue;
		}

 	    boolean ret = false;
		try {
		   if(Integer.parseInt(data) == 1) {ret = true;}
		} catch (Exception e) {e.printStackTrace();}
		
		return ret;
	}

	public String getSystemVar(String name, String defValue) {
		String data = "";
//		if(!systemUserReg.getUseDatabase()) {
//			TRACE("loading local file-"+name,4);
//			ehsFile xyz = new ehsFile("variables",name);
//			data = xyz.loadFile();
//		} else {
			data=systemMysql.executeSQLQuery("SELECT chatVarValue FROM chatvariables WHERE chatVarName='" + name + "'",defValue);
//		}
		
		if(data.length() == 0) {
			setSystemVar(name,defValue);
			return defValue;
		}

		return data.trim();
	}

	public String setSystemVar(String name, String val) {
//		if(!systemUserReg.getUseDatabase()) {
//			TRACE("saving local file-"+name+"-"+val,4);
//			String tmp = getCodeBase().getPath();
//			tmp = ".." + tmp;
//			tmp = getPath(tmp);
//			ehsFile xyz = new ehsFile(tmp,name);
//			ehsFile xyz = new ehsFile("variables",name);
//			xyz.saveFile(val);
//		} else {
			systemMysql.executeSQLQuery("REPLACE INTO chatvariables (chatVarName,chatVarValue) VALUES ('"+name+"','"+val+"')","");
//		}
		return val;
	}

	public int setSystemVar(String name, int val) {
//		if(!systemUserReg.getUseDatabase()) {
//			setSystemVar(name,String.valueOf(val));
//		} else {
			systemMysql.executeSQLQuery("REPLACE INTO chatvariables (chatVarName,chatVarValue) VALUES ('"+name+"','"+String.valueOf(val)+"')","");
//		}
		return val;
	}
	
	public boolean setSystemVar(String name, boolean val) {
//		if(!systemUserReg.getUseDatabase()) {
//			setSystemVar(name,valueOf(val));
//		} else {
			systemMysql.executeSQLQuery("REPLACE INTO chatvariables (chatVarName,chatVarValue) VALUES ('"+name+"','"+valueOf(val)+"')","");
//		}
		return val;
	}

	public Frame getTopLevelParent(Component component) {
		Component c = component;
		while(c.getParent() != null) {
			c=c.getParent();
		}
		if(c instanceof Frame) {
			return (Frame)c;
		} else {
			return null;
		}
	}

	public String stripEHSTags(String s) {
//		Source xslt = new StreamSource(new StringReader(IDENTITY_XSLT));
//		return doStringTransform(s,xslt);
		s = removeTags(s,"<ehs");
		s = removeTags(s,"</ehs");
		s = removeTags(s,"<?xml");
		s = removeTags(s,"<!DOCTYPE");
		return s;
	}
	
	public String removeTags(String s,String tagStart) {
		int index = s.indexOf(tagStart);
		while (index != -1) { // while we still have a tag
			int eindex = s.indexOf(">",index); // find the end of the tag
			if (eindex == -1) {break;} // if the end of the tag does not exist return
			
			if (index == 0) {index=1;} // tag right at beginning of line fudge
			if (eindex == s.length()-1) {s = s.substring(0,index-1);} else {s = s.substring(0,index-1) + s.substring(eindex+1);}
			
			index = s.indexOf(tagStart); // any more instances of the tag?
		}
		return s;
	}
	
	public String extractTagAttrib(String s,String tag,String attrib) {
		int index = s.indexOf(tag);
		if (index == -1) {return "";} // no tag found
		int eindex = s.indexOf(">",index);
		if (eindex == -1) {return "";}
		String tagAttrib = s.substring(index + tag.length(),eindex); // attribs will be in form attrib1="" attrib2="" ...
		
		String tmp = "";
		boolean replace = false;
		for(int i=0;i<tagAttrib.length();i++) {
			if(tagAttrib.charAt(i) == '\"' || tagAttrib.charAt(i) == '\'') {replace = !replace;}
			if(tagAttrib.charAt(i) == ' ' && replace) {tmp = tmp + "#";} else {tmp = tmp + tagAttrib.charAt(i);}
		}
		tagAttrib = tmp;
		
		Vector v = supportFunctions.splitIntoTokens(tagAttrib," ");
		for (int i=0;i<v.size();i++) {
			Vector v1 = supportFunctions.splitIntoTokens((String)v.elementAt(i),"=");
			String ret =  (String)v1.elementAt(1);
			ret = ret.replace('#',' ');
			ret = ret.replace("\'","");
			ret = ret.replace("\"","");
			if(attrib.equals((String)v1.elementAt(0))) {return ret;}
		}
		return ""; // no tag attribute found
	}

	public helpDialog displayHelpDialog() {
		   helpDialog d = new helpDialog(getTopLevelParent(this));
		   d.setLocation(defaultDialogX,defaultDialogY);
		   return d;
	}
	
	public void displayDialogOld(String msg) {
		Frame top = getTopLevelParent(this);
		msgDialog d = new msgDialog(top,msg);
		d.setLocation(defaultDialogX,defaultDialogY);
		d.dispose();
	}
	public void displayDialog(String msg) {
		displayDialogNew(msg,JOptionPane.INFORMATION_MESSAGE);
	}
	public void displayDialog(String msg, int iconType) {
		   displayDialogNew(msg,iconType);
	}
	public void displayDialogNew(String msg,int iconType) {
		   JOptionPane.showMessageDialog(getTopLevelParent(this),msg,systemUserReg.getAppNameVersion(),iconType);
	}
	
	public msg1Dialog displayModelessDialog(String msg) {
		Frame top = getTopLevelParent(this);
		msg1Dialog d = new msg1Dialog(top,systemUserReg.getAppName(),msg);
		return d;
	}
	public msg1Dialog displayModelessDialog(String title,String msg,String id) {
		Frame top = getTopLevelParent(this);
		msg1Dialog d = new msg1Dialog(top,title,msg,id);
		return d;
	}

	public msg2Dialog displayModelessStatusDialog(String msg,String id) {
		Frame top = getTopLevelParent(this);
		msg2Dialog d = new msg2Dialog(top,msg,false,id);
		return d;
	}
	public msg2Dialog displayModelessStatusDialog(String msg) {
		Frame top = getTopLevelParent(this);
		msg2Dialog d = new msg2Dialog(top,msg,false);
//		d.setLocation(defaultDialogX,defaultDialogY);
		return d;
	}

	public msg2Dialog displayCancelModelessStatusDialog(String msg) {
		Frame top = getTopLevelParent(this);
		msg2Dialog d = new msg2Dialog(top,msg,true);
//		d.setLocation(defaultDialogX,defaultDialogY);
		return d;
	}

	public msg3Dialog displayPanelDialog(JPanel p,String title) {
		Frame top = getTopLevelParent(this);
		msg3Dialog d = new msg3Dialog(top,p,title);
//		d.setLocation(defaultDialogX,defaultDialogY);
		return d;
	}
	public msg3Dialog displayPanelDialog(JPanel p,String title,boolean bModel) {
		Frame top = getTopLevelParent(this);
		msg3Dialog d = new msg3Dialog(top,p,title,bModel);
		return d;
	}

	public String getAppletInfo() {
		return systemUserReg.getAppCopyright();
	}
	
	public void setNativeLookAndFeel() {
		   try {
		   	   UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		   } catch(Exception e) {}
	}
			


public class simpleftp {
    
    
    /**
     * Create an instance of SimpleFTP.
     */
    public simpleftp() {
        
    }
    
    
    /**
     * Connects to the default port of an FTP server and logs in as
     * anonymous/anonymous.
     */
    public synchronized void connect(String host) throws IOException {
        connect(host, 21);
    }
    
    
    /**
     * Connects to an FTP server and logs in as anonymous/anonymous.
     */
    public synchronized void connect(String host, int port) throws IOException {
        connect(host, port, "anonymous", "anonymous");
    }
    
    
    /**
     * Connects to an FTP server and logs in with the supplied username
     * and password.
     */
    public synchronized void connect(String host, int port, String user, String pass) throws IOException {
        if (socket != null) {
            throw new IOException("SimpleFTP is already connected. Disconnect first.");
        }
        socket = new Socket(host, port);
        reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
        
        String response = readLine();
        if (!response.startsWith("220 ")) {
            throw new IOException("SimpleFTP received an unknown response when connecting to the FTP server: " + response);
        }
        
        sendLine("USER " + user);
        
        response = readLine();
        if (!response.startsWith("331 ")) {
            throw new IOException("SimpleFTP received an unknown response after sending the user: " + response);
        }
        
        sendLine("PASS " + pass);
        
        response = readLine();
        if (!response.startsWith("230 ")) {
            throw new IOException("SimpleFTP was unable to log in with the supplied password: " + response);
        }
        
        // Now logged in.
    }
    
    
    /**
     * Disconnects from the FTP server.
     */
    public synchronized void disconnect() throws IOException {
        try {
            sendLine("QUIT");
        }
        finally {
            socket = null;
        }
    }
    
    
    /**
     * Returns the working directory of the FTP server it is connected to.
     */
    public synchronized String pwd() throws IOException {
        sendLine("PWD");
        String dir = null;
        String response = readLine();
        if (response.startsWith("257 ")) {
            int firstQuote = response.indexOf('\"');
            int secondQuote = response.indexOf('\"', firstQuote + 1);
            if (secondQuote > 0) {
                dir = response.substring(firstQuote + 1, secondQuote);
            }
        }
        return dir;
    }


    /**
     * Changes the working directory (like cd). Returns true if successful.
     */   
    public synchronized boolean cwd(String dir) throws IOException {
        sendLine("CWD " + dir);
        String response = readLine();
        return (response.startsWith("250 "));
    }
    
    
    /**
     * Sends a file to be stored on the FTP server.
     * Returns true if the file transfer was successful.
     * The file is sent in passive mode to avoid NAT or firewall problems
     * at the client end.
     */
    public synchronized boolean stor(File file) throws IOException {
        if (file.isDirectory()) {
            throw new IOException("SimpleFTP cannot upload a directory.");
        }
        
        String filename = file.getName();

        return stor(new FileInputStream(file), filename);
    }
    
    
    /**
     * Sends a file to be stored on the FTP server.
     * Returns true if the file transfer was successful.
     * The file is sent in passive mode to avoid NAT or firewall problems
     * at the client end.
     */
    public synchronized boolean stor(InputStream inputStream, String filename) throws IOException {

        BufferedInputStream input = new BufferedInputStream(inputStream);
        
        sendLine("PASV");
        String response = readLine();
        if (!response.startsWith("227 ")) {
            throw new IOException("SimpleFTP could not request passive mode: " + response);
        }
        
        String ip = null;
        int port = -1;
        int opening = response.indexOf('(');
        int closing = response.indexOf(')', opening + 1);
        if (closing > 0) {
            String dataLink = response.substring(opening + 1, closing);
            StringTokenizer tokenizer = new StringTokenizer(dataLink, ",");
            try {
                ip = tokenizer.nextToken() + "." + tokenizer.nextToken() + "." + tokenizer.nextToken() + "." + tokenizer.nextToken();
                port = Integer.parseInt(tokenizer.nextToken()) * 256 + Integer.parseInt(tokenizer.nextToken());
            }
            catch (Exception e) {
                throw new IOException("SimpleFTP received bad data link information: " + response);
            }
        }
        
        sendLine("STOR " + filename);
        
        Socket dataSocket = new Socket(ip, port);
        
        response = readLine();
        if (!response.startsWith("150 ")) {
            throw new IOException("SimpleFTP was not allowed to send the file: " + response);
        }
        
        BufferedOutputStream output = new BufferedOutputStream(dataSocket.getOutputStream());
        byte[] buffer = new byte[4096];
        int bytesRead = 0;
        while ((bytesRead = input.read(buffer)) != -1) {
            output.write(buffer, 0, bytesRead);
        }
        output.flush();
        output.close();
        input.close();
        
        response = readLine();
        return response.startsWith("226 ");
    }


    /**
     * Enter binary mode for sending binary files.
     */
    public synchronized boolean bin() throws IOException {
        sendLine("TYPE I");
        String response = readLine();
        return (response.startsWith("200 "));
    }
    
    
    /**
     * Enter ASCII mode for sending text files. This is usually the default
     * mode. Make sure you use binary mode if you are sending images or
     * other binary data, as ASCII mode is likely to corrupt them.
     */
    public synchronized boolean ascii() throws IOException {
        sendLine("TYPE A");
        String response = readLine();
        return (response.startsWith("200 "));
    }
    
    
    /**
     * Sends a raw command to the FTP server.
     */
    private void sendLine(String line) throws IOException {
        if (socket == null) {
            throw new IOException("SimpleFTP is not connected.");
        }
        try {
            writer.write(line + "\r\n");
            writer.flush();
            if (DEBUG) {
                System.out.println("> " + line);
            }
        }
        catch (IOException e) {
            socket = null;
            throw e;
        }
    }
    
    private String readLine() throws IOException {
        String line = reader.readLine();
        if (DEBUG) {
            System.out.println("< " + line);
        }
        return line;
    }
    
    private Socket socket = null;
    private BufferedReader reader = null;
    private BufferedWriter writer = null;
    
    private boolean DEBUG = false;
}
	public class hdlSystem {
		private compiler[] compilers = new compiler[2];
		private int currentCompilerIndex = 0;
		private String hdlSystemName = "Untitled";
		private boolean hdlSystemModified = false;
		private boolean hdlSystemCompiled = false;
		private ehsFile hdlSystemFile = null;
		private int iSheet;
		private int iMaxLevel;
		private int iMarginWidth,iMarginHeight;
		
		public int getMarginWidth() {return iMarginWidth;}
		public int getMarginHeight() {return iMarginHeight;}
		public void setSystemFile(ehsFile tmp) {hdlSystemFile = tmp;}
		public ehsFile getSystemFile() {return hdlSystemFile;}
		public void setSystemName(String tmp) {hdlSystemName = tmp;}
		public String getSystemName() {return hdlSystemName;}
		public boolean getSystemModified() {return hdlSystemModified;}
		public void setSystemModified(boolean tmp) {hdlSystemModified = tmp;}
		public boolean getSystemCompiled() {return hdlSystemCompiled;}
		public void setSystemCompiled(boolean tmp) {hdlSystemCompiled = tmp;}
		
		public hdlSystem() {
			iMaxLevel = -1;
			iSheet = 1;
			iMarginWidth =  10 * charWidth;
			iMarginHeight =  2 * charHeight;
			compilers[1] = new VerilogCompiler();
			compilers[0] = new VHDLCompiler();
		}
		public void resetSystemState() {
			iMaxLevel = -1;
			iSheet = 1;
			hdlSystemModified = false;
			hdlSystemCompiled = false;
			hdlSystemName = "Untitled";
			hdlSystemFile = null;
		}
		public int getMaxLevel() {return iMaxLevel;}
		public void setMaxLevel(int i) {iMaxLevel = i;}
		public int getCurrentSheet() {return iSheet;}
		public void setCurrentSheet(int i) {iSheet = i;}
		public void setCompilerIndex(int i) {currentCompilerIndex = i;}
		public int getCompilerIndex() {return currentCompilerIndex;}
		public compiler getCompiler(int index) {return compilers[index];}
			public int getNumberOfCompilers() {return compilers.length;}
	}

	public class JScrollPaneEHS extends JScrollPane {
		JScrollPaneEHS() {
			super(); 
		}
		JScrollPaneEHS(Component view) {
			super(view); 
		}
		public void scrollToLastLine() {
			JScrollBar tmp = verticalScrollBar;
			tmp.setValue(tmp.getMaximum());
		}
	}
	
	public Font getUnderlinedFont(Font f) {
		Map<TextAttribute, Integer> fontAttributes = new HashMap<TextAttribute, Integer>();
		fontAttributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
		return f.deriveFont(fontAttributes);
	}	
	public class ImageExtra extends Component {
		private BufferedImage 	bi;
		
		public ImageExtra() {
			bi = null;
		}
		public ImageExtra(BufferedImage i) {
			bi = i;
		}
		public ImageExtra(Image im) {
		     bi = fromImage(im);
		}
		public BufferedImage fromImage(Image im) {
		     BufferedImage bi = new BufferedImage(im.getWidth(null),im.getHeight(null),BufferedImage.TYPE_INT_RGB);
		     Graphics bg = bi.getGraphics();
		     bg.drawImage(im, 0, 0, null);
		     bg.dispose();
		     return bi;
		}
		public BufferedImage getBufferedImage() {
			//return createImage(new MemoryImageSource(width,height,pixels,0,width));
			return bi;
		}
		public BufferedImage loadImageWithMT(String name) {
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			MediaTracker picTracker = new MediaTracker(this);
			Image i = toolkit.getImage(name);
			picTracker.addImage(i,0);
			try {picTracker.waitForID(0);} catch (InterruptedException e) {}
			if (picTracker.isErrorAny()) {
				TRACE("Error in loading image " + name,4);
			}
			
			bi = fromImage(i);
			return bi;
		}
		public BufferedImage loadImage(String name) {
			try {
				if (isApplication()) {
						bi = ImageIO.read(new File(name));
				} else {
					URL u = new URL(getCodeBase(),name);
					bi = ImageIO.read(u);
				}
			} catch (IOException e) {;}
			return bi;
		}
		public void saveImage(String name) {
			try {
				if (isApplication()) {
					File outputfile = new File(name);
					ImageIO.write(bi, "jpg", outputfile);
				} else {
					File outputfile = new File(name);
					ImageIO.write(bi, "jpg", outputfile);
				}
			} catch (IOException e) {;}
			
		}
	}

	public void TRACE(String msg,Vector v,int level) {
		if (v.size() == 0) {TRACE(msg,level);return;}
		String tmp = (String)v.elementAt(0);
		for (int i=1;i<v.size();i++) {
			tmp = tmp + "," + (String)v.elementAt(i);
		}
		TRACE(msg + ":" + tmp,level);
	  }
	  public void TRACE(String msg) {
		  TRACE(msg,3);
	  }
	  public void TRACE(String msg,int level) {
		if(level < TRACELEVEL) {return;}			
		//if (isApplication()) {return;}
		int threadP = Thread.currentThread().getPriority();
		System.err.println("("+currentDate()+" "+currentTime()+") ["+Thread.currentThread().getName()+" ("+String.valueOf(threadP)+")] "+msg);
	  }	  
	
	  public class hdlSearchReplaceDialog extends searchreplaceDialog {
		  public hdlSearchReplaceDialog(Frame parent) {
			  super(parent);
		  }
		  public void SRFind(String find) {
			  displayDialog("Find String: " + find);
		  }
	  }
	public class hdlSyntaxEditorPane extends syntaxEditorPane {
		public void SEPUpdateMaxLineNumber(int num) {
			// if different max line number redraw line number header
			if (getMaxLineNumber() != num) {
				mainTab.getSEPComp().getHeader().updateMaxLineNumber(num);
			}		
		}
		public void searchReplace() {
			hdlSearchReplaceDialog dlg = searchreplaceCommonDialog();
		}
		public void SEPClickedAt(int row,int col) {
		}
		public void setRawText(String s) {
			bInit = true;
			s = s.replaceAll("<","&lt"); 			
			s = s.replaceAll(">","&gt"); 			
						
			compilerTokens tokenizer = new compilerTokens();
			String name = hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getName(); 
			if (name.equals("VHDL")) { // for VHDL
				tokenizer.setReservedWords(VHDLReservedWords);
				tokenizer.setTypes(VHDLTypes);
			} else { // and for Verilog
				tokenizer.setReservedWords(VerilogReservedWords);
				tokenizer.setTypes(VerilogTypes);
			}

			removeAllFormats();
			addFormat(new syntaxEditorPaneFormat("beginLineKeyword","^("+tokenizer.getKeywordORedString()+")\\W","<b><font color='blue'>","</font></b>"));
			addFormat(new syntaxEditorPaneFormat("endLineKeyword","\\W("+tokenizer.getKeywordORedString()+")$","<b><font color='blue'>","</font></b>"));
			addFormat(new syntaxEditorPaneFormat("midLineKeyword","\\W("+tokenizer.getKeywordORedString()+")\\W","<b><font color='blue'>","</font></b>"));
			addFormat(new syntaxEditorPaneFormat("singleLineKeyword","^("+tokenizer.getKeywordORedString()+")$","<b><font color='blue'>","</font></b>"));
			addFormat(new syntaxEditorPaneFormat("midLineType","\\W("+tokenizer.getTypeORedString()+")\\W","<b><font color='green'>","</font></b>"));
			addFormat(new syntaxEditorPaneFormat("midLineNumber","\\W(\\d+)\\W","<b><font color='gray'>","</font></b>"));
			addFormat(new syntaxEditorPaneFormat("listNumber","[\\(;,](\\d+)[;,\\)]","<b><font color='gray'>","</font></b>"));
			addFormat(new syntaxEditorPaneFormat("time","\\W((?:\\d+)(?:ms|us|ns|ps|secs))\\W","<b><font color='gray'>","</font></b>"));

			String tmp = "";
			Vector lines = supportFunctions.splitIntoTokens(s,"\n");
			setMaxLineNumber(lines.size());
			for (int i=0;i<lines.size();i++) {
				String line = (String)lines.elementAt(i);
				line = doFormats(line);
				tmp = tmp + line;
				tmp = tmp + "\n";
			}
			
			tmp = tmp.replaceAll("\\n","<br>\n");

			setText(tmp);
			bInit = false;
		}
	}
	public class hdlSEPComponent extends SEPComponent {
		private JScrollPaneLineNumberHeader header = null;
		private	int							width = 35;
		private int							height = 100000; // fudge !!!
		
		public hdlSEPComponent(syntaxEditorPane jep,int cols,int rows) {
			super(jep,cols,rows);
			
			header = new JScrollPaneLineNumberHeader();
			header.setPreferredSize(new Dimension(width, height));
		}
		public JScrollPaneLineNumberHeader getHeader() {return header;}
	}
	
	public class Tuple3<A, B, C> {

	    public final A a;
	    public final B b;
	    public final C c;

	    public Tuple3(A a, B b,C c) {
	        this.a = a;
	        this.b = b;
	        this.c = c;
	    }
	    public A getA() {return a;}
	    public B getB() {return b;}
	    public C getC() {return c;}
	    
	    @Override
	    public boolean equals(Object o) {
	        if (this == o) return true;
	        if (o == null || getClass() != o.getClass()) return false;

	        Tuple3<?, ?, ?> tuple = (Tuple3<?, ?, ?>) o;
	        if (!a.equals(tuple.a)) return false;
	        if (!b.equals(tuple.b)) return false;
	        return c.equals(tuple.c);
	    }

	    @Override
	    public int hashCode() {
	        int result = a.hashCode();
	        result = 31 * result + b.hashCode() + c.hashCode();
	        return result;
	    }
	}
	public class Tuple2<A, B> {

	    public final A a;
	    public final B b;

	    public Tuple2(A a, B b) {
	        this.a = a;
	        this.b = b;
	    }
	    public A getA() {return a;}
	    public B getB() {return b;}
	    
	    @Override
	    public boolean equals(Object o) {
	        if (this == o) return true;
	        if (o == null || getClass() != o.getClass()) return false;

	        Tuple2<?, ?> tuple = (Tuple2<?, ?>) o;
	        if (!a.equals(tuple.a)) return false;
	        return b.equals(tuple.b);
	    }

	    @Override
	    public int hashCode() {
	        int result = a.hashCode();
	        result = 31 * result + b.hashCode();
	        return result;
	    }
	}

	public class mainCard extends Panel implements ActionListener,KeyListener,ListSelectionListener,ChangeListener,ItemListener {
		private JButton newBut,openBut,saveBut,compileBut,simulateBut,helpBut;
		private JTextField systemnameTF;
		private JTextArea statusTA;
		private hdlSyntaxEditorPane HDLTA;
		private JList compilers;
		private DefaultListModel compilersM;
		private	JScrollPaneEHS statusScrollPane;
		private JSpinner startTime,stopTime;
		private String timeUnit = "ms";
		private JRadioButton[] timeButtons = new JRadioButton[4];
		private String timeLabels[] = {"ns","us","ms","secs"};
		private ButtonGroup timeGroup = new ButtonGroup();
		private	hdlSEPComponent SEPComp = null;
		
		mainCard() {
			HDLTA = new hdlSyntaxEditorPane();
			HDLTA.addKeyListener(this);
			HDLTA.setBackground(lightyellow);
			
			compilersM = new DefaultListModel();
			compilers = new JList(compilersM);
			compilers.addListSelectionListener(this);
			compilers.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			compilers.setVisibleRowCount(5);
			for(int i=0;i<hdlworkbench.getNumberOfCompilers();i++) {
				compilersM.addElement(hdlworkbench.getCompiler(i).getName());
			}
			compilers.setSelectedIndex(0);
			JScrollPane pane = new JScrollPane(compilers);
			pane.setPreferredSize(new Dimension(5*charWidth,2*charHeight));
			JPanel topPanel = new JPanel();
			JLabel lab = new JLabel("<html><font size='+2' color='red'>HDL Work Bench</font><p><font size='-2'>"+systemUserReg.getAppCopyright()+"</font></html>");
			Font f = lab.getFont();
			lab.setFont(f.deriveFont((float)f.getSize() + 3));
			topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.X_AXIS));
			topPanel.add(lab);
//			topPanel.add(Box.createRigidArea(new Dimension(5 * charWidth,charHeight)));
//			topPanel.add(pane);
			
			newBut = new JButton("New");
			newBut.addActionListener(this);
			newBut.setPreferredSize(new Dimension(10*charWidth,charHeight));
			newBut.setToolTipText("New HDL File");
			openBut = new JButton("Open");
			openBut.addActionListener(this);
			openBut.setPreferredSize(new Dimension(10*charWidth,charHeight));
			openBut.setToolTipText("Open HDL File");
			saveBut = new JButton("Save");
			saveBut.addActionListener(this);
			saveBut.setPreferredSize(new Dimension(10*charWidth,charHeight));
			saveBut.setToolTipText("Save HDL File");
			compileBut = new JButton("Compile");
			compileBut.addActionListener(this);
			compileBut.setPreferredSize(new Dimension(10*charWidth,charHeight));
			compileBut.setToolTipText("Compile HDL File");
			simulateBut = new JButton("Simulate");
			simulateBut.addActionListener(this);
			simulateBut.setPreferredSize(new Dimension(10*charWidth,charHeight));
			simulateBut.setToolTipText("Simulate HDL File");
			helpBut = new JButton("Help");
			helpBut.addActionListener(this);
			helpBut.setPreferredSize(new Dimension(10*charWidth,charHeight));
			helpBut.setToolTipText("Help File");

			JPanel butPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
			butPanel.add(newBut);
			butPanel.add(openBut);
			butPanel.add(saveBut);
			butPanel.add(compileBut);
			butPanel.add(helpBut);

			startTime = new JSpinner();
			stopTime = new JSpinner();
			startTime.addChangeListener(this);
			stopTime.addChangeListener(this);
			startTime.setPreferredSize(new Dimension(6*charWidth,charHeight));
			stopTime.setPreferredSize(new Dimension(6*charWidth,charHeight));
			JPanel simPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
			simPanel.add(new JLabel("Plot Start Time "));
			simPanel.add(startTime);
			simPanel.add(new JLabel(" Stop Time: "));
			simPanel.add(stopTime);
			stopTime.setValue(new Integer(100));
			simPanel.add(simulateBut);
			for (int i=0;i<timeButtons.length;i++) {
				timeButtons[i] = new JRadioButton(timeLabels[i]);
				timeButtons[i].setContentAreaFilled(false);
				timeButtons[i].addItemListener(this);
				timeGroup.add(timeButtons[i]);
				simPanel.add(timeButtons[i]);
			}
			timeButtons[2].setSelected(true);
			
			systemnameTF = new JTextField("",50);
			statusTA = new JTextArea("",7,50);
			statusTA.setEditable(false);
			statusTA.setText(systemUserReg.getMultiLineInfoText());
			systemnameTF.setEditable(false);
			statusTA.setWrapStyleWord(true);
			statusTA.setBackground(lightyellow);
			f = statusTA.getFont();
			statusTA.setFont(f.deriveFont((float)f.getSize() - 3));
			
			JPanel p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
			p.add(topPanel);
			p.add(Box.createRigidArea(new Dimension(charWidth,charHeight/2)));
			p.add(systemnameTF);
			SEPComp = new hdlSEPComponent(HDLTA,15,15);
			SEPComp.getScrollPane().setRowHeaderView(SEPComp.getHeader());
			SEPComp.getScrollPane().setCorner(JScrollPane.UPPER_LEFT_CORNER,
					new JScrollPaneSolidColorCorner(Color.red));
			SEPComp.getScrollPane().setCorner(JScrollPane.LOWER_LEFT_CORNER,
					new JScrollPaneSolidColorCorner(Color.red));
			p.add(SEPComp.getScrollPane());
			p.add(Box.createRigidArea(new Dimension(charWidth,charHeight/2)));
			p.add(butPanel);
			p.add(Box.createRigidArea(new Dimension(charWidth,charHeight/2)));
			p.add(simPanel);
			p.add(Box.createRigidArea(new Dimension(charWidth,charHeight/2)));
			statusScrollPane = new JScrollPaneEHS(statusTA);
			statusScrollPane.setPreferredSize(new Dimension(15*charWidth,5*charHeight));
			p.add(statusScrollPane);
			add(p,"West");

			displaySystemName();
								
			saveBut.setEnabled(false);
			compileBut.setEnabled(false);
			simulateBut.setEnabled(false);
		}
		public hdlSEPComponent getSEPComp() {return SEPComp;}
		public void updateMainCard() {}
		public void stateChanged(ChangeEvent evt) {
			Object start = startTime.getValue();
			Object stop = stopTime.getValue();
			Integer istart = (Integer)start;
			Integer istop = (Integer)stop;

			if (evt.getSource() == startTime) {
				//displayDialog("Start Time: " + istart.toString());
				if (istart.intValue() >= istop.intValue()) {
					startTime.setValue(new Integer(istop.intValue() - 1));
				}
			}
			if (evt.getSource() == stopTime) {
				//displayDialog("Stop Time: " + istop.toString());
				if (istop.intValue() <= istart.intValue()) {
					stopTime.setValue(new Integer(istart.intValue() + 1));
				}
			}
		}
		public void valueChanged(ListSelectionEvent evt) {
			if (!evt.getValueIsAdjusting()) {
				hdlworkbench.setCompilerIndex(compilers.getSelectedIndex());
				//HDLTA.refreshText();
			}
		}
      		public void itemStateChanged(ItemEvent evt) {
			JRadioButton but = (JRadioButton)evt.getItem();
			if (evt.getStateChange() == ItemEvent.SELECTED) {
				timeUnit = but.getText();
			}
		}
      		public void actionPerformed(ActionEvent evt) {
			if (evt.getSource() == newBut) {hdlSystemNew();}
			if (evt.getSource() == openBut) {hdlSystemOpen();}
			if (evt.getSource() == saveBut) {hdlSystemSave(true);}
			if (evt.getSource() == compileBut) {hdlSystemCompile();}
			if (evt.getSource() == simulateBut) {hdlSystemSimulate();}
		}
		public void keyTyped(KeyEvent evt) {}
		public void keyReleased(KeyEvent evt) {}
		public void keyPressed(KeyEvent evt) {
			hdlworkbench.setSystemModified(true);
			displaySystemName();
			saveBut.setEnabled(true);
			compileBut.setEnabled(true);
			simulateBut.setEnabled(true);
		}
		public void hdlSystemNew() {
			hdlSystemSave(false);
			hdlworkbench.resetSystemState();
			getSEPComp().getHeader().removeAllMarkers();
			HDLTA.setRawText("");
			getSEPComp().getHeader().updateMaxLineNumber(1);
			displaySystemName();
			saveBut.setEnabled(false);
			compileBut.setEnabled(false);
			simulateBut.setEnabled(false);
		}
		public void hdlSystemOpen() {
			hdlSystemSave(false);
			hdlworkbench.resetSystemState();
			String tmp = fileOpenDialog("","*." + hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getFileExt());
			if (tmp == null) {return;}
			addStatusMsg("\nLoaded File:"+tmp);
			hdlworkbench.setSystemName(tmp);
			hdlworkbench.setSystemModified(false);
			hdlworkbench.setSystemFile(new ehsFile(tmp));
			getSEPComp().getHeader().removeAllMarkers();
			HDLTA.setRawText(hdlworkbench.getSystemFile().loadFile());
			getSEPComp().getHeader().updateMaxLineNumber(getSEPComp().getEditorPane().getMaxLineNumber());
			displaySystemName();
			saveBut.setEnabled(false);
			compileBut.setEnabled(true);
			simulateBut.setEnabled(true);
		}
		public void addStatusMsg(String msg) {
			statusTA.append(msg);
			statusScrollPane.scrollToLastLine();
		}
		public boolean hdlSystemSave(boolean bForceSave) {
			if (hdlworkbench.getSystemModified()) {
				if (!bForceSave) {
					if (JOptionPane.showConfirmDialog(null,"Save File","Save File",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.NO_OPTION) {return false;}
				}
				if (hdlworkbench.getSystemName().contains("Untitled")) {
					String tmp = fileSaveDialog("","*." + hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getFileExt());
					if (tmp == null) {return false;}
					hdlworkbench.setSystemFile(new ehsFile(tmp));
					hdlworkbench.setSystemName(tmp);
				}
				
				String fileContents = HDLTA.getRawText();
				Vector fileLines = supportFunctions.splitIntoTokens(fileContents,"\n");
				String line = (String)fileLines.elementAt(0);
				hdlworkbench.getSystemFile().saveFile(line+"\n");
				for (int i=1;i<fileLines.size();i++) {
					line = (String)fileLines.elementAt(i);
					hdlworkbench.getSystemFile().appendFile(line+"\n");
				}
				hdlworkbench.setSystemModified(false);
				addStatusMsg("\nFile Saved - " + hdlworkbench.getSystemName());
				displaySystemName();
				saveBut.setEnabled(false);
			}
			return true;
		}
		public void hdlSystemCompile() {
			hdlSystemSave(true);
			addStatusMsg("\nCompiling System ...");
			if (hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).compile(hdlworkbench.getSystemName())) {
				addStatusMsg("\nCompile Successful");
			} else {
				addStatusMsg("\nCompile Failed");
				addStatusMsg(hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getErrorString() + "\n");
			}
		}
		public void hdlSystemSimulate() {
			hdlSystemSave(true);
			addStatusMsg("\nSimulating System ...");
			try {
				Object start = startTime.getValue();
				Object stop = stopTime.getValue();
				Integer s1 = (Integer)start;
				Integer s2 = (Integer)stop;
				String simulatePHPFile = "output/" + supportFunctions.getFilenameNoExt(hdlworkbench.getSystemName()) + ".php?entity="+supportFunctions.getFilenameNoExt(hdlworkbench.getSystemName()+"&start="+s1.toString()+"&end="+s2.toString()+"&timeunit="+timeUnit);
				ac.showDocument(new URL(getCodeBase(),simulatePHPFile),"_blank");
			} catch (Exception e) {;}
		}
		public void displaySystemName() {
			String tmp = hdlworkbench.getSystemName();
			tmp = supportFunctions.getFilename(tmp);
			if (hdlworkbench.getSystemModified()) {tmp = tmp + "*";}
			systemnameTF.setText(tmp);
		}
	}
	
	public String stringRepeat(String s,int times) {
		String ret = "";
		if (times > 0) {
			for (int i=0;i<times;i++) {
				ret = ret + s;
			}
		}
		
		return ret;
	}
	public enum transTableTokenType {
		NONE {
			public Color getTokenColor() {
				return Color.white;
			}
			public String getDescription() {
				return "None";
			}
		},
		OPTIONAL {
			public Color getTokenColor() {
				return Color.red;
			}
			public String getDescription() {
				return "Optional";
			}
		},
		KEYWORD {
			public Color getTokenColor() {
				return new Color(255,255,170);
			}
			public String getDescription() {
				return "Keyword";
			}
		},
		NORMAL {
			public Color getTokenColor() {
				return new Color(255,255,170);
			}
			public String getDescription() {
				return "Normal";
			}
		},
		MULTIPLE {
			public Color getTokenColor() {
				return Color.green;
			}
			public String getDescription() {
				return "Multiple";
			}
		};
		public abstract Color getTokenColor();
	}
	private	int 						xTTMargin = 10;
	private	int 						yTTMargin = 10;
	public class transTableCanvasDialog extends JDialog implements drawingCanvasUtils {
		private int 						numRows = 20;
		private int 						numCols = 60;
		private scrollableTransTableCanvas 	sDC1 = null;
		private	drawingCanvas				dc = null;
		private	ScrollPane 					sp = null;
		private	translationTable			table = null;
		private	boolean						bOK = false;
		private JButton						OKBut,CANCELBut;
		private final int					DELETE = -1;
		private final int					INSERT = 1;
		
		public boolean isOK() {return bOK;}
		public void rightClickAction(Vector v,MouseEvent evt) {;}
		public void leftClickAction(drawingItem d,MouseEvent evt) {;}
		public void leftClickSelectedAction(Vector v,MouseEvent evt) {;}
		public void hoverAction(drawingItem d,MouseEvent evt) {;}
		public void customDoCommand(String cmd,String params,drawingItem d) {;}
		public boolean canvasDoubleClickAction(MouseEvent evt) {return false;}
		public boolean canvasLeftClickAction(MouseEvent evt) {return false;}
		public void doubleClickAction(drawingItem d,MouseEvent evt) {
			doubleClickAction((transTableDrawingItem)d);
		}
		public void makeGroup(int groupID,Vector v,transTableTokenType type) {
			for(int i=0;i<v.size();i++) {
				transTableDrawingItem d = (transTableDrawingItem)v.elementAt(i);
				if (d.getTTGroupID() == groupID) {
					d.setTokenType(type);
				}
			}
		}
		public boolean isGroup(int groupID,Vector v) {
				int count = 0;
			
			for(int i=0;i<v.size();i++) {
				transTableDrawingItem d = (transTableDrawingItem)v.elementAt(i);
				if (d.getTTGroupID() == groupID) {
					if (++count > 1) {return true;}
				}
			}
			
			return false;
		}
		public void adjustCordData(int startIndex,int groupID,Vector v,int signAdjust,boolean bGroup) {
			int changeX = (xTTMargin + ttDIWidth) * signAdjust;
			int changeY = (yTTMargin + ttDIHeight) * signAdjust;
			
			//displayDialog("adjustCordData:si:"+String.valueOf(startIndex)+":gi:"+String.valueOf(groupID)
			//		+":sa:"+String.valueOf(signAdjust)+":bGroup:"+String.valueOf(bGroup));
			
			for(int i=startIndex;i<v.size();i++) {
				transTableDrawingItem d = (transTableDrawingItem)v.elementAt(i);
				Rectangle rc = d.getBoundingRect();
				
				if (bGroup) {
					if (d.getTTGroupID() == groupID) {
						rc.y = rc.y + changeY;
						d.setBoundingRect(rc);
					}
				} else {
					rc.x = rc.x + changeX;
					d.setBoundingRect(rc);
					d.setTTGroupID(d.getTTGroupID() + signAdjust);
				}
			}
		}
		public Window getActiveWindow() {
	         final KeyboardFocusManager currentKeyboardFocusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
	         final Window activeWindow = currentKeyboardFocusManager.getActiveWindow();
	         
	         return activeWindow;
		}
		public void doubleClickAction(transTableDrawingItem d) {
			Vector tmp = supportFunctions.splitIntoTokens(d.getUserDefinedName(),":");
			Vector v = transTableMap.get((String)tmp.elementAt(0));
			//displayDialog("Num Tokens (get)"+String.valueOf(v.size()));
			if(v != null) {
				int index = v.indexOf(d);
				if (index == 0) {
					displayDialog("Can not edit keyword token.");
					return;
				}
				if(index != -1) {					
					int groupID = d.getTTGroupID();
					Rectangle rc = d.getBoundingRect();
					int xCord = rc.x;
					int yCord = rc.y;
					
					JPanel p = new JPanel();
					p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
					JButton closeBut = new JButton("Close");
					closeBut.setPreferredSize(new Dimension(14*charWidth,charHeight*2));
					closeBut.setMaximumSize(new Dimension(14*charWidth,charHeight*2));
					closeBut.setMinimumSize(new Dimension(14*charWidth,charHeight*2));
					closeBut.addActionListener(new ActionListener() {
						public void actionPerformed(ActionEvent e) {
							getActiveWindow().dispose();							
						}
					});
					JButton editorBut = new JButton("Editor");
					editorBut.setPreferredSize(new Dimension(14*charWidth,charHeight*2));
					editorBut.setMaximumSize(new Dimension(14*charWidth,charHeight*2));
					editorBut.setMinimumSize(new Dimension(14*charWidth,charHeight*2));
					editorBut.addActionListener(new ActionListener() {
						public void actionPerformed(ActionEvent e) {
							d.editor();
							getActiveWindow().dispose();							
						}
					});
					JButton deleteBut = new JButton("Delete");
					deleteBut.setPreferredSize(new Dimension(14*charWidth,charHeight*2));
					deleteBut.setMaximumSize(new Dimension(14*charWidth,charHeight*2));
					deleteBut.setMinimumSize(new Dimension(14*charWidth,charHeight*2));
					deleteBut.addActionListener(new ActionListener() {
						public void actionPerformed(ActionEvent e) {
							boolean bGroup = isGroup(groupID,v);
							getDC().deleteDrawingItem((drawingItem)d);
							v.removeElementAt(index);
							adjustCordData(index,groupID,v,DELETE,bGroup);
							if(isGroup(groupID,v)) {
								//displayDialog("Group ID "+String.valueOf(groupID)+" is a group");
							} else {
								//displayDialog("Group ID "+String.valueOf(groupID)+" is NOT a group");
								makeGroup(groupID,v,transTableTokenType.NORMAL);
							}
							getDC().repaint();
							getActiveWindow().dispose();							
						}
					});
					JButton insertBeforeBut = new JButton("Insert");
					insertBeforeBut.setPreferredSize(new Dimension(14*charWidth,charHeight*2));
					insertBeforeBut.setMaximumSize(new Dimension(14*charWidth,charHeight*2));
					insertBeforeBut.setMinimumSize(new Dimension(14*charWidth,charHeight*2));
					insertBeforeBut.addActionListener(new ActionListener() {
						public void actionPerformed(ActionEvent e) {
							// groupID is one more then element clicked on 
							// xCord is xCord + xMargin + ttDIWidth
							// yCord is the same as element double clicked on
							transTableDrawingItem dNew = (transTableDrawingItem)getDC().addDrawingItem(
								getDC().getEntity(),dcTypeTransTable,
								xCord + xTTMargin + ttDIWidth,yCord,
								(String)tmp.elementAt(0) + ":" + "newtext",
								"*c","x",
								String.valueOf(groupID+1),false,Color.black);
							dNew.setTokenType(transTableTokenType.NORMAL);
							dNew.setCanTransform(false);
							dNew.setPreString("");
							dNew.setPostString("");
							dNew.setUserDefinedName((String)tmp.elementAt(0) + ":" + "newtext");
							v.insertElementAt(dNew,index+1);
							adjustCordData(index + 2,groupID,v,INSERT,false); //+2 to start from element after inserted one
							getDC().repaint();
							getActiveWindow().dispose();							
						}
					});
					JButton insertGroupBut = new JButton("Insert Group");
					insertGroupBut.setPreferredSize(new Dimension(14*charWidth,charHeight*2));
					insertGroupBut.setMaximumSize(new Dimension(14*charWidth,charHeight*2));
					insertGroupBut.setMinimumSize(new Dimension(14*charWidth,charHeight*2));
					insertGroupBut.addActionListener(new ActionListener() {
						public void actionPerformed(ActionEvent e) {
							// groupID is the same as the element double clicked on 
							// xCord is the same as element click on
							// yCord is yCord + yMargin + ttDIHeight
							transTableDrawingItem dNew = (transTableDrawingItem)getDC().addDrawingItem(
								getDC().getEntity(),dcTypeTransTable,
								xCord,yCord + yTTMargin + ttDIHeight,
								(String)tmp.elementAt(0) + ":" + "newtext",
								"*c","x",
								String.valueOf(groupID),false,Color.black);
							dNew.setTokenType(transTableTokenType.MULTIPLE);
							d.setTokenType(transTableTokenType.MULTIPLE);
							dNew.setCanTransform(false);
							dNew.setPreString("");
							dNew.setPostString("");
							dNew.setUserDefinedName((String)tmp.elementAt(0) + ":" + "newtext");
							v.insertElementAt(dNew,index+1);
							adjustCordData(index + 2,groupID,v,INSERT,true); //+2 to start from element after inserted one
							getDC().repaint();
							getActiveWindow().dispose();							
						}
					});
					p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
					p.add(new JLabel("<html><b>Keyword:"+(String)tmp.elementAt(0)+"</html></b>"));
					p.add(new JLabel("<html><b>Text:"+d.getText()+"</html></b>"));
					p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
					p.add(deleteBut);
					p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
					p.add(insertBeforeBut);
					p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
					p.add(insertGroupBut);
					p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
					p.add(editorBut);
					p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
					p.add(closeBut);
					displayPanelDialog(p,"Edit TT Element",true);
					
					//displayDialog("Num Tokens (put)"+String.valueOf(v.size()));
					transTableMap.put((String)tmp.elementAt(0),v);								
				} else {
					displayDialog("Token DI for keyword ("+(String)tmp.elementAt(0)+") NOT found");
				}
			} else {
				displayDialog("Keyword ("+(String)tmp.elementAt(0)+") NOT Found");
			}
		}
		public void processTransTableDrawingItems() {	
			int xCord = 0;
			int yCord = 0;
			int yCordMax = 0;
			
			transTableMap.clear();
			msg2Dialog msgD = displayModelessStatusDialog(systemUserReg.getAppName());
			int numTokens = 0;
			Vector keywords = table.getKeywords();
			for (int i=0;i<keywords.size();i++) {
				int groupID = 0;
				Vector v = new Vector();
				xCord = xTTMargin;
				yCord = yCordMax + yTTMargin + ttDIHeight;
				int yCordStart = yCord;
				yCordMax = yCord;
				TRACE("processTransTableDrawingItems:keyword:"+(String)keywords.elementAt(i),4);
				TRACE("processTransTableDrawingItems:entity:"+getDC().getEntity(),4);
				msgD.setText("Processing translation table keyword:" + (String)keywords.elementAt(i));
				//displayDialog("processTransTableDrawingItems:key:"+(String)keywords.elementAt(i));
				transTableDrawingItem d = (transTableDrawingItem)getDC().addDrawingItem(getDC().getEntity(),dcTypeTransTable,
						xCord,yCord,(String)keywords.elementAt(i) + ":" + (String)keywords.elementAt(i),"","",
						String.valueOf(groupID++),false,Color.black);
				d.setTokenType(transTableTokenType.KEYWORD);
				d.setCanTransform(false);
				d.setPreString(table.getTranslationTableEntry((String)keywords.elementAt(i)).getpreEntryString());
				d.setPostString(table.getTranslationTableEntry((String)keywords.elementAt(i)).getpostEntryString());
				d.setUserDefinedName((String)keywords.elementAt(i) + ":" + (String)keywords.elementAt(i));
				v.addElement(d);

				Vector tokens = table.getTokens((String)keywords.elementAt(i));				
				numTokens = numTokens + tokens.size();
				for (int j=0;j<tokens.size();j++) {
					translationTableToken token = (translationTableToken)tokens.elementAt(j);
					xCord = xCord + xTTMargin + ttDIWidth;
					Vector syntaxStrings = supportFunctions.splitIntoTokens(token.getText(),"##",false);
					TRACE("processTransTableDrawingItems:"+token.getText()+":Tokens:"+String.valueOf(syntaxStrings.size()),4);
					
					String transTextStrings1 = token.getTransText();
					if (transTextStrings1.length() == 0) {
						transTextStrings1 = "*c" + stringRepeat("##*c",syntaxStrings.size()-1);
					}
					String flagStrings1 = token.getFlags();
					if (flagStrings1.length() == 0) {
						if (j == tokens.size()-1) { // last token should have a 'y' finish processing flag
							flagStrings1 = "y" + stringRepeat("##y",syntaxStrings.size()-1);																						
						} else {
							flagStrings1 = "x" + stringRepeat("##x",syntaxStrings.size()-1);															
						}
					}
					
					Vector transTextStrings = supportFunctions.splitIntoTokens(transTextStrings1,"##",false);
					Vector flagsStrings = supportFunctions.splitIntoTokens(flagStrings1,"##",false);
					
					for (int part=0;part<syntaxStrings.size();part++) {
						if (part > 0) {
							yCord = yCord + yTTMargin + ttDIHeight;
							yCordMax = yCord;
						}
						String syntax = (String)syntaxStrings.elementAt(part);
						String transText = (String)transTextStrings.elementAt(part);
						String flags = (String)flagsStrings.elementAt(part);
						String id = (String)keywords.elementAt(i) + ":" + syntax;

						transTableTokenType type = transTableTokenType.NORMAL;
						if (syntaxStrings.size() > 1) {
							type = transTableTokenType.MULTIPLE;
						}
						if (flags.indexOf("z") != -1) {type = transTableTokenType.OPTIONAL;} // check for optional token
						
						d = (transTableDrawingItem)getDC().addDrawingItem(getDC().getEntity(),dcTypeTransTable,
								xCord,yCord,id,transText,flags,String.valueOf(groupID),false,Color.black);

						d.setTokenType(type);
						d.setCanTransform(false);
						d.setPreString("");
						d.setPostString("");
						d.setUserDefinedName(id);
						v.addElement(d);
					} // for all parts
					groupID++;
					yCord = yCordStart;
				} // for all tokens
				transTableMap.put((String)keywords.elementAt(i),v);
			} // for all keywords
			
			msgD.destory();
			msgD.dispose();
			//displayDialog("Keywords: " + String.valueOf(keywords.size()) + " Tokens: " + String.valueOf(numTokens));
		}
		public drawingCanvas getDC() {return dc;}
		public ScrollPane getScrollPane() {return sp;}
		public transTableCanvasDialog(Frame parent,String title,String entity,int xMax,int yMax,translationTable table) {
			super(parent,title,true);
			
			this.table = table;
						
			JPanel p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
			
			sDC1 = new scrollableTransTableCanvas(entity,xMax,yMax,20,20,false);

			dc = sDC1.getDC();
			sp = sDC1.getComponent();

			processTransTableDrawingItems();
			
			getDC().hideToolWindows();
			getDC().setMultiUser(false);
			getDC().setUseDatabase(false);
			getDC().setReadOnly(false);
			getDC().addDrawingCanvasListener(this);
			getDC().setDrawFocusHandles(false);
			getDC().setSubEntity("subentity");
			
			getScrollPane().setSize(charWidth*numCols,charHeight*numRows);
			p.add(getScrollPane());
			p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
			JPanel p1 = new JPanel();
			p1.setLayout(new BoxLayout(p1,BoxLayout.X_AXIS));
			OKBut = new JButton("Ok");
			p1.add(OKBut);
			CANCELBut = new JButton("Cancel");
			p1.add(CANCELBut);
			p.add(p1);
			add(p);

			ActionListener OKTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					bOK = true;
					dispose();
			   }
			};
			OKBut.addActionListener(OKTask);
			ActionListener CANCELTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					dispose();
			   }
			};
			CANCELBut.addActionListener(CANCELTask);

 			addWindowListener(new WindowAdapter() {
 				public void windowClosing(WindowEvent evt) {
 					dispose();
	            }
			});

			pack();
			setVisible(true);			
		}		
		public void destroy() {
			dispose();
	    }
	}	
	public class transTableDrawingItem extends drawingItem {
		private String 				keyword;
		private String				text;
		private	String 				transtext;
		private String 				flags;
		private String				prestring;
		private String				poststring;
		private	Rectangle			boundingRect;
		private	transTableTokenType	type = transTableTokenType.NONE;
		private int					groupTTID = 0;
		private	int					count = 0;
		
		public void setCount(int i) {count = i;}
		public int getCount() {return count;}
		public void setTTGroupID(int i) {groupTTID = i;}
		public int getTTGroupID() {return groupTTID;}
		public transTableTokenType getTokenType() {return type;}
		public void setTokenType(transTableTokenType t) {type = t;}
		public String getPreString() {return prestring;}
		public void setPreString(String s) {prestring = s;} 
		public String getPostString() {return poststring;}
		public void setPostString(String s) {poststring = s;} 
		public String getFlags() {return flags;}
		public String getTransText() {return transtext;}
		public String getText() {return text;}
		public transTableDrawingItem() {}
		public transTableDrawingItem(String id,int orgX,int orgY,String p1,String p2,String p3,String p4,boolean fill,Color c) {
			super(dcTypeTransTable,id,orgX,orgY,p1,p2,p3,p4,fill,c);
			
			Vector v = supportFunctions.splitIntoTokens(p1,":");
			keyword = (String)v.elementAt(0);
			text = (String)v.elementAt(1);
			this.transtext = p2;
			this.flags = p3;
			this.groupTTID = Integer.parseInt(p4);
			boundingRect = new Rectangle(orgX,orgY,ttDIWidth,ttDIHeight);
			prestring = "";
			poststring = "";
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
			// do nothing here if drawing item is of a fixed size
		}
		public void editor() {
			String[] titles = new String[]{"Text","Trans Text","Flags"};			
			String[] defaults = new String[] {getText(),getTransText(),getFlags()};
			String[] data = getDataAsDialog("Edit Trans Table Element",titles,defaults);
			if (data != null) {
				text = data[0];
				transtext = data[1];
				flags = data[2];
			}
			
			repaint();
		}
		public void paint(Graphics2D g2d,boolean focus) {
			setupPaint(g2d,focus);
			
			g2d.setColor(type.getTokenColor());

			AffineTransform at = new AffineTransform();
			Shape s = new RoundRectangle2D.Double(boundingRect.x, boundingRect.y, 
					boundingRect.width, boundingRect.height,
					25,25);
			g2d.fill(s);

			g2d.setColor(Color.black);
			g2d.drawRoundRect(boundingRect.x, boundingRect.y, 
					boundingRect.width, boundingRect.height,
					25,25);
			centerTextAtBox(g2d,text,boundingRect);
			
			teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			// do nothing here if drawing item is of a fixed size
		}
		public Rectangle getBoundingRect() {
			return boundingRect;
		}
		public void setBoundingRect(Rectangle r) {
			boundingRect = r;
		}
		//public boolean canDelete() {return false;}
	}
	public boolean cmdLineParamPresent(String name) {
		if (commandLineArgs.get(name) != null) {
			return true;
		}
		return false;

	}
	public String cmdLineParamValue(String name,String defaultValue) {
		String value = (String)commandLineArgs.get(name);
		if (value != null) {
			return value;
		}

		return defaultValue;
	} 

	public class transTableDrawingCanvas extends drawingCanvas {
		private ArrayList<Integer> l = new ArrayList<Integer>();
		
		   public transTableDrawingCanvas(String entity,int maxX,int maxY,int spaceX,int spaceY,boolean gVisible) {
			   super(entity,maxX,maxY,spaceX,spaceY,gVisible);
		   }
		   public boolean doPaint(drawingItem d) {
			   if (d.getType() <= dcTypeBuiltInMaxId) {return true;} //built in types always drawn

			   return true;
		   } 
		   public boolean printOverride(Graphics2D g2d) {
			   g2d.drawImage(getCurrentCanvasImage(),0,0,canvasMaxX,canvasMaxY,null);
			   return true;
		   }
			public int calcJump(transTableDrawingItem d) {
				int jump = 1; // default jump value
				String flags = d.getFlags();
				
				int index = flags.indexOf("r");
				if (index != -1) {
					jump = Integer.parseInt(flags.substring(index+1,index+3));
				}
				if (flags.indexOf("y") != -1) {return transTableNoJump;}
				
				if (jump != 0) {
					if (jump > 0) { // forward jump
						jump = l.get(d.getTTGroupID()) - d.getCount();
					} else { // backward jump
						jump = jump - d.getCount();
					}
				}
				
				return jump;
			}
			public Vector getTransTableGroupItems(Vector values,int group) {
				Vector v = new Vector();
				
				for(int i=0;i<values.size();i++) {
					transTableDrawingItem di = (transTableDrawingItem)values.elementAt(i);
					if (group == di.getTTGroupID()) {
						v.addElement(di);
					}
				}
				
				return v;
			}
			public void drawTransTableConnectors(Graphics2D g2d) {
				for (Map.Entry<String, Vector> entry : transTableMap.entrySet()) {
					String key = entry.getKey();
					Vector value = entry.getValue();
					l.clear();
					int currentGroup = 0;
					int count = 0;
					for(int i=0;i<value.size();i++) {
						transTableDrawingItem di = (transTableDrawingItem)value.elementAt(i);
						if (currentGroup == di.getTTGroupID()) {
							di.setCount(count++);
						} else {
							l.add(count);
							TRACE("drawTransTableConnectors:count:"+String.valueOf(count),4);
							currentGroup = di.getTTGroupID();
							count = 0;
							di.setCount(count++);
						}
						if (i == value.size()-1) {// add the count for the LAST TT DI Element
							l.add(count);
							TRACE("drawTransTableConnectors:count:"+String.valueOf(count),4);
						}
					}
					for(int i=0;i<value.size();i++) {
						
						transTableDrawingItem di = (transTableDrawingItem)value.elementAt(i);
						int jump = calcJump(di);
						
						TRACE("drawTransTableConnectors:i:"+String.valueOf(i)+":keyword:"+key+":value:"
								+di.getText()+":flags:"+di.getFlags()+":group:"+di.getTTGroupID()
								+":count:"+di.getCount()+":jump:"+String.valueOf(jump),4);

						if (jump != transTableNoJump) {
							transTableDrawingItem diTo = (transTableDrawingItem)value.elementAt(i + jump);
														
							if (jump == 0) {
								Vector v = getTransTableGroupItems(value,di.getTTGroupID());
								if (v.size() > 2) {
									transTableDrawingItem diFirst = (transTableDrawingItem)v.elementAt(0);
									transTableDrawingItem diLast = (transTableDrawingItem)v.elementAt(v.size() - 1);
									Rectangle rcFirst = diFirst.getBoundingRect();
									Rectangle rcLast = diLast.getBoundingRect();
									Point ptFirst = centerPoint(rcFirst);
									Point ptLast = centerPoint(rcLast);
									int m = (ttDIHeight / 2) + (yTTMargin / 2);
									int m1 = (int)(diFirst.getBoundingRect().width / 2.0) + (int)(xTTMargin / 2.0);
									
									g2d.drawLine(ptFirst.x,ptFirst.y,ptFirst.x,ptFirst.y-m);
									g2d.drawLine(ptFirst.x,ptFirst.y-m,ptFirst.x+m1,ptFirst.y-m);
									
									g2d.drawLine(ptFirst.x+m1,ptFirst.y-m,ptLast.x+m1,ptLast.y+m);
									
									g2d.drawLine(ptLast.x+m1,ptLast.y+m,ptLast.x,ptLast.y+m);
									g2d.drawLine(ptLast.x,ptLast.y+m,ptLast.x,ptLast.y);

								}
							}
							if (jump == -1 || jump == 1) {
								Point ptStart = centerPoint(di.getBoundingRect());
								Point ptEnd = centerPoint(diTo.getBoundingRect());
								g2d.drawLine(ptStart.x,ptStart.y,ptEnd.x,ptEnd.y);
							}
							if (jump < -1  || jump > 1) {
								Point ptStart1 = centerPoint(di.getBoundingRect());
								Point ptEnd1 = centerPoint(diTo.getBoundingRect());
								// use 1.5 instead of 2.0 because otherwise the connector would merge with other connectors
								double length = (di.getBoundingRect().height / 2.0) + (yTTMargin / 1.5);
								g2d.drawLine(ptStart1.x,ptStart1.y,ptStart1.x,(int)(ptStart1.y - length));
								g2d.drawLine(ptStart1.x,(int)(ptStart1.y - length),ptEnd1.x,(int)(ptEnd1.y - length));
								g2d.drawLine(ptEnd1.x,(int)(ptEnd1.y - length),ptEnd1.x,ptEnd1.y);
							}
						}
						//displayDialog("pause");
					}
				}		
			}
		   public void beforePainting(Graphics2D g2d) {
			   drawTransTableConnectors(g2d);
		   }
		   public void customOutlineDrawingItem(Graphics2D g2d,int type) {;}
		   public drawingItem createCustomDrawingItem(String entity,int type,String id,int x,int y,String p1,String p2,String p3,String p4,boolean fill,Color c) {
				if (type == dcTypeTransTable) {
					transTableDrawingItem d = new transTableDrawingItem(id,x,y,p1,p2,p3,p4,fill,c);
					return d;
				}
				
				return (drawingItem)null;
		   }
		   public PopupMenu customCreateMenu(PopupMenu menu) {
			   menu.removeAll();
			   
			   return menu;
		   }
		   public void customUpdateMenu(PopupMenu menu) {
			   
		   }
	}

	public class scrollableTransTableCanvas {
		  private transTableDrawingCanvas  	dC;
		  private ScrollPane		  		sPane;
		  private Adjustable				bottomSB,rightSB;
		  
		  public scrollableTransTableCanvas() {
			  this("",dcMaxX,dcMaxY,dcGridSpaceX,dcGridSpaceY,true);
		  }
		  public scrollableTransTableCanvas(String entity,int maxX,int maxY,int spaceX,int spaceY,boolean visible) {
			  dC = new transTableDrawingCanvas(entity,maxX,maxY,spaceX,spaceY,visible);
			  sPane = new ScrollPane();
			  sPane.add(dC);
			  bottomSB = sPane.getHAdjustable();
			  rightSB = sPane.getVAdjustable();
		  }
		  public Point getGCTopLeftCords() {return sPane.getScrollPosition();}
		  public void setGCTopLeftCords(Point pt) {sPane.setScrollPosition(pt);}
		  public Adjustable getBottomSB() {return bottomSB;}
		  public Adjustable getRightSB() {return rightSB;}
		  public void paint(Graphics g) {dC.paint(g);}
		  public drawingCanvas getDC() {return dC;}
		  public ScrollPane getComponent() {return sPane;}
		  public void update(Graphics g) {paint(g);}
		  public void paint() {paint(getGraphics());}
		  public void setSize(Dimension d) {dC.setSize(d);}
		  public Dimension getSize() {return dC.getSize();}
	}
	
	public class miniTextEditor extends JDialog implements ActionListener,TextListener {
		private	ehsFile			file;
		private JButton			butSave,butCancel;
		private	TextArea		text;
		private int				numCols = 20;
		private	int				numRows = 45;
		private	boolean 		bSaved = false;
		
		public miniTextEditor(Frame parent,String filename) {
			super(parent,filename,true);
			init(parent,filename,numCols,numRows);
		}
		public void init(Frame parent,String filename,int cols,int rows) {
			butSave = new JButton("save");
			butCancel = new JButton("Close");
			butSave.addActionListener(this);
			butCancel.addActionListener(this);
			butSave.setEnabled(false);
			file = new ehsFile(filename);
			String data = file.loadFile();
			setLayout(new BorderLayout());
			JPanel butPanel = new JPanel();
			JPanel editPanel = new JPanel();
			text = new TextArea(data,cols,rows);
			text.addTextListener(this);
			editPanel.add(text);
			butPanel.add(butSave);
			butPanel.add(butCancel);
			add(editPanel,BorderLayout.CENTER);
			add(butPanel,BorderLayout.SOUTH);
			pack();
			setVisible(true);
		}
		public boolean isSaved() {return bSaved;}
		public void destroy() {
			dispose();
	    }
		public void actionPerformed(ActionEvent e) {
			if (e.getSource() == butSave) {
				String data = text.getText();
				file.saveFile(data);
				bSaved = true;
			}
			
			dispose();
		}
		public void textValueChanged(TextEvent e) {
			butSave.setEnabled(true);
		}
	}
	
	public class HDLConnector {
		private	String	connName;
		private	String	connEntity;
		private	String	connPort;
		private	String	connList;
		
		HDLConnector(String name,String entity,String port,String list) {
			connName = name;
			connEntity = entity;
			connPort = port;
			connList = list;
		}
		public String getConnName() {return connName;}
		public String getConnEntity() {return connEntity;}
		public String getConnPort() {return connPort;}
		public String getConnList() {return connList;}
	}
 	public class designCard extends Panel implements drawingCanvasUtils,ActionListener {
		private	Vector HDLConnectors = new Vector();

		designCard() {			
			setLayout(new BorderLayout());
			JPanel textPanel = new JPanel();
			textPanel.setLayout(new BoxLayout(textPanel,BoxLayout.Y_AXIS));
			textPanel.setBorder(BorderFactory.createTitledBorder("Design"));
			sDC = new scrollableDrawingCanvas(supportFunctions.getTmpFilename("untitled"),dcMaxX,dcMaxY,20,20,true);
			getDrawingCanvas().addDrawingCanvasListener(this);
			getDrawingCanvas().setMultiUser(false);
			getDrawingCanvas().setReadOnly(false);
			getDrawingCanvas().setUseDatabase(false);
			getDrawingCanvas().setDrawFocusHandles(false);
			getDrawingCanvas().setSubEntity("subentity");

			ScrollPane sp = sDC.getComponent();
			sp.setSize(charWidth*visibleDCWidthChars,charHeight*visibleDCHeightChars);
			textPanel.add(sp);
			add(textPanel,"Center");
		}
		public HDLConnector getHDLConnector(String name) {			
				for (int i=0;i<HDLConnectors.size();i++) {
					HDLConnector conn = (HDLConnector)HDLConnectors.elementAt(i);
					if (conn.getConnName().equals(name)) {return conn;}
				}
				
				return (HDLConnector)null;
		}
		public void updateDesignCard(boolean b) {
			if (b) {
				String fname ="";
				getDrawingCanvas().hideToolWindows();
			   	if (hdlworkbench.getSystemFile() == null) {			
					fname = fileOpenDialog("","*." + hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getFileExt());
					if (fname == null) {return;}
					hdlworkbench.setSystemName(fname);
					hdlworkbench.setSystemModified(false);
					hdlworkbench.setSystemFile(new ehsFile(fname));
					mainTab.getSEPComp().getHeader().removeAllMarkers();
					mainTab.HDLTA.setRawText(hdlworkbench.getSystemFile().loadFile());
					mainTab.getSEPComp().getHeader().updateMaxLineNumber(mainTab.getSEPComp().getEditorPane().getMaxLineNumber());
			  	} else {
					mainTab.hdlSystemSave(true);
				}
				Vector v = getDrawingCanvas().getDrawingItemsOfType(dcTypeHDL);
				if (v.size() == 0){generateHDLBlocks();}
			} else {
				getDrawingCanvas().hideToolWindows();
			}
		}
		public void generateHDLBlocks() {
			msg2Dialog msgD = displayModelessStatusDialog("Generating Diagram");
			msgD.setText("Generating HDL Blocks ...");
			getDrawingCanvas().clearDrawingCanvas();
			getDrawingCanvas().setUpdate(false);
			createHDLDrawingItems(supportFunctions.getFilenameNoExt(hdlworkbench.getSystemName()));
			processLevelData(getDrawingCanvas().getDrawingItemsOfType(dcTypeHDL));
			processCordData(getDrawingCanvas().getDrawingItemsOfType(dcTypeHDL));
			processHDLConnectors(getDrawingCanvas().getDrawingItemsOfType(dcTypeHDL));
			getDrawingCanvas().setUpdate(true);
			msgD.destory();
			msgD.dispose();
		}
		public void processHDLConnectors(Vector drawingitems) {
			for (int i=0;i<drawingitems.size();i++) {
				HDLDrawingItem d = (HDLDrawingItem)drawingitems.elementAt(i);
				for (int ii=0;ii<HDLConnectors.size();ii++) {
					HDLConnector conn = (HDLConnector)HDLConnectors.elementAt(ii);
					if (d.getUserDefinedName().equals(conn.getConnEntity())) {
						int xCord = 0;
						int rotAngle = 0;
						Rectangle r = d.getBoundingRect();
						Point pt = d.getHDLPortPoint(conn.getConnPort());
						if (pt.x < r.x + r.width - 3) { // 'in' mode port
							TRACE("processHDLConnectors:port " + conn.getConnPort() + " is in mode",4);
							xCord = pt.x - (4*charWidth);
						} else {
							TRACE("processHDLConnectors:port " + conn.getConnPort() + " is out mode",4);
							xCord = pt.x;
							rotAngle = 180;
						}
						int yCord = pt.y - charWidth;
						HDLConnDrawingItem dd = (HDLConnDrawingItem)getDrawingCanvas().addDrawingItem(getDrawingCanvas().getEntity(),dcTypeHDLConn,xCord,yCord,conn.getConnName(),conn.getConnEntity(),conn.getConnPort(),conn.getConnList(),false,Color.black);
						dd.setCanTransform(false);
						dd.setRotAngle(rotAngle);
					}
				}
			}
		}
		public void processLevelData(Vector drawingItems) {
			// reset default level for each HDL drawing item
			hdlworkbench.setMaxLevel(0);
			if (drawingItems.size() == 0) {return;}
			HDLDrawingItem d = (HDLDrawingItem)drawingItems.elementAt(0);
			Rectangle rc = d.getBoundingRect(); // assume all HDL drawing items same size!
			int iNumberPerRow = dcMaxX/(rc.width + hdlworkbench.getMarginWidth());
			TRACE("processLevelData:Number per row:"+String.valueOf(iNumberPerRow),4);
			
			for (int i=0;i<drawingItems.size();i++) {
				HDLDrawingItem dd = (HDLDrawingItem)drawingItems.elementAt(i);
				dd.setLevel((int)i/iNumberPerRow);
				TRACE("processLevelData:HDL DI:"+dd.getUserDefinedName()+":Set to level:"+String.valueOf(i/iNumberPerRow),4);
				dd.setSheet(1);
			}

			hdlworkbench.setMaxLevel((int)((drawingItems.size()-1)/iNumberPerRow));
			TRACE("processLevelData:Max Level:"+String.valueOf(hdlworkbench.getMaxLevel()),4);
		}
		public void processCordData(Vector drawingitems) {
			for (int i=0;i<=hdlworkbench.getMaxLevel();i++) {
				int iNumOnLevel = 0;
				for (int ii=0;ii<drawingitems.size();ii++) {
					HDLDrawingItem d = (HDLDrawingItem)drawingitems.elementAt(ii);
					Rectangle rc = d.getBoundingRect();
					if (d.getLevel() == i) {
						int xCord = hdlworkbench.getMarginWidth() + ((hdlworkbench.getMarginWidth() + rc.width) * iNumOnLevel);
						int yCord = hdlworkbench.getMarginHeight() + ((hdlworkbench.getMarginHeight() + rc.height) * i);
						TRACE("processLevelData:HDL DI:"+d.getUserDefinedName()+":Set to ("+String.valueOf(xCord)+","+String.valueOf(yCord)+")",4);
						d.moveTo(new Point(xCord,yCord));
						iNumOnLevel++;
					}
				}
			}
		}
		public void createHDLDrawingItems(String filename) {
			org.w3c.dom.Element 	root;
			org.w3c.dom.Document 	doc;
			
			xmlDataFile hdlItems = new xmlDataFile();
			String filename1 = dataRelativePath+"/"+appDirectory+"/output/" + filename + "_hdlitems";
			TRACE("createHDLDrawingItems:XML Filename:"+filename1,4);
			if (!hdlItems.openXMLDataFile(filename1,"hdldrawingitems",false)) {
				displayDialog("Failed to open HDL drawing items XML Data");
				root = null;
				doc = null;
				return;
			}
			root = hdlItems.getRootElement();
			doc = hdlItems.getXMLDocument();
			
			HDLConnectors.removeAllElements();
			NodeList n = executeXPathExpr(doc,"/hdldrawingitems/entity");
			for (int i=0;i<n.getLength();i++) {
				org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(i);
				String entityName = e.getAttribute("name");
				String entityPath = e.getAttribute("path");
				TRACE("createHDLDrawingItems:entity name:"+entityName+":entity path:"+entityPath,4);

				NodeList n1 = executeXPathExpr(doc,"/hdldrawingitems/entity[@name='" + entityName + "']/allports");
				org.w3c.dom.Element e2 = (org.w3c.dom.Element)n1.item(0);
				String allPorts = e2.getAttribute("name");
				TRACE("createHDLDrawingItems:allports:"+allPorts,4);

				n1 = executeXPathExpr(doc,"/hdldrawingitems/entity[@name='" + entityName + "']/port");
				for (int ii=0;ii<n1.getLength();ii++) {
					org.w3c.dom.Element e1 = (org.w3c.dom.Element)n1.item(ii);
					String portName = e1.getAttribute("name");
					String portMode = e1.getAttribute("mode");
					String portType = e1.getAttribute("type");
					TRACE("createHDLDrawingItems:port name:"+portName+":mode:"+portMode+":type:"+portType,4);
				}
				HDLDrawingItem d = (HDLDrawingItem)getDrawingCanvas().addDrawingItem(getDrawingCanvas().getEntity(),dcTypeHDL,0,0,entityName,allPorts,entityPath,"",false,Color.black);
				d.setCanTransform(false);
				d.setUserDefinedName(entityName);
			}
			n = executeXPathExpr(doc,"/hdldrawingitems/connlist");
			for (int i=0;i<n.getLength();i++) {
				org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(i);
				String name = e.getAttribute("name");
				String entity = e.getAttribute("entity");
				String port = e.getAttribute("port");
				String clist = e.getAttribute("clist");
				TRACE("createHDLDrawingItems:conn list name:"+name+":Entity:"+entity+":Port:"+port+":list:"+clist,4);
				HDLConnectors.addElement(new HDLConnector(name.trim(),entity.trim(),port.trim(),clist.trim()));
			}
			
			hdlItems.closeXMLDataFile();
		} 
		public void rightClickAction(Vector v,MouseEvent evt) {;}
		public void leftClickAction(drawingItem d,MouseEvent evt) {;}
		public void leftClickSelectedAction(Vector v,MouseEvent evt) {;}
		public void doubleClickAction(drawingItem d,MouseEvent evt) {
			if (d != null) {
				if (d.getType() != dcTypeHDL) {return;}
				HDLDrawingItem dd = (HDLDrawingItem)d;
				TRACE("doubleClickAction:source filename:"+dataRelativePath+"/" + appDirectory + "/" + dd.getPath() + "/" + dd.getUserDefinedName() + "." + hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getFileExt(),4);
				miniTextEditor ddd = new miniTextEditor(getTopLevelParent(this),""+dataRelativePath+"/" + appDirectory + "/" + dd.getPath() + "/" + dd.getUserDefinedName() + "." + hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getFileExt());
				if (ddd.isSaved()) {
					displayDialog("point A");
					String fname = ""+dataRelativePath+"/" + appDirectory + "/" + dd.getPath() + "/" + dd.getUserDefinedName() + "." + hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getFileExt();
					hdlworkbench.setSystemName(fname);
					hdlworkbench.setSystemModified(false);
					hdlworkbench.setSystemFile(new ehsFile(fname));
					mainTab.getSEPComp().getHeader().removeAllMarkers();
					mainTab.HDLTA.setRawText(hdlworkbench.getSystemFile().loadFile());
					mainTab.getSEPComp().getHeader().updateMaxLineNumber(mainTab.getSEPComp().getEditorPane().getMaxLineNumber());
					mainTab.hdlSystemCompile();
					generateHDLBlocks();
				}
			}
		}
		public void hoverAction(drawingItem d,MouseEvent evt) {			
			if (d != null) {				
				if (d.getType() != dcTypeHDLConn) {return;}
				TRACE("hoverAction:Entered",4);
				
				msg3Dialog m3d = getHDLCodeWindow();			
				if (m3d == null) {
					JTextArea tf = null;
					JPanel p = new JPanel();
					HDLConnDrawingItem dd = (HDLConnDrawingItem)d;
					String code = "This port is connected to " + dd.getPortNetList();
					TRACE("hoverAction:PortNetList:"+code,4);
					tf = new JTextArea(code,2,iNumberCharacetrsInHDLCodePopupWindowRow);
					tf.setBackground(new Color(239,237,235));
					tf.setWrapStyleWord(true);
					tf.setEditable(false);
					Font newFont = tf.getFont().deriveFont(tf.getFont().getSize() - 2);
					tf.setFont(newFont);
					p.add(tf);						
					setHDLCodeWindow(displayPanelDialog(p,systemUserReg.getAppName()));
				}
			} else {
				msg3Dialog m3d = getHDLCodeWindow();
				if (m3d != null) {
					m3d.destory();
					m3d.dispose();
					setHDLCodeWindow((msg3Dialog)null);
				}
			}
		}
		public void customDoCommand(String cmd,String params,drawingItem d) {;}
		public void focusHandleHit(drawingItem d) {;}
      	public void actionPerformed(ActionEvent evt) {}
		public boolean canvasDoubleClickAction(MouseEvent evt) {return false;}
		public boolean canvasLeftClickAction(MouseEvent evt) {return false;}
	}

	public class resultsCanvas extends printableCanvas implements Printable,MouseListener {
		private	plotData	resultsData = null;
		private	int			hh = 0;
		private	int			ww = 0;

		private	int 		numTimeDivisions = 10;
		private	int 		x1gap = 15 * charWidth;
		private	int 		x2gap = 3 * charWidth;
		private	int 		y1gap = 3 * charHeight;
		private	int 		y2gap = 4 * charHeight;

		public resultsCanvas() {
			   addMouseListener(this);
			   resultsData = null;
			   hh = 0;
			   ww = 0;						   
		}
		public void loadResults() {
			   if (hdlworkbench.getSystemFile() == null) {			
				String fname = fileOpenDialog("","*." + hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getFileExt());
				if (fname == null) {resultsData = null;}
				hdlworkbench.setSystemName(fname);
				hdlworkbench.setSystemModified(false);
				hdlworkbench.setSystemFile(new ehsFile(fname));
				mainTab.getSEPComp().getHeader().removeAllMarkers();
				mainTab.HDLTA.setRawText(hdlworkbench.getSystemFile().loadFile());
			  }

			  if (resultsData != null) { // results data already loaded
			  } else {		
				resultsData = new plotData();
				if (resultsData.loadResults(supportFunctions.getFilenameNoExt(hdlworkbench.getSystemName())) == false) {resultsData = null;}
			  }
		}
		public int getHH() {return hh;}
		public int getWW() {return ww;}
		public Rectangle getBoundingRect() {return new Rectangle(0,0,ww,hh);}
		public plotData getPlotData() {return resultsData;}
		
		// PrinterJob calls the print method to render the graphics
		// object, starting at pageIndex of 0
		// return PAGE_EXISTS if you have printed that page
		// return NO_SUCH_PAGE if there are no more pages left
		   public int print(Graphics g,PageFormat format,int pagenum) {
			   if (pagenum > 0) {return Printable.NO_SUCH_PAGE;}
			   Dimension size = new Dimension(dcMaxX,dcMaxY);
			   Graphics2D g2d = printPageSetup(g,format,size);
			   //printing = true;
			   paint(g2d);
			   printingOnly(g2d);
			   //printing = false;
			   return Printable.PAGE_EXISTS;
		   }
		   public void printingOnly(Graphics2D g2d) {;}
		public void reDraw() {
			paint(getGraphics());
		}
		public void paint(Graphics g) {
			paint((Graphics2D)g);
		}
		public void mouseEntered(MouseEvent evt) {}
		public void mouseExited(MouseEvent evt) {}
		public void mouseClicked(MouseEvent evt) {}
		public void mousePressed(MouseEvent evt) {
			int xCord = evt.getX();
			int yCord = evt.getY();
			int button=evt.getModifiers();
			
			if ((button & MouseEvent.BUTTON3_MASK) != 0) {return;}

			Vector v = resultsData.getPlottedUniqueSignalNames();
			for (int i=0;i<v.size();i++) {
				Rectangle rcSignal = getSignalRect(i,(String)v.elementAt(i));
				if (rcSignal.contains(xCord,yCord)) {
					displayDialog("You clicked on signal " + (String)v.elementAt(i));
				}
			}
		}
		public void mouseReleased(MouseEvent evt) {}
		public Rectangle getSignalRect(int index,String signal) {
			return new Rectangle(x1gap,y1gap + ((index*2) * charHeight),ww,2*charHeight);
		}
		public void paint(Graphics2D g2d) {					
			g2d.setStroke(new BasicStroke(1));
			g2d.setColor(Color.blue);
			
			if (resultsData == null) {
				centerTextAtPoint(g2d,"Results file not found - " + supportFunctions.getFilenameNoExt(hdlworkbench.getSystemName()),getWidth() / 2,getHeight() / 2);
				return;
			}
						
			Vector v = resultsData.getPlottedUniqueSignalNames();
			
			hh = ((v.size() * 2) * charHeight) + (2*y1gap) + y2gap;
			ww = getWidth();
			setSize(ww,hh);
			
			g2d.drawLine(x1gap,y1gap,x1gap,hh - y2gap);
			g2d.drawLine(x1gap,hh - y2gap,ww - x2gap,hh - y2gap);
			
			TRACE("width:" + String.valueOf(ww) + " Height:" + String.valueOf(hh),9);
			
			int xAxisLength = ( ww - x2gap ) - x1gap;
			int yAxisLength = ( hh - y2gap ) - y1gap;
			int timeTickLength = xAxisLength / numTimeDivisions;
			int timeTickValue = (resultsData.getStopTime() - resultsData.getStartTime()) / numTimeDivisions;
			
			g2d.drawString(resultsData.getID(),2*charWidth,hh - (2 * charHeight));
			centerTextAtPoint(g2d,"Time (" + resultsData.getTimeUnits() + ")",x1gap  + (xAxisLength / 2),hh - charHeight - (charHeight / 2));
			for (int i=0;i<=numTimeDivisions;i++) {
				centerTextAtPoint(g2d,String.valueOf(i * timeTickValue),x1gap + (timeTickLength * i),hh - (3 * charHeight));
				TRACE("plot:"+String.valueOf(i * timeTickValue),9);
				TRACE("x:" + String.valueOf(x1gap + (timeTickLength * i)) + " y:" + String.valueOf(hh - (3 * charHeight)),9);
			}
			
			int betweenSignalGap = 0;
		for (int i=0;i<v.size();i++) {
				boolean bitSignal = false;
				betweenSignalGap = betweenSignalGap + 2;
				String signalName = (String)v.elementAt(i);
				g2d.drawString(signalName,2*charWidth,y1gap + (betweenSignalGap * charHeight));
				int signalXCord = x1gap;
				int signalYCord = y1gap + (betweenSignalGap * charHeight);
				Vector v1 = resultsData.getSignalPointData();
				float signalNewXCord,signalNewYCord;
				for (int j=0;j<v1.size();j++) {
					plotPointData ppd = (plotPointData)v1.elementAt(j);
					if (signalName.equals(ppd.getSignalName())) {
						TRACE("Signal: " + signalName + " Value:" + String.valueOf(ppd.getSignalValue()) + " Time: " + String.valueOf(ppd.getSignalTime()),4);
						if (ppd.getSignalType() == sigType.BIT) {
							bitSignal = true;
							signalNewXCord = x1gap + (( (float)ppd.getSignalTime() / (float)timeTickValue ) * (float)timeTickLength );
							signalNewYCord = signalYCord;
							g2d.drawLine(signalXCord,signalYCord,(int)signalNewXCord,(int)signalNewYCord);
							signalXCord = (int)signalNewXCord;
							signalYCord = (int)signalNewYCord;
							int yAdjust = 1;
							if ( Integer.parseInt(ppd.getSignalValue()) == 1) {yAdjust = -1;}
							signalNewYCord = signalYCord + ( yAdjust * charHeight);
							g2d.drawLine(signalXCord,signalYCord,(int)signalNewXCord,(int)signalNewYCord);
							signalXCord = (int)signalNewXCord;
							signalYCord = (int)signalNewYCord;
						} else {
							float centerXCord = x1gap + (( (float)ppd.getSignalTime() / (float)timeTickValue ) * (float)timeTickLength );
							float crossOverGap = 15;
							float textXCord = centerXCord + crossOverGap;
							float textYCord = signalYCord - ( charHeight / 2);
							g2d.drawString(ppd.getSignalValue(),textXCord,textYCord);
							g2d.drawLine(signalXCord,signalYCord,(int)(centerXCord-crossOverGap),signalYCord);
							g2d.drawLine((int)(centerXCord-crossOverGap),signalYCord,(int)textXCord,signalYCord-charHeight);
							g2d.drawLine(signalXCord,signalYCord-charHeight,(int)(centerXCord-crossOverGap),signalYCord-charHeight);
							g2d.drawLine((int)(centerXCord-crossOverGap),signalYCord-charHeight,(int)textXCord,signalYCord);
							signalXCord = (int)textXCord;
						}
				}
			}
				// complete signal plot to simulation end time
				if (bitSignal) {
					signalNewXCord = x1gap + (( resultsData.getStopTime() / timeTickValue ) * timeTickLength );
					g2d.drawLine(signalXCord,signalYCord,(int)signalNewXCord,signalYCord);
				} else {
					signalNewXCord = x1gap + (( resultsData.getStopTime() / timeTickValue ) * timeTickLength );
					g2d.drawLine(signalXCord,signalYCord,(int)signalNewXCord,signalYCord);
					g2d.drawLine(signalXCord,signalYCord-charHeight,(int)signalNewXCord,signalYCord-charHeight);
				}
			}
		}	
	}
	
	public enum sigType {BIT,BUS};	
	public class plotPointData {
		private	String	signalName;
		private	sigType signalType;
		private	String	signalValue;
		private int	signalTime;
		
		public plotPointData(String signalName,sigType signalType,String signalValue,int signalTime) {
			this.signalName = signalName;
			this.signalType = signalType;
			this.signalValue = signalValue;
			this.signalTime = signalTime;
		}
		
		public String getSignalName() {return signalName;}
		public sigType getSignalType() {return signalType;}
		public String getSignalValue() {return signalValue;}
		public int getSignalTime() {return signalTime;}
	}
	public class plotData {
		private	int	startTime;
		private int	stopTime;
		private Vector	pointData = new Vector();
		private Vector	signalNames = new Vector();
		private Vector	signalPlot = new Vector();
		private String	id = "";
		private String	timeUnits = "";
		
		public plotData() {
			startTime = 0;
			stopTime = 100;
			id = "";
		}
		public Vector getUniqueSignalNames() {return signalNames;} // return all signal names wheter to plot or not
		public Vector getPlottedUniqueSignalNames() {
			Vector v = new Vector();
			
			for (int i=0;i<signalNames.size();i++) {
				if (getSignalPlot((String)signalNames.elementAt(i))) {v.addElement((String)signalNames.elementAt(i));}
			}
			
			return v; // return all signal names to plot
		} 
		public Vector getSignalPointData() {return pointData;}
		public int getStartTime() {return startTime;}
		public void setStartTime(int t) {startTime = t;}
		public int getStopTime() {return stopTime;}
		public void setStopTime(int t) {stopTime = t;}
		public void setTimeUnits(String s) {timeUnits = s;}
		public String getTimeUnits() {return timeUnits;}
		public void setID(String s) {id = s;}
		public String getID() {return id;}
		public boolean getSignalPlot(String s) {
			int index = signalNames.indexOf(s);
			if (index != -1) {
				String tmp = (String)signalPlot.elementAt(index);
				if (tmp.equals("0")) {return false;}
			}
			return true;
		}
		public void setSignalPlot(String s,boolean b) {
			int index = signalNames.indexOf(s);
			if (index == -1) {return;}
			if (b) {signalPlot.setElementAt("1",index);} else {signalPlot.setElementAt("0",index);}
		}
		public boolean loadResults(String baseFilename) {
			pointData.removeAllElements();
			signalNames.removeAllElements();
			signalPlot.removeAllElements();
			
			ehsFile resultsFile = new ehsFile(""+dataRelativePath+"/"+appDirectory+"/output/results",baseFilename + ".res");
			String tmp = resultsFile.readFileLine(); // read simulation id string
			if (tmp == null) {return false;} // results file not found
			setID(baseFilename + " - " + tmp);
			tmp = resultsFile.readFileLine(); // read simulation time units
			setTimeUnits(tmp);
			tmp = resultsFile.readFileLine(); // read simulation start time
			setStartTime(Integer.parseInt(tmp));
			do {
				tmp = resultsFile.readFileLine();
				if (tmp != null && tmp.length() != 0) {
					if (tmp.contains(",")) {
						Vector v = supportFunctions.splitIntoTokens(tmp,",");
						String signame = (String)v.elementAt(0);
						if (signame.indexOf("intsignal") == 0) {continue;}
						sigType signalType = sigType.BIT;
						if (Integer.parseInt((String)v.elementAt(1)) == 1) {signalType = sigType.BUS;}
						plotPointData ppd = new plotPointData((String)v.elementAt(0),signalType,(String)v.elementAt(2),Integer.parseInt((String)v.elementAt(3)));
						pointData.addElement(ppd);
						
						if (!signalNames.contains((String)v.elementAt(0))) {
								signalNames.addElement((String)v.elementAt(0));
								signalPlot.addElement("1"); // default is to plot signal
						}
					} else {
						setStopTime(Integer.parseInt(tmp));
						return true;
					}
				}
			} while (tmp != null);
			
			return true;
		}
	}
	
	public class plotOptionsDialog extends positionDialog implements ActionListener {
		private JButton	butOK;
		private JButton butCancel;
		private ScrollPane sPane;
		private plotData pData;
		private Vector sigNames = new Vector();
		private Vector sigCB = new Vector();
	   
		public plotOptionsDialog(Frame parent,plotData pD) {
		   super(parent,"Plot Options",true);

		   pData = pD;
		   sigNames = pData.getUniqueSignalNames();
		   
		   butOK = new JButton("Ok");
		   butCancel = new JButton("Cancel");
		   butOK.addActionListener(this);
		   butCancel.addActionListener(this);
		   butOK.setPreferredSize(new Dimension(10*charWidth,charHeight));
		   butCancel.setPreferredSize(new Dimension(10*charWidth,charHeight));

		   JPanel p = new JPanel();
		   p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
		   p.add(butOK);
		   p.add(butCancel);
		   
		   JPanel  p1 = new JPanel();
		   sPane = new ScrollPane();
		   p1.setLayout(new GridLayout(2,(sigNames.size() / 2) + 1));
		   for (int i=0;i<sigNames.size();i++) {
				Checkbox cb = new Checkbox((String)sigNames.elementAt(i));
				cb.setState(pData.getSignalPlot((String)sigNames.elementAt(i)));
				sigCB.addElement(cb);
				p1.add(cb);
		   }
		   sPane.add(p1);
		   
		   add(sPane,"Center");
		   add(p,"South");
		   
		   addWindowListener(new WindowAdapter() {
   		     public void windowClosing(WindowEvent evt) {
			     dispose();
		     }
		   });
		   pack();
		   setVisible(true);
		   setSize(800,8*charHeight);
	   }
	  	   
	   public void destroy() {
	   	dispose();
	   }
	   
	   public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == butOK) {
				for (int i=0;i<sigNames.size();i++) {
					Checkbox cb = (Checkbox)sigCB.elementAt(i);
					pData.setSignalPlot((String)sigNames.elementAt(i),cb.getState());
				}
			   dispose();
		   }
		   if (evt.getSource() == butCancel) {
			   dispose();
		   }
	   }
	}

 	public class resultsCard extends Panel implements ActionListener {
		private JPanel		resultsPanel,statusPanel;
		private	resultsCanvas	rCanvas;
		private JButton		printButton,optionsButton,exportButton;
		private ScrollPane	sPane;
		
		resultsCard() {
			printButton = new JButton("Print");
			printButton.addActionListener(this);
			printButton.setToolTipText("Print Results");
			optionsButton = new JButton("Plot Options");
			optionsButton.addActionListener(this);
			optionsButton.setToolTipText("Plot Options");
			exportButton = new JButton("Export JPG");
			exportButton.addActionListener(this);
			exportButton.setToolTipText("Export JPG");
			
			setLayout(new BorderLayout());
			resultsPanel = new JPanel();
			resultsPanel.setLayout(new BoxLayout(resultsPanel,BoxLayout.Y_AXIS));
			resultsPanel.setBorder(BorderFactory.createTitledBorder("Results"));
			
			statusPanel = new JPanel();
			statusPanel.setLayout(new BoxLayout(statusPanel,BoxLayout.X_AXIS));
			statusPanel.add(printButton);
			statusPanel.add(exportButton);
			statusPanel.add(optionsButton);
			
			resultsPanel.add(statusPanel);
			rCanvas = new resultsCanvas();
			sPane = new ScrollPane();
			sPane.setSize(resultsPanel.getWidth(),rCanvas.getHH());
			sPane.add(rCanvas);
			resultsPanel.add(sPane);
			add(resultsPanel);
		}
		public void updateResultsCard() {
			rCanvas.loadResults();
			rCanvas.reDraw();
		}
      		public void actionPerformed(ActionEvent evt) {
    			if (evt.getSource() == printButton) {
    				rCanvas.printCanvas();
    			}
    			if (evt.getSource() == exportButton) {
    				rCanvas.saveAsJPG(rCanvas.getBoundingRect(), "");
    			}
			if (evt.getSource() == optionsButton) {
				plotOptionsDialog dlg = new plotOptionsDialog(getTopLevelParent(this),rCanvas.getPlotData());
				updateResultsCard();
			}
		}
	}

	public class helpCard extends Panel implements ActionListener {
		private JTextArea	messageWidget;
		private	JButton		reportBut;

		helpCard() {
			setLayout(new BorderLayout());
			Panel textPanel = new Panel(new FlowLayout(FlowLayout.CENTER));
			messageWidget = new JTextArea("",26,50);
			messageWidget.setBackground(lightyellow);
			messageWidget.setWrapStyleWord(true);
			supportFunctions.displayTextFile(exHelpFile,messageWidget);
			messageWidget.append("\n");
			messageWidget.append(systemUserReg.getInfoText());
			messageWidget.setEditable(false);
			JScrollPane pane = new JScrollPane(messageWidget);
			pane.setPreferredSize(new Dimension(50*charWidth,15*charHeight));
			textPanel.add(pane);
			reportBut = new JButton("End House Software Help Center");
			textPanel.add(reportBut);
			reportBut.addActionListener(this);
			add(textPanel,"Center");
		}
		public void updateHelpCard() {}
		public void actionPerformed(ActionEvent evt) {
			if (evt.getSource() == reportBut) {toggleTheProf();}
		}
	}

	public void stateChanged(ChangeEvent e) {
		boolean showCard = true;	
				
		if(e.getSource() == tabPane) {

			// perform common actions needed when switching to another tab
			designTab.updateDesignCard(false);			
			
			if(tabPane.getSelectedComponent() == mainTab) {
				mainTab.updateMainCard();
			}
			if(tabPane.getSelectedComponent() == designTab) {
				designTab.updateDesignCard(true);
			}
			if(tabPane.getSelectedComponent() == resultsTab) {
				resultsTab.updateResultsCard();
			}
			if(tabPane.getSelectedComponent() == helpTab) {
				helpTab.updateHelpCard();
			}
			
			if(showCard == false) {
//				tabPane.setSelectedComponent(Tab1);
			}
		}
	}
	public void deleteFilename(String filename) {
		ehsFile tmp = new ehsFile(filename);
		tmp.deleteFile();
	}
		public String getRemoteHostName(String ipaddr) {
			String hostname = "";
			try {
				hostname = InetAddress.getByName(ipaddr).getHostName();
			}
			catch (Exception e) {return "";}
			return hostname;
		}
		public void writeHitRecord(String product) {
			String ipAddr = "0.0.0.0";
			String reverse = getRemoteHostName(ipAddr);
			String tmp = currentShortDate();
			tmp = tmp.replace('/','-');
			systemMysql.executeSQLQuery("INSERT INTO sysehswebstats (sysEHSWSID,sysEHSWSProduct,sysEHSWSIP,sysEHSWSDate,sysEHSWSTime,sysEHSWSRef,sysEHSWSReverse) VALUES (null,'"+product+"','"+ipAddr+"','"+tmp+"','"+currentShortTime()+":00','','"+reverse+"')","");
		}
		
		public Vector removeNumberTokens(Vector v) {
			Vector n = new Vector();
			for (int i=0;i<v.size();i++) {
				try {
					int num = Integer.parseInt((String)v.elementAt(i));
				} catch (Exception e) {
					n.addElement((String)v.elementAt(i));
				}
			}
			
			return n;
		}
		
		public interface msgQueueProcess {
			public void msgQueuePollStart(String msgQueue);
			public void msgQueuePollStop(String msgQueue);
			
			public void msgSet(String msgQueue,String msg);
			public void msgGet(String msgQueue);
			public void msgDelete(String msgQueue);
			public void msgPollData(String msgQueue,String data);
			public void msgQueueCleanupProcess(String msgQueue);
		}
		public class msgQueue {
			private	String				queueName = "";
			private	String				queueDesc = "";
			private int					currentMsgID = -1;
			private	int					msgPollPeriod = 1000; //ms
			private	boolean 			bMsgQueuePollActive = false;
			private msgQueueProcess		target = null;
			private msgQueuePoll		poll = null;
			
			public class msgQueuePoll extends Thread {
				private	int		pollPeriod = 1000;
				private boolean bRunThread = true;
				
				msgQueuePoll() {}
				msgQueuePoll(int ms) {pollPeriod = ms;}
				public void run() {
					while (bRunThread) {
						if (target != null) {target.msgQueueCleanupProcess(getMsgQueueName());}
						
						String data = getMsg(getMsgQueueName());
						if (data.length() > 0) {
							if (target != null) {target.msgPollData(getMsgQueueName(),data);}
						}
						try {Thread.sleep(pollPeriod);} catch (Exception e) {}				
					}
				}
				public void end() {bRunThread = false;}
			}

			msgQueue() {}
			msgQueue(String name,String desc) {
				queueName = name;
				queueDesc = desc;
				
				String data = systemMysql.executeSQLQuery("SELECT MAX(ehsmsgserverID) FROM ehsmsgservers","-1");
				currentMsgID = Integer.parseInt(data);
			}
			
			public void startMsgQueuePoll() {
				bMsgQueuePollActive = true;
				
				poll = new msgQueuePoll(msgPollPeriod);
				poll.start();

				if (target != null) {target.msgQueuePollStart(getMsgQueueName());}
			}
			public void stopMsgQueuePoll() {
				if (poll != null) {
					poll.end();
					bMsgQueuePollActive = false;
					poll = null;

					if (target != null) {target.msgQueuePollStop(getMsgQueueName());}
				}
			}
			
			public void setMsg(String msgQueue,String msg) {
				if (target != null) {target.msgSet(msgQueue,msg);}	
				
				systemMysql.executeSQLQuery("INSERT INTO ehsmsgservers (ehsmsgserversID,ehsmsgserverQueue,ehsmsgserversMsg) VALUES (null,'" + msgQueue + "','" + msg + "')","");
			}
			public String getMsg(String msgQueue) {
				if (target != null) {target.msgGet(msgQueue);}	
				
				String data = systemMysql.executeSQLQuery("SELECT FROM ehsmsgservers ehsmsgserverID,ehsmsgserverMsg WHERE ehsmsgserverQueue='" + msgQueue + "' AND ehsmsgserverID>" + String.valueOf(currentMsgID) + " LIMIT 1","");
				if (data.length() > 0) {
					Vector v = supportFunctions.splitIntoTokens(data);
					currentMsgID = Integer.parseInt((String)v.elementAt(0));
					return (String)v.elementAt(1);
				}
				
				return "";
			}
			
			public String getMsgQueueName() {return queueName;}
			public String getMsgQueueDesc() {return queueDesc;}
			public void addMsgQueueListener(msgQueueProcess target) {this.target = target;}
			public void removeMsgQueueListener() {target = null;}
			public void setMsgPollPeriod(int ms) {msgPollPeriod = ms;}
		
			public void deleteMsgQueue(String msgQueue) {
				if (target != null) {target.msgDelete(msgQueue);}	

				systemMysql.executeSQLQuery("DELETE FROM ehsmsgservers WHERE ehsmsgserverQueue='" + msgQueue + "'","");
			}
		}

		public class datagramPacket {
		   private InetAddress 	recAddress = null;
		   private int		recPort = -1;
		   private String	recData = "";
		   private int		socketBufferSize = 1024;
			
		   public String getData() {return recData;}
		   public InetAddress getAddress() {return recAddress;}
		   public String getHostName() {return recAddress.getHostName();}
		   public int getPort() {return recPort;}
		   public void sendDatagram(DatagramSocket ds,String data,String hostname,int port) {
			   try {sendDatagram(ds,data,InetAddress.getByName(hostname),port);} catch(Exception e) {e.printStackTrace();}
		   }
		   public void sendDatagram(DatagramSocket ds,String data,InetAddress address,int port) {
			try {
				byte[] buf = data.getBytes();
				DatagramPacket packet = new DatagramPacket(buf, buf.length, address, port);
				ds.send(packet);
				TRACE("Datagram Sent: " + data + "(port:" + String.valueOf(port) + ")",4);
			} catch(Exception e) {e.printStackTrace();}
		   }
		   public void sendMulticastDatagram(MulticastSocket ds,String data,String group,int port) {
			   try {sendMulticastDatagram(ds,data,InetAddress.getByName(group),port);} catch(Exception e) {e.printStackTrace();}
		   }
		   public void sendMulticastDatagram(MulticastSocket ds,String data,InetAddress group,int port) {
			try {
				byte[] buf = data.getBytes();
				ds.joinGroup(group);
				DatagramPacket packet = new DatagramPacket(buf, buf.length, group, port);
				ds.send(packet);
				ds.leaveGroup(group);
				TRACE("Datagram Sent: " + data + "(port:" + String.valueOf(port) + ")",4);
			} catch(Exception e) {e.printStackTrace();}
		   }
		   public boolean receiveDatagram(DatagramSocket ds) {
			   return receiveDatagram(ds,0);
		   }
		   public boolean receiveDatagram(DatagramSocket ds,int timeout) {
			try {
				byte[] buf = new byte[socketBufferSize];
				DatagramPacket packet = new DatagramPacket(buf, buf.length);
				// the receive function will block until a datagram arrives
				// the max size of a datagram is 65,507 bytes
				// any packets an applet receives from another applet host will be discared
				ds.setSoTimeout(timeout);
				ds.receive(packet);
				recAddress = packet.getAddress();
				recPort = packet.getPort();
				recData = new String(packet.getData(),0,packet.getLength());
				TRACE("Datagram Received: " + recData + "(port:" + String.valueOf(recPort) + ")",4);
			}
			catch(InterruptedIOException e) {return false;}
			catch(Exception e) {return false;}
			return true;
		   }
		   public boolean receiveMulticastDatagram(MulticastSocket ds,String group) {
			   return receiveMulticastDatagram(ds,group,0);
		   }
		   public boolean receiveMulticastDatagram(MulticastSocket ds,String group,int timeout) {
			try {
				byte[] buf = new byte[socketBufferSize];
				InetAddress gr = InetAddress.getByName(group);
				ds.joinGroup(gr);
				DatagramPacket packet = new DatagramPacket(buf, buf.length);
				// the receive function will block until a datagram arrives
				// the max size of a datagram is 65,507 bytes
				// any packets an applet receives from another applet host will be discared
				ds.setSoTimeout(timeout);
				ds.receive(packet);
				recAddress = packet.getAddress();
				recPort = packet.getPort();
				recData = new String(packet.getData(),0,packet.getLength());
				TRACE("Multicast Datagram Received: " + recData + "(port:" + String.valueOf(recPort) + ")",4);
				ds.leaveGroup(gr);
			}
			catch(InterruptedIOException e) {return false;}
			catch(Exception e) {return false;}
			return true;
		   }
		}
		
		boolean useSocketServer = true;
		String appProcessName = "";
		DatagramSocket appProcessSocket = null;
		int socketStatus = serverMode;
		int portnum = 4445;
		public void setSocketServer(boolean b) {useSocketServer = b;}
		public void setPortNumber(int i) {portnum = i;}
		public boolean isSocketServer() {return useSocketServer;}
		public boolean isServerProcess() {if (socketStatus == serverMode) {return true;} else {return false;}}
		public boolean isClientProcess() {if (socketStatus == clientMode) {return true;} else {return false;}}
		public boolean isNoneProcess() {if (socketStatus == noneMode) {return true;} else {return false;}}
		public String getAppProcessName() {return appProcessName;}
		public int getPortNumber() {return portnum;}
		public void appProcessStart() {
			if (!isSocketServer()) {socketStatus=noneMode;return;}
			if (socketStatus != noneMode) {
			   try {
				appProcessSocket = new DatagramSocket(portnum);
				TRACE(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + ":Server Started",4);
				socketStatus = serverMode;
			   }
			   catch(SecurityException e) {
				socketStatus = noneMode;
				TRACE(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + ":Sockets Security Exception",4);
			   }
			   catch(SocketException e) {
				socketStatus = clientMode;
				appProcessSocket=null;
				TRACE(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + ":Client Mode",4);
			   }
			}
		}
		public void appProcessEnd() {
			if (appProcessSocket != null) {
				 appProcessSocket.close();
				 appProcessSocket=null;
				 TRACE(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + ":Server Terminated",4);
				}
		}
		public void appProcessThread() {
			// this is always regually called from the thread even if we are not the server!
			if (isServerProcess()) { // server processes
				datagramPacket dp = new datagramPacket();
				dp.receiveDatagram(appProcessSocket);
				String packet = dp.getData();
				if (packet.startsWith("Alive Query")) {
					dp.sendDatagram(appProcessSocket,"Alive Response",dp.getAddress(),dp.getPort());
				}
			} 
			if (isClientProcess()) { // client processes
			   try {
				DatagramSocket ds = new DatagramSocket();
				datagramPacket dp = new datagramPacket();
				dp.sendDatagram(ds,"Alive Query","localhost",portnum);
				if (dp.receiveDatagram(ds,10000)) {
					String packet = dp.getData();
					ds.close();
				} else {
					ds.close();
					TRACE(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + ":Server Died",4);
					socketStatus = serverMode;
					appProcessStart();
				}
			   }
			   catch(Exception e) {
				socketStatus = noneMode;
				TRACE(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + ":Sockets Security Exception",4);
			   }
			}
		}
		
		boolean appProcessThreadStarted = false;
		Thread appProcessThread = null;
		int appProcessThreadPeriod = 1000;
		int appProcessThreadPrioity = 5;
		public void startPerApplicationProcess() {
			try {
			   appProcessName = "EHS-"+"HW-"+currentShortDate().replace('/', '-')+currentShortTime().replace(':', '-');
			   appProcessStart();
			   TRACE("Starting Per Application Processes",4);
			   appProcessThreadStarted = true;
			   appProcessThread = new Thread(new Runnable() {
				public void run() {
				   while (appProcessThreadStarted) {
				      try {
					appProcessThread();
					appProcessThread.sleep(appProcessThreadPeriod);
					appProcessThread.yield();
				     } catch (InterruptedException e) {break;}	
				  }
			        }
			   });
			   appProcessThread.setPriority(appProcessThreadPrioity);
			   appProcessThread.setName("EHS App Process Thread");
			   appProcessThread.start();	
			}
			catch(Exception e) {;}
		}
		public void finishPerApplicationProcess(){
			TRACE("Ending Per Application Processes",4);
			appProcessThreadStarted = false; // stops the thread
			appProcessEnd();
		}
		
	public class miniWebBrowser implements HyperlinkListener,PropertyChangeListener {
		private JEditorPane		ta;
		private	java.util.List	history = new ArrayList();
		private	int				MAX_HISTORY = 50;
		private	int				currentHistoryPage = -1;
		private	JToolBar		tools = new JToolBar();
		private backAction		backCommand = new backAction();
		private forwardAction	forwardCommand = new forwardAction();
		private printAction		printCommand = new printAction();
		private JPanel			webPanel = new JPanel();

		public class backAction extends AbstractAction {
			   public backAction() {super("Back");putValue(SHORT_DESCRIPTION,"Backward Page");}
			   public void actionPerformed(ActionEvent evt) {
				   back();
			   }
		}
		public class forwardAction extends AbstractAction {
			   public forwardAction() {super("Forward");putValue(SHORT_DESCRIPTION,"Forward Page");}
			   public void actionPerformed(ActionEvent evt) {
				   forward();
			   }
		}
		public class printAction extends AbstractAction {
			   public printAction() {super("Print");putValue(SHORT_DESCRIPTION,"Print Page");}
			   public void actionPerformed(ActionEvent evt) {
				   print();
			   }
		}
		
		private miniWebBrowser() {
			ta = new JEditorPane();			
			ta.addHyperlinkListener(this);
			ta.addPropertyChangeListener(this);
			ta.setEditable(false);
			ta.setContentType("text/html");
		}
		miniWebBrowser(URL u) {
			try {
				tools.add(backCommand);
				tools.add(forwardCommand);
				tools.add(printCommand);
				
				backCommand.setEnabled(false);
				forwardCommand.setEnabled(false);
				
				ta = new JEditorPane();			
				ta.addHyperlinkListener(this);
				ta.addPropertyChangeListener(this);
				ta.setEditable(false);
				ta.setPage(u);
				String ref = u.getRef();
				if (ref != null) {ta.scrollToReference(ref);}
				
				webPanel.add(new JScrollPane(ta),BorderLayout.CENTER);
				webPanel.add(tools,BorderLayout.NORTH);
				displayPanelDialog(webPanel,"Mini Web Browser");
				
			} catch (Exception e) {}
		}
		public void propertyChange(PropertyChangeEvent evt) {
			if (evt.getPropertyName().equals("page")) {
				// set when page has finished loading ...
			}
		}
		public void hyperlinkUpdate(HyperlinkEvent evt) {
			   if (evt.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
			   	  try {
				  	  URL u = evt.getURL();
				  	  history.add(u);
				  	  int num = history.size();
				  	  if (num > MAX_HISTORY + 10) {
				  		  history = history.subList(num - MAX_HISTORY, num);
				  		  num = MAX_HISTORY;
				  	  }
				  	  currentHistoryPage = num - 1;
				  	  if (currentHistoryPage > 0) {
				  		  backCommand.setEnabled(true);
				  	  }
				  	  
					  ta.setPage(u);
					  String ref = u.getRef();
					  if (ref != null) {ta.scrollToReference(ref);}
				  } catch (IOException e) {}
			   }
			   if (evt.getEventType() == HyperlinkEvent.EventType.ENTERED) {
				   showStatus(evt.getURL().toString());
			   }
			   if (evt.getEventType() == HyperlinkEvent.EventType.EXITED) {
				   showStatus("");
			   }
		}
		public void back() {
			try {
				if (currentHistoryPage > 0) {
					ta.setPage((URL)history.get(--currentHistoryPage));
					backCommand.setEnabled(currentHistoryPage > 0);
					forwardCommand.setEnabled(currentHistoryPage < history.size() - 1);
				}
			} catch (Exception e) {;}
		}
		public void forward() {
			try {
				if (currentHistoryPage < history.size() - 1) {
					ta.setPage((URL)history.get(++currentHistoryPage));
					backCommand.setEnabled(currentHistoryPage > 0);
					forwardCommand.setEnabled(currentHistoryPage < history.size() - 1);
				}
			} catch (Exception e) {;}
		}
		public void print() {
			PrinterJob job = PrinterJob.getPrinterJob();
			PrintableDocument pd = new PrintableDocument(ta);
			job.setPageable(pd);
			if (job.printDialog()) {
				try {
					job.print();
				} catch (Exception e) {;}
			}
		}
	}
	/**
	 * This class implements the Pageable and Printable interfaces and allows
	 * the contents of any JTextComponent to be printed using the java.awt.print
	 * printing API.
	 **/
	public class PrintableDocument implements Pageable, Printable {
	    View root;              // The root View to be printed
	    PageFormat format;      // Paper plus page orientation
	    double scalefactor;     // How much to scale before printing
	    int numPages;           // How many pages in the document
	    double printX, printY;  // coordinates of upper-left of print area
	    double printWidth;      // Width of the printable area
	    double printHeight;     // Height of the printable area
	    Rectangle drawRect;     // The rectangle in which the document is painted

	    // How lenient are we with the bottom margin in widow/orphan prevention?
	    static final double MARGIN_ADJUST = .97;

	    // The font we use for printing page numbers
	    final Font headerFont = new Font("Serif", Font.PLAIN, 12);

	    /**
	     * This constructor allows printing the contents of any JTextComponent
	     * using a default PageFormat and a default scale factor.  The default
	     * scale factor is .75 because the default fonts are overly large.
	     */
	    public PrintableDocument(JTextComponent textComponent) {
		this(textComponent, new PageFormat(), .75);
	    }

	    /** 
	     * This constructor allows the contents of any JTextComponent to be
	     * printed, using any specified PageFormat object and any scaling factor.
	     **/
	    public PrintableDocument(JTextComponent textComponent, PageFormat format,
				     double scalefactor)
	    {
		// Remember the page format, and ask it for the printable area
		this.format = format;
		this.scalefactor = scalefactor;
		this.printX = format.getImageableX()/scalefactor;
		this.printY = format.getImageableY()/scalefactor;
		this.printWidth = format.getImageableWidth()/scalefactor;
		this.printHeight = format.getImageableHeight()/scalefactor;
		double paperWidth = format.getWidth()/scalefactor;

		// Get the document and its root Element from the text component
		Document document = textComponent.getDocument();
		Element rootElement = document.getDefaultRootElement();
		// Get the EditorKit and its ViewFactory from the text component
		EditorKit editorKit =textComponent.getUI().getEditorKit(textComponent);
		ViewFactory viewFactory = editorKit.getViewFactory();

		// Use the ViewFactory to create a root View object for the document
		// This is the object we'll print.  
		root = viewFactory.create(rootElement);

		// The Swing text architecture requires us to call setParent() on
		// our root View before we use it for anything.  In order to do this,
		// we need a View object that can serve as the parent.  We use a 
		// custom implementation defined below.
		root.setParent(new ParentView(root, viewFactory, textComponent));

		// Tell the view how wide the page is; it has to format itself
		// to fit within this width.  The height doesn't really matter here
		root.setSize((float)printWidth, (float)printHeight);

		// Now that the view has formatted itself for the specified width,
		// Ask it how tall it is.  
		double documentHeight = root.getPreferredSpan(View.Y_AXIS);

		// Set up the rectangle that tells the view where to draw itself
		// We'll use it in other methods of this class.
		drawRect = new Rectangle(0, 0, (int)printWidth, (int)documentHeight);

		// Now if the document is taller than one page, we have to 
		// figure out where the page breaks are.
		if (documentHeight > printHeight) paginate(root, drawRect);

		// Once we've broken it into pages, figure out how many pages.
		numPages = pageLengths.size() + 1;
	    }

	    // This is the starting offset of the page we're currently working on
	    double pageStart = 0;
	    
	    /**
	     * This method loops through the children of the specified view,
	     * recursing as necessary, and inserts pages breaks when needed.
	     * It makes a rudimentary attempt to avoid "widows" and "orphans".
	     **/
	    protected void paginate(View v, Rectangle2D allocation) {
		// Figure out how tall this view is, and tell it to allocate
		// that space among its children
		double myheight = v.getPreferredSpan(View.Y_AXIS);
		v.setSize((float)printWidth, (float)myheight);

		// Now loop through each of the children
		int numkids = v.getViewCount();
		for(int i = 0; i < numkids; i++) {
		    View kid = v.getView(i);  // this is the child we're working with
		    // Figure out its size and location
		    Shape kidshape = v.getChildAllocation(i, allocation);
		    if (kidshape == null) continue;
		    Rectangle2D kidbox = kidshape.getBounds2D();

		    // This is the Y coordinate of the bottom of the child
		    double kidpos = kidbox.getY() + kidbox.getHeight() - pageStart;
		   
		    // If this is the first child of a group, then we want to ensure
		    // that it doesn't get left by itself at the bottom of a page.
		    // I.e. we want to prevent "widows"
		    if ((numkids > 1) && (i == 0)) {
			// If it is not near the end of the page, then just move
			// on to the next child
			if (kidpos < printY + printHeight*MARGIN_ADJUST) continue;

			// Otherwise, the child is near the bottom of the page, so
			// break the page before this child and place this child on
			// the new page.
			breakPage(kidbox.getY());
			continue;
		    }

		    // If this is the last child of a group, we don't want it to
		    // appear by itself at the top of a new page, so allow it to
		    // squeeze past the bottom margin if necessary.  This helps to
		    // prevent "orphans"
		    if ((numkids > 1) && (i == numkids-1)) {
			// If it fits normally, just move on to the next one
			if (kidpos < printY + printHeight) continue;

			// Otherwise, if it fits with extra space, then break the
			// page at the end of the group
			if (kidpos < printY + printHeight/MARGIN_ADJUST) {
			    breakPage(allocation.getY() + allocation.getHeight());
			    continue;
			}
		    }

		    // If the child is not the first or last of a group, then we use
		    // the bottom margin strictly.  If the child fits on the page,
		    // then move on to the next child.
		    if (kidpos < printY+printHeight) continue;

		    // If we get here, the child doesn't fit on this page.  If it has
		    // no children, then break the page before this child and continue.
		    if (kid.getViewCount() == 0) {
			breakPage(kidbox.getY());
			continue;
		    }

		    // If we get here, then the child did not fit on the page, but it
		    // has kids of its own, so recurse to see if any of those kids
		    // will fit on the page.
		    paginate(kid, kidbox);
		}
	    }

	    // For a document of n pages, this list stores the lengths of pages 
	    // 0 through n-2.  The last page is assumed to have a full length
	    ArrayList pageLengths = new ArrayList();

	    // For a document of n pages, this list stores the starting offset of
	    // pages 1 through n-1.  The offset of page 0 is always 0
	    ArrayList pageOffsets = new ArrayList();

	    /** 
	     * Break a page at the specified Y coordinate.  Store the necessary
	     * information into the pageLengths and pageOffsets lists
	     **/
	    void breakPage(double y) {
		double pageLength = y-pageStart-printY;
		pageStart = y-printY;
		pageLengths.add(new java.lang.Double(pageLength));
		pageOffsets.add(new java.lang.Double(pageStart));
	    }

	    /** Return the number of pages. This is a Pageable method.   */
	    public int getNumberOfPages() { return numPages; }

	    /** 
	     * Return the PageFormat object for the specified page.  This is a
	     * Pageable method. This implementation uses the computed length of the
	     * page in the returned PageFormat object.  The PrinterJob will use this
	     * as a clipping region, which will prevent extraneous parts of the
	     * document from being drawn in the top and bottom margins.
	     **/
	    public PageFormat getPageFormat(int pagenum) {
		// On the last page, just return the user-specified page format
		if (pagenum == numPages-1) return format;

		// Otherwise, look up the height of this page and return an
		// appropriate PageFormat.
		double pageLength = ((java.lang.Double)pageLengths.get(pagenum)).doubleValue();
		PageFormat f = (PageFormat) format.clone();
		Paper p = f.getPaper();
		if (f.getOrientation() == PageFormat.PORTRAIT)
		    p.setImageableArea(printX*scalefactor, printY*scalefactor,
				       printWidth*scalefactor, pageLength*scalefactor);
		else 
		    p.setImageableArea(printY*scalefactor, printX*scalefactor,
				       pageLength*scalefactor, printWidth*scalefactor);
		f.setPaper(p);
		return f;
	    }

	    /**
	     * This Pageable method returns the Printable object for the specified
	     * page.  Since this class implements both Pageable and Printable, it just
	     * returns this.
	     **/
	    public Printable getPrintable(int pagenum) { return this; }

	    /**
	     * This is the basic Printable method that prints a specified page
	     **/
	    public int print(Graphics g, PageFormat format, int pageIndex) {
		// Return an error code on attempts to print past the end of the doc
		if (pageIndex >= numPages) return NO_SUCH_PAGE;

		// Cast the Graphics object so we can use Java2D operations
		Graphics2D g2 = (Graphics2D)g;
		
		// Translate to accomodate the top and left margins
		g2.translate(format.getImageableX(), format.getImageableY());
		
		// Scale the page by the specified scaling factor
		g2.scale(scalefactor, scalefactor);

		// Display a page number centered in the area of the top margin.
		// Set a new clipping region so we can draw into the top margin
		// But remember the original clipping region so we can restore it
		if (pageIndex > 0) {
		    Shape originalClip = g.getClip();
		    g.setClip(new Rectangle(0, (int)-printY,
					    (int)printWidth, (int)printY));
		    // Compute the header to display, measure it, then display it
		    String numString = "- " + (pageIndex+1) + " -";
		    // Get string and font measurements
		    FontRenderContext frc = g2.getFontRenderContext();
		    Rectangle2D numBounds = headerFont.getStringBounds(numString, frc);
		    LineMetrics metrics = headerFont.getLineMetrics(numString, frc);
		    g.setFont(headerFont);    // Set the font
		    g.setColor(Color.black);  // Print with black ink
		    g.drawString(numString,   // Display the string
				 (int)((printWidth-numBounds.getWidth())/2),
				 (int)(-(printY-numBounds.getHeight())/2 +
				       metrics.getAscent()));
		    g.setClip(originalClip);  // Restore the clipping region
		}

		// Get the staring position and length of the page within the document
		double pageStart = 0.0, pageLength = printHeight;
		if (pageIndex > 0)
		    pageStart = ((java.lang.Double)pageOffsets.get(pageIndex-1)).doubleValue();
		if (pageIndex < numPages-1)
		    pageLength = ((java.lang.Double)pageLengths.get(pageIndex)).doubleValue();

		// Scroll so that the appropriate part of the document is lined up
		// with the upper-left corner of the page
		g2.translate(0.0, -pageStart);

		// Now paint the entire document.  Because of the clipping region,
		// only the desired portion of the document will actually be drawn on
		// this sheet of paper.
		root.paint(g, drawRect);

		// Finally return a success code
		return PAGE_EXISTS;
	    }

	    /** 
	     * This inner class is a concrete implementation of View, with a 
	     * couple of key method implementations.  An instance of this class
	     * is used as the parent of the root View object we want to print
	     **/
	    class ParentView extends View {
		ViewFactory viewFactory; // The ViewFactory for the hierarchy of views
		Container container;     // The Container for the hierarchy of views

		public ParentView(View v, ViewFactory viewFactory, Container container)
		{
		    super(v.getElement());
		    this.viewFactory = viewFactory;
		    this.container = container;
		}

		// These methods return key pieces of information required by
		// the View hierarchy.
		public ViewFactory getViewFactory() { return viewFactory; }
		public Container getContainer() { return container; }

		// These methods are abstract in View, so we've got to provide
		// dummy implementations of them here, even though they're never used.
		public void paint(Graphics g, Shape allocation) {}
		public float getPreferredSpan(int axis) { return 0.0f; }
		public int viewToModel(float x,float y,Shape a,Position.Bias[] bias) {
		    return 0;
		}
		public Shape modelToView(int pos, Shape a, Position.Bias b)
		    throws BadLocationException {
		    return a;
		}
	    }
	}
	public class languageStrings {
		private Locale locale = null;
		private ResourceBundle rb = null;
		
		public Locale getLocale() {return locale;}
		public ResourceBundle getBundle() {return rb;}
		public languageStrings () {
			setNewLang(Locale.getDefault());
		}
		public languageStrings (Locale locale) {
			setNewLang(locale);
		}
		public void setNewLang(Locale locale) {
			this.locale = locale;
			loadRB(locale);
		}
		public void loadRB(Locale locale){
			try {
				TRACE("Loading resource bundle: intlresources",4);
				rb = ResourceBundle.getBundle("intlresources",locale);
			} catch (Exception e) {e.printStackTrace();}
		}
		public Object getObject(String key) {
			if (rb == null) {return "";}
			return rb.getObject(key);
		}
		public String getString(String key) {
			if (rb == null) {return "";}
			return rb.getString(key);
		}
		public Enumeration getKeys() {
			if (rb == null) {return null;}
				return rb.getKeys();
		}
	}	
	
	public String getEnumValues(Enum e) {
		String ret = "";
		Class c = e.getDeclaringClass();
		Object[] values = c.getEnumConstants();
		if (values != null) {
			for (int i=0;i<values.length;i++) {
				TRACE("getEnumValues:"+String.valueOf(i)+":" + values[i],4);
				if (i != 0) {ret = ret + ",";}
				ret = ret + values[i];
			}
		}
		return ret;
	}

	public void init() {			
		bRunAppWithGUI = true;
		setLocation(0,0);
		setSize(windowXMax,windowYMax);
		invalidate();
		validate();

		setNativeLookAndFeel();
		contentPane = getContentPane();
		tabPane = new JTabbedPane();

		systemUserReg = new registrationinfo("HDL Work Bench","HDL Work Bench","WB1000","01.63.0000.00","01/02/18","(c) End House Software 2007-2019",bRemoteHosted);
		systemMysql = new mysqlJDBC();
		systemMysql.connect();
		String data = systemMysql.executeSQLQuery("SELECT sysEHSDeptName FROM sysehsdepartments","Admin,Enquiry,Technical,Sales");
		Vector v = supportFunctions.splitIntoTokens(data);
		systemUserReg.setDepts(v);
		systemUserReg.setPreRelease(true);
		systemUserReg.registerUser();

		systemAudioClips = new sounds();
		
		help = new helpAction();
		about = new aboutAction();
		
		JMenuBar menuBar = new JMenuBar();
		JMenu fileMenu = new JMenu("File");
		JMenu helpMenu = new JMenu("Help");
		helpMenu.add(help);
		helpMenu.add(about);
		menuBar.add(fileMenu);
		menuBar.add(helpMenu);
		if(getSystemVar(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "menubar",0) == 1) {setJMenuBar(menuBar);}
		
		smallWords = supportFunctions.splitIntoTokens(swords);
			
		ac = getAppletContext();
					   
		msg2Dialog msgD = displayModelessStatusDialog("HDL Work Bench is Loading");
		
		msgD.setText("Loading Internationalization Database");
		lStrings = new languageStrings();
		
		msgD.setText("Creating User Panels");

		fm = getFontMetrics(getFont());
		charHeight = fm.getHeight(); // + fm.getAscent(); remove GDB 09/07/2014
		charWidth = fm.stringWidth("O");

		hdlworkbench = new hdlSystem();
		mainTab = new mainCard();
		designTab = new designCard();
		resultsTab = new resultsCard();
		helpTab = new helpCard();
		
		contentPane.setLayout(new BorderLayout());
		tabPane.add("Main",mainTab);
		tabPane.add("Design",designTab);
		tabPane.add("Results",resultsTab);
		tabPane.add("Help",helpTab);
		tabPane.addChangeListener(this);
		contentPane.add(tabPane,"Center");

		maxSoundID = 0;
		systemAudioClips.createNumberSounds(maxSoundID + extraSounds);

		msgD.setText("Loading The Professor");
		theProf = new chatAVI(dataRelativePath + "/images/prof.gif",0,0,"Professor",adminEmail,false,windowXMax,windowYMax);
		systemAudioClips.loadSound(dataRelativePath + "/sounds/prof.wav",maxSoundID+profSoundID);
		
		ciHelp = new customIcon();
		int[] x5 = {6,10,10,6};
		int[] y5 = {15,15,13,13};
		customIconData ciD = new customIconData(x5,y5,Color.black);
		ciHelp.addData(ciD);
		int[] x6 = {7,9,9,10,10,11,10,11,11,10,10,9,9,5,5,4,4,3,3,5,5,6,6,9,9,10,10,9,9,8,8,7,7};
		int[] y6 = {12,12,9,9,7,7,6,6,4,4,3,3,1,1,3,3,4,4,8,8,4,4,3,3,4,4,6,6,7,7,8,8,12};
		ciD = new customIconData(x6,y6,Color.black);
		ciHelp.addData(ciD);
		
		writeHitRecord("hdlwb");
		
		msgD.destory();
		msgD.dispose();
		
		setSocketServer(false);
		setPortNumber(4445);
		startPerApplicationProcess();	

		parentFrame = getTopLevelParent(this);
		machineID = getMachineUniqueIDInternal();
		
		String data1 = systemMysql.executeSQLQuery("SELECT sysEHSProdKBFilename FROM sysehsproducts WHERE sysEHSProdName='" + systemUserReg.getAppName() + "'","");
		exFAQFile = dataRelativePath + "/knowledgebases/" + data1;
		TRACE("init:Knowledgebase file:"+exFAQFile,4);
	}
		public String getMachineUniqueIDInternal() {
			if (systemUserReg.getAppRemotedHosted()) {return "1";}
			
			pseduoFile f = new pseduoFile(""+dataRelativePath+"/" + appDirectory + "/.licence");
			String  s = f.loadFile();
			if (s.length() != 0) {return s.trim();}
			
			int tmp = getSystemVar("muniquecount",0);
			setSystemVar("muniquecount",tmp+1);

			pseduoFile f1 = new pseduoFile(""+dataRelativePath+"/" + appDirectory + "/.licence");
			f1.saveFile(String.valueOf(tmp));
			f1.flush();
			
			return String.valueOf(tmp);
		}
		public String getMachineUniqueString() {
			return getMachineUniqueIDInternal();
		}
		public int getMachineUniqueID() {
			try {
				return Integer.parseInt(getMachineUniqueIDInternal());
			} catch (Exception e) {return 0;}
		}
	public int ehsHashCode(String s) {
		int hc = 0;
		for (int i=0;i<s.length();i++) {
			char ch = s.charAt(i);
			hc = hc + ch;
		}
		return hc;
	}

	public String currentDate() {
		DateFormat f = DateFormat.getDateInstance(DateFormat.LONG);
		return f.format(new Date());
	}	

	public String currentTime() {
		DateFormat f = DateFormat.getTimeInstance(DateFormat.LONG);
		return f.format(new Date());
	}	
	public String currentShortDate() {
		DateFormat f = DateFormat.getDateInstance(DateFormat.SHORT);
		return f.format(new Date());
	}	

	public String currentShortTime() {
		DateFormat f = DateFormat.getTimeInstance(DateFormat.SHORT);
		return f.format(new Date());
	}

	public int daysTillExpired(Date expDate) {
		Date currentDate = new Date();
		long expTime = expDate.getTime();
		long currTime = currentDate.getTime();
		long diff = expTime - currTime;
		return (int)diff/(1000*60*50*24);
	}
	public String stringPart(String token) {
		if (token.length() == 0) {return (String)null;}
		
		int index = 0;
		for (int i=0;i<token.length();i++) {
			if (!Character.isDigit(token.charAt(i))) {break;}
			index++;
		}
		if (index == token.length()-1) {return null;}
		return token.substring(index);
	}

	public int numberPart(String token) {
		if (token.length() == 0) {return 0;}

		int index = 0;
		for (int i=0;i<token.length();i++) {
			if (!Character.isDigit(token.charAt(i))) {break;}
			index++;
		}
		if (index == token.length()-1) {return 0;}
		return Integer.parseInt(token.substring(0,index));
	}
	
	public String decbin(int num) {
		return Integer.toBinaryString(num);
	}
	public String decoct(int num) {
		return Integer.toOctalString(num);
	}
	public String dechex(int num) {
		return Integer.toHexString(num);
	}	
	
	public String reverseStringByWord(String s) {
		Stack stack = new Stack();
		StringTokenizer strTok = new StringTokenizer(s);
		while(strTok.hasMoreTokens()) {
			stack.push(strTok.nextElement());
		}
		StringBuffer revStr = new StringBuffer();
		while(!stack.isEmpty()) {
			revStr.append(stack.pop());
			revStr.append(" ");
		}
		return revStr.toString().trim();
	}
	
	public String reasembleTokens(Vector v,int start,int end,String seps) {
		String result = "";
		for(int i=0;i<v.size();i++) {
			if (i>=start && i<=end) {
				if(i != start) {result = result + seps;}
				result = result + (String)v.elementAt(i);
			}
		}
		return result;
	}
	public String reasembleTokens(Vector v,int start) {
		return reasembleTokens(v,start,v.size()-1,",");
	}
	public String reasembleTokens(Vector v,String seps) {
		return reasembleTokens(v,0,v.size()-1,seps);	
	}
	public String reasembleTokens(Vector v) {
		return reasembleTokens(v,0,v.size()-1,",");
	}

	public String removeDupTokens(String data) {
		   return removeDupTokens(data,",");
	}
	
	public String removeDupTokens(String data,String seps) {
		Vector tmp = new Vector();
		Vector v = supportFunctions.splitIntoTokens(data,seps);

		TRACE("removeDupTokens - " + data);
		String result = "";
		if(v.size() == 0) {return result;}
		result = (String)v.elementAt(0);
		for(int i=1;i<v.size();i++) {
			if(!tmp.contains((String)v.elementAt(i))) {
				tmp.addElement((String)v.elementAt(i));
				result = result + seps + (String)v.elementAt(i);
			}
		}

		TRACE(result);
		return result;
	}
	
	Vector addWords = new Vector();
	Vector ignoreWords = new Vector();
	String dictOwner = "";
	public String stripSpecialCharacters(String s) {
		   return s;
	}
	public void loadUserDictionary(String user) {
		   clearUserDictionary();
		   dictOwner = user;
		   String data = systemMysql.executeSQLQuery("SELECT FROM sysehswords sysehswordsID WHERE sysehswordsOwner='"+user+"'","");
		   TRACE("User Dict: " + data,3);
		   Vector v = supportFunctions.splitIntoTokens(data);
		   for (int i=0;i<v.size();i++) {
		   	   String data1 = systemMysql.executeSQLQuery("SELECT FROM sysehswords sysehswordsType,sysehswordsWord WHERE sysehswordsID="+(String)v.elementAt(i),"");
			   Vector v1 = supportFunctions.splitIntoTokens(data1);
			   int wordType = Integer.parseInt((String)v1.elementAt(0));
			   switch (wordType) {
			   		  case scaddword:
					  	   addWords.addElement((String)v1.elementAt(1));
						   break;
			   		  case scignoreword:
					  	   ignoreWords.addElement((String)v1.elementAt(1));
						   break;
			   }
		   }
	}
	public void clearUserDictionary() {
		   addWords.removeAllElements();
		   ignoreWords.removeAllElements();
		   dictOwner = "";
	}
	public String getDictOwner() {return dictOwner;}
	public void setDictOwner(String s) {dictOwner = s;}
	public void storeWord(String word,int wordType,String wordOwner) {
		   systemMysql.executeSQLQuery("INSERT INTO sysehswords (sysehswordsID,sysehswordsType,sysehswordsWord,sysehswordsOwner) VALUES (null,"+String.valueOf(wordType)+",'"+word+"','"+wordOwner+"')","");
	}
	public void spellCheck(JTextField tf) {
		   String word = selectCurrentWord(tf);
		   String data = checkWord(word);
           if(data.length() == 0) {return;}
		   replaceCurrentWord(tf,word);
    }
	public String spellCheck(String s) {
		   if (s.length() == 0) {return s;}
		   Vector v = supportFunctions.splitIntoTokens(s," ");
		   String s2 = "";
		   String tmp = checkWord((String)v.elementAt(0));
		   if (tmp.length() == 0) {s2 = (String)v.elementAt(0);} else {s2 = tmp;}
		   for (int i=1;i<v.size();i++) {
		   	   tmp = checkWord((String)v.elementAt(i));
		   	   if (tmp.length() == 0) {s2 = s2 + (String)v.elementAt(i);} else {s2 = s2 + tmp;}
		   }
		   return s2;		    
	}
	public String checkWord(final String s) {
		   String newWord = stripSpecialCharacters(s);
		   String[] params = {"word",newWord};
		   String alts = supportFunctions.executePHPScript(remoteHostRelativePath+"/webcommon/spellcheck",params,newWord);
		   alts = alts + newWord;
		   Vector v = supportFunctions.splitIntoTokens(alts);
		   if (v.size() == 1) {return "";}
		   Object[] opts = new Object[v.size()];
		   v.copyInto(opts);
		   if (addWords.contains(newWord) || ignoreWords.contains(newWord)) {return s;}
		   Object sel = JOptionPane.showInputDialog(null,"Select Correct Word","Spell Check",JOptionPane.QUESTION_MESSAGE,null,opts,opts[v.size()-1]);
		   if (sel == null) {
			ActionListener addTask = new ActionListener() {
      		   public void actionPerformed(ActionEvent evt) {
			   		 storeWord(s,scaddword,dictOwner);
			   }
			};
  			JButton addBut = new JButton("Add Word");
			addBut.addActionListener(addTask);
			ActionListener ignoreTask = new ActionListener() {
      		   public void actionPerformed(ActionEvent evt) {
			   		 storeWord(s,scignoreword,dictOwner);
			   }
			};
  			JButton ignoreBut = new JButton("Ignore Word");
			ignoreBut.addActionListener(ignoreTask);
		   	  Object sels[] = {addBut,ignoreBut,"Cancel"};
			  int ret=JOptionPane.showOptionDialog(null,"Add/Ignore Word","Spell Checker",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,sels,sels[2]);
		   	  return "";
		   }
		   return (String)sel;
	} 
	public String selectCurrentWord(JTextField tf) {
		   Vector v = getWordStartEndPos(tf.getText(),tf.getCaretPosition());
		   tf.select(Integer.parseInt((String)v.elementAt(0)),Integer.parseInt((String)v.elementAt(1))+1);
		   return tf.getSelectedText();
	}
	
	public void replaceCurrentWord(JTextField tf,String word) {
		   String oldText = tf.getText();
		   Vector v = getWordStartEndPos(tf.getText(),tf.getCaretPosition());
		   String newText = oldText.substring(0,Integer.parseInt((String)v.elementAt(0))) + word + oldText.substring(Integer.parseInt((String)v.elementAt(1)),oldText.length());
		   tf.setText(newText);		   
	}	
	
	public Vector getWordStartEndPos(String s,int spos) {
	   Vector v = new Vector();
	   if (spos<0 || spos>s.length()) {return v;}
	   StringBuffer b = new StringBuffer(s);
	   int index = 0;
	   for (int i=spos;i>-1;i--) {
	      if (b.charAt(i) == ' ') {index=i+1;break;}
	   }
	   v.addElement(String.valueOf(index));
	   index = s.length()-1;
	   for(int i=spos+1;i<s.length();i++) {
	      if (b.charAt(i) == ' ') {index=i-1;break;}
	   }	   
	   v.addElement(String.valueOf(index));
	   return v;
	}

	public String posSearchStr(String keywords) {
		Vector v = supportFunctions.splitIntoTokens(keywords);
		if (v.size()==0) {return "";}
		String tmp = "POSITION('"+(String)v.elementAt(0)+"' IN sysEHSHelpText)>0";
		if (v.size()==1) {return tmp;}
		for (int i=1;i<v.size();i++) {
			tmp = tmp + " AND POSITION('"+(String)v.elementAt(i)+"' IN sysEHSHelpText)>0";
		}
		return tmp;
	}
	
	public void populateChoice(Choice c,Vector v) {
		c.removeAll();
		for (int i=0;i<v.size();i++) {
			c.addItem((String)v.elementAt(i));
		}
	}
	
	public String replace(String s,String search,String replace,boolean bAll) {
		int index = s.indexOf(search);
		if (index == -1) {return s;}
		String tmp = s.substring(0,index)+replace+s.substring(index+search.length());
		if (bAll == true) {
			return replace(tmp,search,replace,bAll);
		}
		return tmp;
	}

	public String pad(String s,String pad,int finalLength,int padDir) {
		if (s.length() >= finalLength) {return s;}
		String finalStr = "";
		if (padDir == strPadRight) {finalStr = s;}
		for (int i=0;i<finalLength-s.length();i=i+pad.length()) {
			finalStr = finalStr + pad;
		}
		if (padDir == strPadLeft) {finalStr = finalStr + s;}
		return finalStr;
	}
	
	public int strCount(String s,char ch) {
		int count = 0;
		StringBuffer b = new StringBuffer(s);
		for (int i=0;i<b.length();i++) {
			if (ch == b.charAt(i)) {count++;}
		}
		return count;
	}

	public void tileImage(Graphics g,Component c,Image i) {
		   Rectangle r = c.getBounds();
		   int iw = i.getWidth(c);
		   int ih = i.getHeight(c);
		   if ((iw<=0) || (ih<=0)) {return;}
		   for (int x=0;x<r.width;x+=iw) {
		   	   for (int y=0;y<r.height;y+=ih) {
			   	   g.drawImage(i,x,y,c);
			   }
		   }
	}
	
	public void toggleTheProf() {
		   if (profDlg == null) {
		   	  profDlg = new profDialog(getTopLevelParent(this));
		   } else {
		   	   profDlg.destory();
			   profDlg.dispose();
			   profDlg = null;
		   }
	}
	public void askTheProf(String s) {
		   if (profDlg == null) {toggleTheProf();}
		   profDlg.getAnswer(s);
	}
	public void tellTheProf(String q,String s) {
		   if (profDlg == null) {toggleTheProf();}
		   profDlg.ta.setText(s);
		   profDlg.tf.setText(q);
		   systemAudioClips.playSound(maxSoundID+profSoundID);
	}

	public class chatAVI {
		private	Rectangle	aviRect;
		private	boolean		aviEmailVisible;
		private	boolean		aviInRoom;
		private	boolean		aviSpeeking;
		private	String		aviFilename;
		private	String		aviName;
		private	String		aviCurMsg;
		private	String		aviCurPrAvi;
		private	String		aviEmail;
		private	int			aviDir;
		private	int			aviMaxX;
		private	int			aviMaxY;
		private int			aviType;
		private	pictureCanvas	aviCanvas;
		private boolean		aviDockable;
		
		chatAVI(String filename,int x,int y,String name, String email, boolean visible, int mX, int mY) {
		   createAVI(filename,x,y,name,email,visible,mX,mY,false);
		}
		chatAVI(String filename,int x,int y,String name, String email, boolean visible, int mX, int mY,boolean dockable) {
		   createAVI(filename,x,y,name,email,visible,mX,mY,dockable);
		}
		public void createAVI(String filename,int x,int y,String name,String email,boolean visible,int mX,int mY,boolean dockable) {
			aviCanvas = new pictureCanvas(filename,chatAVISizeX,chatAVISizeY);
			aviMaxX = mX;
			aviMaxY = mY;
			aviDir = 1;
			aviName = name;
			aviFilename = filename;
//			displayDialog("chatAvi="+filename);
			aviEmail = email;
			aviEmailVisible = visible;
			aviSpeeking = false;
			aviCurMsg = "";
			aviCurPrAvi = "";
			aviInRoom = false;
			aviType = aviUser;
			aviDockable = dockable;
			setAviXY(x,y);
		}
		
		public void setAviType(int i) {aviType = i;}
		public int getAviType() {return aviType;}
		public boolean getAviDockable() {return aviDockable;}
		public boolean getAviTest() {if (aviType == aviTest) {return true;} else {return false;}}
		public void setAviTest(boolean b) {if(b==true) {aviType = aviTest;} else {aviType = aviUser;}}
		public Image getAviImage() {return aviCanvas.image();}
		public void setAviSpeeking(boolean speek) {aviSpeeking = speek;}
		public int getAviDir() {return aviDir;}
		public String getAviEmail() {
			if(aviEmailVisible) {
				return aviEmail;
			} else {
				return "Sorry, user's email is not avialable";
			}		
		}
		public String getAviFilename() {return aviFilename;}
		public boolean getAviEmailVisible() {return aviEmailVisible;}
		public int getAviMaxX() {return aviMaxX;}
		public int getAviMaxY() {return aviMaxY;}
		public void setInRoom(boolean b) {
			aviInRoom = b;
		}
		public int getAviWidth() {
			return aviRect.width;
		}
		public int getAviHeight() {
			return aviRect.height;
		}
		public void setAviXY(int x, int y) {
			aviRect = new Rectangle(x,y,aviCanvas.width(),aviCanvas.height());
			calcDir();
		}
		public pictureCanvas getAviCanvas() {return aviCanvas;}
		public void drawAvi(Graphics g) {drawAvi(g,0,false);}
		public Rectangle getAviRect() {return aviRect;}
		public void drawAvi(Graphics g,int nextDockablePos,boolean dockable) {
			   drawAvi(g,nextDockablePos,dockable,Color.yellow);
		}
		public void drawAvi(Graphics g,int nextDockablePos,boolean dockable,Color c) {
			if (!dockable) {
			   aviCanvas.paint(g,aviRect.x,aviRect.y);
			   boxCenterText(g,c,aviName,aviRect.x,aviRect.y+aviRect.height,aviRect.width,fm.getHeight());
			} else {
				int vGap = aviRect.height / 3;
				int hGap = aviRect.width / 4;
				int numPerRow = MaxX / (aviRect.width + hGap);
				int row = (nextDockablePos % numPerRow) + 1;
				int xCord = aviMaxX - (nextDockablePos * (aviRect.width + hGap));
				int yCord = (vGap + aviRect.height) * row;
				setAviXY(xCord,yCord);
				aviCanvas.paint(g,xCord,yCord);
			}
		}
		public void calcDir() {
			aviDir = aviRHS;
			if(aviRect.x + (numDirAvis * aviRect.width) > aviMaxX) {
				aviDir = aviLHS;
			}
		}
		public String getMsg() {return aviCurMsg;}
		public String getPrivateAvi() {return aviCurPrAvi;}
		public void moveAvi(int x, int y) {
			setAviXY(x,y);
		}
		public boolean getInRoom() {return aviInRoom;}
		public String getAviName() {return aviName;}
		public boolean pointInAvi(int x, int y) {
			return aviRect.contains(x,y);
		}
		public void speakAvi(String msg, String pName) {
		}
		public void setAviMsg(String s) {aviCurMsg=s;}
		public void setPrivateAvi(String s) {aviCurPrAvi=s;}
	}
	
	public class ccCardCredits extends Panel {
		public ccCardCredits() {
			JPanel p = new JPanel();
			p.setBorder(BorderFactory.createTitledBorder(""));
			p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
			p.add(new JLabel(systemUserReg.getHTMLInfoText()));
			add(p);
		}
		public void updateCreditsCard() {}
	}
	public class ccCardActions extends Panel {
		public ccCardActions() {
			JPanel p = new JPanel();
			p.setBorder(BorderFactory.createTitledBorder("Actions"));
			p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
			p.add(new JLabel("<html><font color='red'>To Be Implemented</font></html>"));
			add(p);
		}
		public void updateActionsCard() {}
	}
	
	public class JCustomButton extends JButton {
		public JCustomButton(String lab) {
			this(lab,"",null);
		}
		public JCustomButton(String label,String tooltip,customIcon ciIcon) {
			super(label);
			if (ciIcon != null) {
				setIcon(ciIcon);
				setPressedIcon(ciIcon);
				setRolloverIcon(ciIcon);
				setDisabledIcon(ciIcon);
			}
			setToolTipText(tooltip);
		}
	}
	
	public class ccCard extends Panel implements ActionListener {
		   private JCustomButton helpBut;
		public ccCard() {
				  JPanel p = new JPanel();
				  p.setBorder(BorderFactory.createTitledBorder("Control Panel"));
				  p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
				  helpBut = new JCustomButton("","Help",ciHelp);
				  helpBut.addActionListener(this);
				  p.add(helpBut);
		}
		public void updateccCard() {}
		   public void actionPerformed(ActionEvent evt) {
				  if (evt.getSource() == helpBut) {
				  	 toggleHelp();
				  }
		   }
		public void toggleHelp() {
			   if (helpDlg == null) {
			   	  helpDlg = displayHelpDialog();
			   } else {
			   	 helpDlg.destroy();
				 helpDlg.dispose();
				 helpDlg = null;
			  }
		}
	}
	
	public class controlPanelDialog extends positionDialog implements ChangeListener {
		   private ccCard ccTab;
		   private ccCardCredits ccCreditsTab;
		   private ccCardActions ccActionsTab;
		   private JTabbedPane tabPane1;
		   
		   public controlPanelDialog(Frame parent) {
		   		  super(parent,"Control Panel",false);
				  setLayout(new BorderLayout());
				  ccTab = new ccCard();
				  ccActionsTab = new ccCardActions();
				  ccCreditsTab = new ccCardCredits();
				  tabPane1 = new JTabbedPane();
				  tabPane1.add("Chat",ccTab);
				  tabPane1.add("Actions",ccActionsTab);
				  tabPane1.add("Credits",ccCreditsTab);
				  add(tabPane1,"Center");
				  tabPane1.addChangeListener(this);
				  addWindowListener(new WindowAdapter() {
				  	  public void WindowClosing(WindowEvent evt) {
					  		 destory();
						  	 controlPanelDlg = null;
							 dispose();
					  }
				  });
				  pack();
				  loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "cpanel");
				  setVisible(true);
		   }
		   public void destory() {savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "cpanel");dispose();}
		   public void stateChanged(ChangeEvent evt) {
			   if (evt.getSource() == tabPane1) {
				   if (tabPane1.getSelectedComponent()==ccTab) {
					   ccTab.updateccCard();
				   }
				   if (tabPane1.getSelectedComponent()==ccCreditsTab) {
					   ccCreditsTab.updateCreditsCard();
				   }
				   if (tabPane1.getSelectedComponent()==ccActionsTab) {
					   ccActionsTab.updateActionsCard();
				   }
			   }
		   }
	}
	public class profDialog extends positionDialog implements ActionListener {
		   private JTextArea ta;
		   private JTextField tf;
		   private JButton askProfBut,updateHelpBut,moreHelpBut;
		   
		   public profDialog(Frame parent) {
		   		  super(parent,"The Professor",false);
		   		  
				  pictureCanvas pcan = theProf.getAviCanvas();
				  JPanel p1 = new JPanel();
				  p1.setLayout(new FlowLayout(FlowLayout.CENTER));
				  p1.add(pcan);
				  
				  askProfBut = new JButton("Ask The Professor");
				  askProfBut.addActionListener(this);
				  updateHelpBut = new JButton("Update Help");
				  updateHelpBut.addActionListener(this);
				  moreHelpBut = new JButton("More...");
				  moreHelpBut.addActionListener(this);
				  boolean bEnable = false;
				  TRACE("sendReport:userid:"+systemUserReg.getUserID(),4);
				  if (systemUserReg.getUserID().equals("gavin") || systemUserReg.getUserID().equals("admin")) {bEnable = true;}
				  updateHelpBut.setEnabled(bEnable);

				  JPanel p2 = new JPanel();
				  p2.setLayout(new BoxLayout(p2,BoxLayout.X_AXIS));
				  p2.add(askProfBut);
				  p2.add(moreHelpBut);
				  p2.add(updateHelpBut);

				  JPanel p = new JPanel();
				  p.setBorder(BorderFactory.createTitledBorder(""));
				  p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
				  p.add(p1);
				  p.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
				  JLabel lab = new JLabel("Type Question Here:");
				  lab.setAlignmentX(Component.LEFT_ALIGNMENT);
				  p.add(lab);
				  tf = new JTextField("",20);
				  tf.setBackground(new Color(255,255,170));
				  p.add(tf);
				  p.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
				  ta = new JTextArea("",10,20);
				  ta.setBackground(new Color(255,255,170));
				  ta.setEditable(false);
				  p.add(ta);
				  p.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
				  p.add(p2);
				  
				  add(p);
				  
				  pack();
				  setVisible(true);
				  addWindowListener(new WindowAdapter() {
				  	  public void WindowClosing(WindowEvent evt) {destroy();}
				  });
		   }
		   public void destory() {savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "prof");profDlg=null;dispose();}
		   public void actionPerformed(ActionEvent evt) {
		   		  if (evt.getSource() == askProfBut) {
				  	 getAnswer(tf.getText());
				  }
		   		  if (evt.getSource() == moreHelpBut) {
		   			  systemUserReg.sendReport("");
				  }
		   		  if (evt.getSource() == updateHelpBut) {
		   			  updateHelpTopics(systemUserReg.getAppName(),exHelpFile,true);
				  }
		   }
		   public void getAnswer(String question) {
			 tf.setText(question);
			 Vector v = supportFunctions.splitIntoTokens(question," ");
			 Vector keywords = notIntersect(v,smallWords);
			 if (keywords.size() == 0) {displayDialog("Please include more keywords in your question");return;}
			 String keywordsStr = reasembleTokens(keywords);
			 displayHelpTopics(getRankedHelpTopics(systemUserReg.getAppName(),keywordsStr),ta);
		   }
	}
	
	interface imageUtils {
			  public void imageLoaded(backgroundImageLoad bil);
	}
	public class backgroundImageLoad extends Thread {
		   private imageUtils		 target;
		   private Image		 image;
		   private String		 imageName;
		   private boolean		 imageLoaded;
		   private int			 imageID;
		   
		   public backgroundImageLoad(String name,imageUtils iu,int id) {
		   		  target = iu;
				  setName("BackgroundImageLoad - " + name);
				  imageID = id;
				  imageName = name;
				  image = null;
				  imageLoaded = false;
				  Toolkit toolkit = Toolkit.getDefaultToolkit();
				  image = toolkit.getImage(imageName);
			}
			public Image image() { 
				   if (imageLoaded) {return image;} else {return null;}
			}
			public void run() {
				   bilmt.addImage(image,imageID);
				   try {
				   	   int status = bilmt.statusID(imageID,true);
					   while (status == MediaTracker.LOADING) {
						   repaint();
						   Thread.sleep(bilSleepPeriod);
						   status = bilmt.statusID(imageID,true);
					   }
				   }
				   catch (Exception e) {e.printStackTrace();}
				   imageLoaded = true;
				   if (target != null) {target.imageLoaded(this);}
			}
	}
		
	public interface pictureUtils {
		public void pictureStart();
		public void pictureFinish();
		public void picturePaint(Graphics g);
	}

	public class pictureCanvas extends printableCanvas implements Printable {
		private	Image		picImage = null;
		private	int		picWidth,picHeight;
		private	pictureUtils	target;
		
		pictureCanvas(String name,int mx,int my) {
			setuppictureCanvas(name,mx,my);
		}
		pictureCanvas(int mx,int my) {
			setuppictureCanvas("",mx,my);
		}
		pictureCanvas(String name) {
			setuppictureCanvas(name,noScaleX,noScaleY);
		}
		public void setuppictureCanvas(String name,int mx,int my) {
			  picImage = null;
			  target = null;
		   	  picWidth = mx;
			  picHeight = my;
			  setSize(mx,my);
			  if (name.length() != 0) {pictureLoad(name);}
		}
		public void removePictureListener() {target = null;}
		public void addPictureListener(pictureUtils pu) {target = pu;}
		public void pictureLoad(String name) {
			TRACE("Loading image " + name,4);
			picStartLoading();
						
//			try {picImage = doBackgroundImageLoadNew(new URL(getCodeBase(),name));} catch (Exception e) {}

			MediaTracker picTracker = new MediaTracker(this);
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			picImage = toolkit.getImage(name);
			picTracker.addImage(picImage,0);
			try {picTracker.waitForID(0);} catch (InterruptedException e) {}
			if (picTracker.isErrorAny()) {
				TRACE("Error in loading image " + name,4);
			}

			picFinishLoading();
			if (picWidth == noScaleX) {
				picWidth = picImage.getWidth(this);
				picHeight = picImage.getHeight(this);
			} 
			setSize(picWidth,picHeight);
			repaint();
		}
		public void picStartLoading() {
			TRACE("picStartLoading called",4);
			if (target != null) {target.pictureStart();}
		}
		public void picFinishLoading() {
			TRACE("picFinishLoading called",4);
			if (target != null) {target.pictureFinish();}
		}	
		public int print(Graphics g,PageFormat format,int pagenum) {
			if (pagenum>0) {return Printable.NO_SUCH_PAGE;}
			Dimension size = new Dimension(picWidth,picHeight);
			Graphics2D g2d = printPageSetup(g,format,size);
			paint(g2d);
			return Printable.PAGE_EXISTS;
		}
		public void update(Graphics g) {
			paint(g);
		}
		public void paint(Graphics g) {
			paint(g,0,0);
		}
		public void paint(Graphics g,int x,int y) {
			if (picImage != null) {
				g.drawImage(picImage,x,y,picWidth,picHeight,this);
			}
			if (target != null) {target.picturePaint(g);}
		}
		public void setImage(Image i) {
			TRACE("setImage in pictureCanvas called");
			picImage = i;
			if (picWidth == noScaleX) {
				picWidth = picImage.getWidth(this);
				picHeight = picImage.getHeight(this);
			} 
			setSize(picWidth,picHeight);
			repaint();
		}
		public int height() {return picHeight;}
		public int width() {return picWidth;}
		public Image image() {return picImage;}		
	}

	public void displayHTMLPanel(String html,int rows,int cols) {
		Frame top = getTopLevelParent(this);
		htmlDialog d = new htmlDialog(top,html,rows,cols);
		d.dispose();
	}
	public void displayHTMLPanel(String html) {
		displayHTMLPanel(html,25,5);
	}

	public class htmlDialog extends JDialog implements ActionListener {
		private	Button	ok;
		private JEditorPane ta1;

		public htmlDialog(Frame parent,String html,int rows,int cols) {
			super(parent,"Infomation",true);
			setLayout(new FlowLayout());
			ta1 = new JEditorPane();
			ta1.setEditable(false);
			ta1.setContentType("text/html");
			ta1.setBackground(Color.yellow);
			ta1.setText(html);
			JPanel textPanel = new JPanel();
			JScrollPane pane = new JScrollPane(ta1);
			pane.setPreferredSize(new Dimension(rows*charWidth,cols*charHeight));
			textPanel.add(pane);
			add(textPanel);
			ok = new Button("Ok");
			ok.addActionListener(this);
			add(ok);
			pack();
			setVisible(true);
		}
		
		public void actionPerformed(ActionEvent evt) {
			if (evt.getSource() == ok) {dispose();}
		}
	}	

	public class msgDialog extends positionDialog implements ActionListener {
		private	Button	ok;

		public msgDialog(Frame parent,String msg,String id) {
			super(parent,"Infomation",true,id);
			msgDialogInit(msg);
		}
		public msgDialog(Frame parent,String msg) {
			super(parent,"Infomation",true);
			msgDialogInit(msg);
		}
		public void msgDialogInit(String msg) {
			setLayout(new FlowLayout());
			add(new Label(msg));
			ok = new Button("Ok");
			ok.addActionListener(this);
			add(ok);
			pack();
			setVisible(true);
		}
		
		public void actionPerformed(ActionEvent evt) {
			if (evt.getSource() == ok) {dispose();}
		}
	}

	public class msg1Dialog extends positionDialog {

		public msg1Dialog(Frame parent,String title,String msg) {
			super(parent,title,false);
			setLayout(new FlowLayout(FlowLayout.CENTER));
			add(new Label(msg));
			pack();
			setVisible(true);
		}
		public msg1Dialog(Frame parent,String title,String msg,String id) {
			super(parent,title,false,id);
			setLayout(new FlowLayout(FlowLayout.CENTER));
			add(new Label(msg));
			pack();
			setVisible(true);
		}
		
		public void destory() {
			dispose();
		}
	}

	public interface msg2DialogUtils {
		public void buttonClicked();
	}
	public class msg2Dialog extends positionDialog implements ActionListener {
		private TextField ta;
		private JButton   cancel;
		private boolean	  cancelPressed = false;
		private	msg2DialogUtils	target;
		
		public msg2Dialog(Frame parent,String msg,boolean cancelable,String id) {
			super(parent,msg,false,id);
			msg2DialogInit(cancelable);
		}
		public msg2Dialog(Frame parent,String msg,boolean cancelable) {
			super(parent,msg,false);
			msg2DialogInit(cancelable);
		}
		public void msg2DialogInit(boolean cancelable) {
			target = null;
			setLayout(new FlowLayout());
			ta = new TextField("",35);
			ta.setEditable(false);
			add(ta);
			if (cancelable) {
				cancel = new JButton("cancel");
				cancel.addActionListener(this);
				add(cancel);
			}
			pack();
			setVisible(true);
		}
		
		public void setButtonText(String text) {
			cancel.setText(text);
		}
		
		public void removeMsgDialogListener() {target=null;}
		public void addMsgDialogListener(msg2DialogUtils mdu) {
			target = mdu;
		}
		public void setText(String s) {
			ta.setText(s);
			try{Thread.sleep(125);} catch (Exception e) {;}
		}
		public String getText() {return ta.getText();}
		
		public void destory() {
			dispose();
		}
		public boolean getCancelPressed() {return cancelPressed;}
		public void setCancelPressed(boolean b) {cancelPressed = b;}
		public void actionPerformed(ActionEvent evt) {
			if (evt.getSource() == cancel) {
				cancelPressed = true;
				if (target != null) {target.buttonClicked();}
			}
		}
	}
	
	public interface msg3DialogUtils {
		public void dialogClose();
		public void dialogMoved();
	}
	public class msg3Dialog extends positionDialog {
		private	msg3DialogUtils	target;
		private String title;
		
		public msg3Dialog(Frame parent,JPanel p,String title) {
			super(parent,title,false);
			this.title = title;
			msg3DialogInit(p);
		}
		public msg3Dialog(Frame parent,JPanel p,String title,boolean bModel) {
			super(parent,title,bModel);
			this.title = title;
			msg3DialogInit(p);
		}
		public void msg3DialogInit(JPanel p) {
			setLayout(new FlowLayout());
			add(p);
	   			  addWindowListener(new WindowAdapter() {
	   			     public void windowClosing(WindowEvent evt) {
					     if (target != null) {target.dialogClose();}
					     dispose();
	                 }
			      });
				  addComponentListener(new ComponentAdapter() {
					public void componentMoved(ComponentEvent evt) {
						if (target != null) {target.dialogMoved();}
					}
				  });
			pack();
			setVisible(true);	
		}
		public void destory() {
			dispose();
		}
		public String getTitleString() {return getTitle();}
		public void setTitleString(String s) {setTitle(s);}
		public void removeMsgDialogListener() {target=null;}
		public void addMsgDialogListener(msg3DialogUtils mdu) {
			target = mdu;
		}			
	}
	
	public class helpDialog extends JDialog {
		   private JTextArea ta;
		   
		   public helpDialog(Frame parent) {
		   		  super(parent,"Help",false);
				  setLayout(new FlowLayout(FlowLayout.CENTER));
				  ta = new JTextArea("",10,30);
				  supportFunctions.displayTextFile(exHelpFile,ta);
				  ta.setEditable(false);
				  add(ta);
	   			  addWindowListener(new WindowAdapter() {
	   			     public void windowClosing(WindowEvent evt) {
					 	helpDlg = null;
	   		            dispose();
	                 }
			      });
				  pack();
				  setVisible(true);
		   }
		   
		   public void destroy() {
		   		  dispose();
		   }
	}
	
	public class printableCanvas extends Canvas {
		public Image getCurrentCanvasImage() {
			Dimension d = getSize();
			Image i = createImage(d.width,d.height);
			Graphics2D g2d = (Graphics2D)i.getGraphics();
			paint(g2d);
			return i;
		}
		public void saveAsJPG(Rectangle rcClip,String filename) {
			   Image i = getCurrentCanvasImage();
			   if (i == null) {return;}
			   if (filename.length() == 0) {
				   filename = fileSaveDialog("","*.jpg");
					if (filename == null) {return;}
			   }
				if (!filename.endsWith(".jpg")) {filename = filename + ".jpg";}
			   displayDialog("Saved " + filename);
			   ImageExtra ie = new ImageExtra(i);
			   ie.saveImage(filename);
		}
		public void printCanvas() {
			TRACE("printCanvas called",3);
			PrinterJob pJob = PrinterJob.getPrinterJob();
			pJob.setPrintable(null,pJob.defaultPage());
			if (pJob != null) {
			   if (pJob.printDialog()) {
			   	try {
			   	   pJob.print();
			   	} catch (PrinterException e) {}
			   }
//			   pJob.end();
			}
		}
		public boolean printPageSetupOverride(Graphics2D g2d,PageFormat format,Dimension size) {
			return false;
		}
		public Graphics2D printPageSetup(Graphics g,PageFormat format,Dimension size) {
			Graphics2D g2d = (Graphics2D)g;
			
			if (printPageSetupOverride(g2d,format,size)) {return g2d;}
			g2d.translate(format.getImageableX(),format.getImageableY());
			double pageWidth = format.getImageableWidth();
			double pageHeight = format.getImageableHeight();
			if (size.width > pageWidth) {
				double f = pageWidth / size.width;
				g2d.scale(f,f);
				pageWidth /= f;
				pageHeight /= f;
			}
			if (size.height > pageHeight) {
				double f = pageHeight / size.height;
				g2d.scale(f,f);
				pageWidth /= f;
				pageHeight /= f;
			}
			g2d.translate((pageWidth-size.width)/2,(pageHeight-size.height)/2);
			g2d.drawRect(-1,-1,size.width+2,size.height+2);
			g2d.setClip(0,0,size.width,size.height);
			return g2d;
		}
	}
	
	public class Queue {
		private	Vector	quVector;
		private String	quName;

		public Queue() {
			quVector = new Vector();
			quName = "";
		}
		public Queue(String name) {
			quVector = new Vector();
			quName = name;
			TRACE("Creating a queue called "+quName,3);
		}
		public void append(Object o) {
			TRACE("appending object to queue "+quName);
			quVector.addElement(o);
		}
		public Object remove() {
			TRACE("removing object from queue "+quName);
			if(size() != 0) {
				Object o = quVector.elementAt(0);
				quVector.removeElementAt(0);
				return o;
			} else {
				return null;
			}
		}
		public int size() {
			return quVector.size();
		}
		public void empty() {
			TRACE("Emptying queue "+quName,3);
			quVector.removeAllElements();
		}
		public String getQueueName() {return quName;}
	}

	public void executeJavaScript(String filename) {
		try {
			// create a script engine manager
			ScriptEngineManager factory = new ScriptEngineManager();
			// create a JavaScript engine
			ScriptEngine engine = factory.getEngineByName("JavaScript");
			// evaluate JavaScript code from String
			engine.eval("print('Hello, World')");
		} catch (Exception e) {e.printStackTrace();}
	}

		public String rightString(String s,int chars) {
			if (chars < 0) {chars = 0;}
			if (chars > s.length()) {chars = s.length();}
			return s.substring(s.length() - chars);
		}
		public String leftString(String s,int chars) {
			if (chars < 0) {chars = 0;}
			if (chars > s.length()) {chars = s.length();}
			return s.substring(0,chars);
		}
		public String midString(String s,int start,int end) {
			if (start < 0) {start = 0;}
			if (end < 0) {end = 0;}
			if (start > s.length()) {start = s.length();}
			if (end > s.length()) {end = s.length();}
			return s.substring(start,end);
		}

	public String[] regMatchGroups(String line,String pat) {
		ehsRegExp p = new ehsRegExp();
		p.regExpMatch(line,pat);
		return p.getFoundGroupsArray();
	}
	public class ehsRegExp {
		private Vector foundStrings = new Vector();
		private Vector foundGroups = new Vector();

		public  String getFoundStringsCSV() {
			if (foundStrings.size() == 0) {return "";}
			String tmp = (String)foundStrings.elementAt(0);
			for (int i=1;i<foundStrings.size();i++) {
				tmp = tmp + "," + (String)foundStrings.elementAt(i);
			}
			return tmp;
		}
		public  String getFoundGroupsCSV() {
			if (foundGroups.size() == 0) {return "";}
			String tmp = (String)foundGroups.elementAt(0);
			for (int i=1;i<foundGroups.size();i++) {
				tmp = tmp + "," + (String)foundGroups.elementAt(i);
			}
			return tmp;
		}
		public Vector getFoundStrings() {return foundStrings;}
		public Vector getFoundGroups() {return foundGroups;}
		public String[] getFoundStringsArray() {
			String[] results = new String[foundStrings.size()];
			foundStrings.copyInto(results);
			return results;
		}
		public String[] getFoundGroupsArray() {
			String[] results = new String[foundGroups.size()];
			foundGroups.copyInto(results);
			return results;
		}
		public boolean regExpMatch(String token,String pattern) {
			boolean bFound = false;
			Pattern p = Pattern.compile(pattern);
			Matcher m = p.matcher(token);
			foundStrings.removeAllElements();
			foundGroups.removeAllElements();
			while (m.find()) {
				bFound = true;
				String tmp = m.group();
				if (tmp != null) {
					tmp = tmp.trim();
					foundStrings.addElement(tmp); // is the same as the line below	
//					foundStrings.addElement(token.substring(m.start(), m.end()));
				} else {
					TRACE("Main string is null",4);
				}
				// group zero denotes the entire pattern by convention. It is not included in this count
				for (int i=1;i<=m.groupCount();i++) {
					String tmp1 = m.group(i);
					if(tmp1 != null) {
						tmp1 = tmp1.trim();
						foundGroups.addElement(tmp1);
					} else {
						TRACE("Group string is null",4);
					}
				}
			}
			
			return bFound;
		}
	}

	public symType symTypeFromString(String s) {
		for (symType st : symType.values()) {
			if (s.equals(st.getDescription())) {return st;}
		}
		return symType.NONE;
	}
	public symClass symClassFromString(String s) {
		for (symClass st : symClass.values()) {
			if (s.equals(st.getDescription())) {return st;}
		}
		return symClass.NONE;
	}
	public enum symType {NONE("None"),LABEL("Label"),ARCH("Arch"),SIGNAL("Signal"),ENTITY("Entity"),PROCESS("Process"),PROCEDURE("Procedure"),PACKAGE("Package"),COMPONENT("Component"),COMPONENTID("ComponentID"),INTERNAL("Internal"),FILE("File"),CONSTANT("Constant"),FUNCTION("Function"),VARIABLE("Variable"),PARAMETER("Parameter"),TYPE("Type"),CLASS("Class"),INTERFACE("Interface"),ENUM("Enum"),CLASSINTERFACEENUM("ClassInterfaceEnum"),TEMPLATE("Template"),TEMPLATETYPE("TemplateType"),NEWDATATYPE("NewDataType");
		
		private final String description;
		symType(String description) {
			this.description = description;
		}
		public String getDescription() {return description;}
	}
	public enum symClass {NONE("None"),GLOBAL("Global"),BULITIN("Builtin"),LIBRARY("Library"),CONTAINER("Container"),APPLICATION("Application");
		
		private final String description;
		symClass(String description) {
			this.description = description;
		}
		public String getDescription() {return description;}
	}
	public int indexOf(String[] values,String value) {
		for (int i=0;i<values.length;i++) {
			if (value.equals(values[i])) {return i;}
		}
		
		return -1;
	}
	public class compilerSymbol {
		private String name = "";
		private String value = "";
		private String scopeID = "";
		private	String subScope = "";
		private symType type = symType.NONE;
		private symClass sclass = symClass.NONE;
		private int lowerBound = 0;
		private int upperBound = 0;
		private int lowerRange = 0;
		private int upperRange = 0;
		private int extra = 0;
		private	int code = 0;
		private String subType = "";
		private String stringLowerRange = "";
		private String stringUpperRange = "";
		private boolean bEnum = false;
		private boolean bArray = false;
		private boolean bDynamic = false;
		private boolean bForwardDeclFlag = false;
		
		public boolean getForwardDecl() {return bForwardDeclFlag;}
		public void setForwardDecl(boolean b) {bForwardDeclFlag = b;}
		public void setDynamic(boolean b) {
			bDynamic = b;
		}
		public boolean isDynamic() {return bDynamic;}
		public int getEnumCount() {
			String[] vals = getEnumValues();
			if (vals != null) {return vals.length;}
			
			return 0;
		}
		public int getEnumIndex(String s) {
			String[] vals = getEnumValues();
			for (int i=0;i<vals.length;i++) {
				if (s.equals(vals[i])) {return i;}
			}
			
			return -1;
		}
		public String getEnumValue(int index) {
			String[] vals = getEnumValues();
			if (index >= vals.length) {return "";}
			return vals[index];
		}
		public String[] getEnumValues() {
			if (getEnum() == true) {
				Vector v = supportFunctions.splitIntoTokens(getSymbolValue(),"#");
				String[] values = new String[v.size()];
				v.copyInto(values);
				return values;
			}
			
			return null;
		}
		public String[] getEnumSlice(String start,String end) {
			String[] enumValues = getEnumValues();
			int startIndex = indexOf(enumValues,start);
			int endIndex = indexOf(enumValues,end);
			if (startIndex == -1 || endIndex == -1) {
				String[] enumSliceValues = new String[0];
				return enumSliceValues;
			}
			String[] enumSliceValues = new String[Math.abs(endIndex - startIndex)];
			if (endIndex > startIndex) {
				for (int i=startIndex,j=0;i<=endIndex;i++,j++) {
					enumSliceValues[j] = enumValues[i];
				}
			} else {
				for (int i=startIndex,j=0;i>=endIndex;i--,j++) {
					enumSliceValues[j] = enumValues[i];
				}
			}
			
			return enumSliceValues;
		}
		public void setEnum(boolean b) {bEnum = b;}
		public boolean getEnum() {return bEnum;}
		public String getSubType() {return subType;}
		public void setSubType(String s) {subType = s;}
		public compilerSymbol(String scope,String subScope,String name,String value,symType type,symClass sclass) {
			this.scopeID = scope;
			this.subScope = subScope;
			this.name = name;
			this.value = value;
			this.type = type;
			this.sclass = sclass;
		}
		public void setCode(int i) {code = i;}
		public int getCode() {return code;}
		public void setExtra(int i) {extra = i;}
		public int getExtra() {return extra;}
		public void setScope(String s) {scopeID = s;}
		public String getScope() {return scopeID;}
		public void setSubScope(String s) {subScope = s;}
		public String getSubScope() {return subScope;}
		public void setRanges(int low,int high) {setLowerRange(low);setUpperRange(high);}
		public void setUpperRange(int i) {upperRange = i;}
		public int getUpperRange() {return upperRange;}
		public void setLowerRange(int i) {upperRange = i;}
		public int getLowerRange() {return lowerRange;}
		public void setBounds(int low,int high) {setLowerBound(low);setUpperBound(high);}
		public void setUpperBound(int i) {upperBound = i;}
		public int getUpperBound() {return upperBound;}
		public void setLowerBound(int i) {upperBound = i;}
		public int getLowerBound() {return lowerBound;}
		public void setStringUpperRange(String s) {stringUpperRange = s;}
		public String getStringUpperRange() {return stringUpperRange;}
		public void setStringLowerRange(String s) {stringLowerRange = s;}
		public String getStringLowerRange() {return stringLowerRange;}
		public void setSymbolValue(String s) {value=s;}
		public String getSymbolValue() {return value;}
		public String getSymbolName() {return name;}
		public symType getSymbolType() {return type;}
		public symClass getSymbolClass() {return sclass;}
		public void setSymbolClass(symClass s) {sclass=s;}
		public void setSymbolType(symType s) {type=s;}
		public boolean isConstant() {if (type == symType.CONSTANT) {return true;} else {return false;}}
		public int getHighestBound() {if (getUpperBound() > getLowerBound()) {return getUpperBound();} else {return getLowerBound();}}
		public int getLowestBound() {if (getUpperBound() < getLowerBound()) {return getUpperBound();} else {return getLowerBound();}}
		public boolean isArray() {return bArray;}
		public void setArray(boolean b) {bArray = b;}
		public boolean hasRange() {if (getUpperRange() != getLowerRange()) {return true;} else {return false;}}
		public int size() {return length();}
		public int length() {return Math.abs(getUpperBound() - getLowerBound());}
		public boolean isAscending() {
			if ((getUpperBound() > getLowerBound()) || (getUpperRange() > getLowerRange())) {return true;}
			return false;
		}
		public String dumpSymbol() {
			String extra = ",Enum:"+valueOf(bEnum)+",Array:"+valueOf(bArray)+",Dynamic:"+valueOf(bDynamic);
			if (isArray()) {extra = " (Array low:"+String.valueOf(getLowerBound())+" High:"+String.valueOf(getUpperBound())+")";}
			if (hasRange()) {extra = extra + " (Range low:"+String.valueOf(getLowerRange())+" High:"+String.valueOf(getUpperRange())+")";}
			return "Entity:" + getScope() + ",SubEntity:" + getSubScope() + ",Name:" + getSymbolName() + ",Value:" + getSymbolValue() + ",Type:" + getSymbolType().getDescription() + ",Class:" + getSymbolClass().getDescription() + extra;			
		}
	}
	public class compositeCompilerSymbol {
		private	String	compositeid = "";
		private Vector 	items = new Vector();
		
		public compositeCompilerSymbol(String id) {
			compositeid = id;
		}
		public Vector getItems() {return items;}
		public void addSymbol(compilerSymbol item) {items.addElement(item);}
		public void removeSymbol(compilerSymbol item) {items.removeElement(item);}
		public void removeAll() {items.removeAllElements();}
		public void setCompositeID(String id) {compositeid = id;}
		public String getCompositeID() {return compositeid;}
		public String dumpSymbol() {
			String dump = "";
			for (int i=0;i<items.size();i++) {
				compilerSymbol s = (compilerSymbol)items.elementAt(i);
				dump = dump + "(" + compositeid + ") " + s.dumpSymbol() + "\n";
			}
			return dump;
		}
	}
	public void symbolNodeClicked(String symbolScoe,String symbolSubScope,String symbolName,String symbolValue) {
	}
	public class compilerSymbolTable implements TreeSelectionListener,TextListener {
		private Vector symbols = new Vector();
		private	Vector complexSymbols = new Vector();
		private msg3Dialog symbolDialog = null;
		private	JTree symbolTree = null;
		private boolean bEditValue = false;
		private TextField valueTF = null;
		private compilerSymbol cs = null;
		private boolean bUseForwardDecls = false;
		
		public void setUseForwardDecls(boolean b) {bUseForwardDecls = b;}
		public boolean getUseForwardDecls() {return bUseForwardDecls;}
		public void setEditValue(boolean b) {bEditValue = b;}
		public Vector getAllSymbols() {return symbols;}
		public void mergeSymbolTable(compilerSymbolTable cst) {
			Vector v = cst.getAllSymbols();
			for (int i=0;i<v.size();i++) {
				compilerSymbol symbol = (compilerSymbol)v.elementAt(i);	
				addSymbol(symbol.getScope(),symbol.getSubScope(),symbol.getSymbolName(),symbol.getSymbolValue(),symbol.getSymbolType(),symbol.getSymbolClass());
			}
		}
		public void textValueChanged(TextEvent evt) {
			if (cs != null) {
				cs.setSymbolValue(valueTF.getText());
			}
		}
		public void valueChanged(TreeSelectionEvent evt) {
			Object selection = symbolTree.getLastSelectedPathComponent();
			if (selection != null) {
				DefaultMutableTreeNode node = (DefaultMutableTreeNode)selection;
				symbolTreeNodeClicked(symbolTree,node);
			}
		}
		public void symbolTreeNodeClicked(JTree tree,DefaultMutableTreeNode node) {
			if (node.isLeaf()) {
				DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode)node.getParent();
				if (node.getRoot() != parentNode) {
					String symbolType = parentNode.toString();
					// node text is in the form scope:sub scope:symbol name
					Vector v1 = supportFunctions.splitIntoTokens(node.toString(),":");
					String symbolScope = (String)v1.elementAt(0);
					String symbolSubScope = (String)v1.elementAt(1);
					String symbolName = (String)v1.elementAt(2);
					TRACE("symbolTreeNodeClicked:scope:"+symbolScope+":subscope:"+symbolSubScope+":name:"+symbolName,4);
					//displayDialog("symbolTreeNodeClicked:scope:"+symbolScope+":subscope:"+symbolSubScope+":name:"+symbolName);
					String symbolValue = "";
					symType type = symTypeFromString(symbolType);
					//Vector v = hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getSymbolTable().getSymbols(type);
					Vector v = getSymbols(type); // GDB 06/02/2014
					TRACE("symbolTreeNodeClicked:number of type symbols "+String.valueOf(v.size()),4);
					//displayDialog("symbolTreeNodeClicked:number of type symbols "+String.valueOf(v.size()));
					cs = null;
					for (int i=0;i<v.size();i++) {
						cs = (compilerSymbol)v.elementAt(i);
						//displayDialog("symbolTreeNodeClicked:next symbol name:"+cs.getSymbolName());
						if (symbolName.equals(cs.getSymbolName())) {
							//displayDialog("symbolTreeNodeClicked:got symbol value:"+cs.getSymbolValue());
							symbolValue = cs.getSymbolValue();
							break;
						}
					}
					TRACE("symbolTreeNodeClicked:Clicked symbol:Type:"+symbolType+":Name:"+symbolName+":Value:"+symbolValue,4);
					valueTF.setText(symbolValue);
					symbolNodeClicked(symbolScope,symbolSubScope,symbolName,symbolValue);
				} else {
					TRACE("symbolTreeNodeClicked:Symbol type got no entries",4);
					valueTF.setText("Not Defined");
				}
			} else {
				TRACE("symbolTreeNodeClicked:Not clicked on a leaf node",4);
				valueTF.setText("Not Defined");
			}
		}
		public JTree buildSymbolTree(String rootText) {
			DefaultMutableTreeNode root = new DefaultMutableTreeNode(rootText);
			symbolTree = new JTree(root);
			for (symType s : symType.values()) {
				if (s == symType.NONE) {continue;}
				DefaultMutableTreeNode child = new DefaultMutableTreeNode(s.getDescription());
				root.add(child);
				Vector v = getSymbols(s);
				for (int ii=0;ii<v.size();ii++) {
					compilerSymbol cs1 = (compilerSymbol)v.elementAt(ii);
					child.add(new DefaultMutableTreeNode(cs1.getScope() + ":" + cs1.getSubScope() + ":" + cs1.getSymbolName()));
				}
			}
			
			symbolTree.expandRow(0);
			return symbolTree;
		}
		public msg3Dialog createSymbolDialog(String title,String msg) {
			if (symbolDialog != null) {destroySymbolDialog();}
			symbolTree = buildSymbolTree(systemUserReg.getAppName());
			symbolTree.addTreeSelectionListener(this);
			TreeSelectionModel m = symbolTree.getSelectionModel();
			m.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
			symbolTree.setSelectionModel(m);
			JScrollPane spane = new JScrollPane(symbolTree);
			JPanel symbolPanel = new JPanel();
			symbolPanel.setLayout(new BoxLayout(symbolPanel,BoxLayout.Y_AXIS));			
			cs = null;
			valueTF = new TextField(20);
			valueTF.addTextListener(this);
			valueTF.setEnabled(bEditValue);
			symbolPanel.add(valueTF);
			symbolPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			symbolPanel.add(spane);
			symbolPanel.add(new JLabel(msg,JLabel.CENTER));
			symbolPanel.setSize(250,275);
			symbolDialog = displayPanelDialog(symbolPanel,title);
			return symbolDialog;
		}
		public void destroySymbolDialog() {
			if (symbolDialog != null) {
				symbolDialog.dispose();
				symbolDialog.destory();
				symbolDialog = null;
			}
		}
		
		public void removeAllSymbols() {
			symbols.removeAllElements();
			complexSymbols.removeAllElements();
		}
		public void unresolvedForwardDecl(compilerSymbol cs) {
			cs.setForwardDecl(false);
		}
		public void unresolvedForwardDecls() {
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (getUseForwardDecls() == true) {
					unresolvedForwardDecl(cs);
				}
			}
		}
		public compilerSymbol checkForwardDecls(String scope,String subScope,String name,symType type,symClass sclass) {
			if (getUseForwardDecls() == true) {
				compilerSymbol cs = addSymbol(scope,subScope,name,"",type,sclass);
				cs.setForwardDecl(true);
				TRACE("checkForwardDecls:Defined forward symbol decl:" + name,4);
				displayDialog("checkForwardDecls:Defined forward symbol decl:" + name);
				return cs;
			}
			return (compilerSymbol)null;
		}
		public compilerSymbol findSymbol(String scope,String subScope,String name) {
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope.equals(symbol.getScope()) && name.equals(symbol.getSymbolName())) {return symbol;}
			}
			return checkForwardDecls(scope,subScope,name,symType.NONE,symClass.NONE);
		}
		public compilerSymbol findSymbol(String scope,String subScope,String name,symType type,symClass sclass) {
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope.equals(symbol.getScope()) && name.equals(symbol.getSymbolName()) && type == symbol.getSymbolType() && sclass == symbol.getSymbolClass()) {return symbol;}
			}
			return checkForwardDecls(scope,subScope,name,type,sclass);
		}
		public compilerSymbol findSymbol1(int code,String scope,String subScope,String name,symType type) {
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope.equals(symbol.getScope()) && subScope.equals(symbol.getSubScope()) && name.equals(symbol.getSymbolName()) && type == symbol.getSymbolType() && code == symbol.getCode()) {return symbol;}
			}
			return checkForwardDecls(scope,subScope,name,type,symClass.NONE);
		}
		public compilerSymbol findSymbol(String scope,String subScope,String name,symType type) {
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope.equals(symbol.getScope()) && name.equals(symbol.getSymbolName()) && type == symbol.getSymbolType()) {return symbol;}
			}
			return checkForwardDecls(scope,subScope,name,type,symClass.NONE);
		}
		public compositeCompilerSymbol findComplexSymbol(String name) {
			for (int i=0;i<complexSymbols.size();i++) {
				compositeCompilerSymbol symbol = (compositeCompilerSymbol)symbols.elementAt(i);
				if (name.equals(symbol.getCompositeID())) {return symbol;}
			}
			return (compositeCompilerSymbol)null;
		}
		public Vector getSymbols(String scope) {
			Vector v = new Vector();
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope == symbol.getScope()) {v.addElement(symbol);}
			}
			return v;
		}
		public Vector getSymbols(String scope,String subScope) {
			Vector v = new Vector();
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope == symbol.getScope() && subScope == symbol.getSubScope()) {v.addElement(symbol);}
			}
			return v;
		}
		public Vector getSymbols(symType type) {
			Vector v = new Vector();
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (type == symbol.getSymbolType()) {v.addElement(symbol);}
			}
			return v;
		}
		public Vector getSymbols(String scope,symType type) {
			Vector v = new Vector();
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope == symbol.getScope() && type == symbol.getSymbolType()) {v.addElement(symbol);}
			}
			return v;
		}
		public Vector getSymbols(String scope,symClass c) {
			Vector v = new Vector();
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope == symbol.getScope() && c == symbol.getSymbolClass()) {v.addElement(symbol);}
			}
			return v;
		}
		public Vector getSymbols(String scope,String subScope,symType type) {
			Vector v = new Vector();
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope == symbol.getScope() && subScope == symbol.getSubScope() && type == symbol.getSymbolType()) {v.addElement(symbol);}
			}
			return v;
		}
		public Vector getSymbols(String scope,String subScope,symClass c) {
			Vector v = new Vector();
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol symbol = (compilerSymbol)symbols.elementAt(i);
				if (scope == symbol.getScope() && subScope == symbol.getSubScope() && c == symbol.getSymbolClass()) {v.addElement(symbol);}
			}
			return v;
		}
		public compilerSymbol addSymbol(int code,String scope,String subScope,String name,String value,symType type,symClass sclass) {
			compilerSymbol symbol = new compilerSymbol(scope,subScope,name,value,type,sclass);
			symbol.setCode(code);
			symbols.addElement(symbol);
			return symbol;
		}
		public compilerSymbol addSymbol(String scope,String subScope,String name,String value,symType type,symClass sclass) {
			return addSymbol(scope,subScope,name,value,type,sclass,"");
		}
		public compilerSymbol addSymbol(String scope,String subScope,String name,String value,symType type,symClass sclass,String complexSym) {
			compilerSymbol cs = findSymbol(scope,subScope,name,type);
			if (cs != null) {
				if (getUseForwardDecls() == true) {
					cs.setForwardDecl(false);
					TRACE("addSymbol:Resolving forward symbol decl:" + name,4);
					displayDialog("addSymbol:Resolving forward symbol decl:" + name);
					return cs;
				} else {
					TRACE("addSymbol:Symbol found " + name + ": NO ForwardDecl",4);
				}
			}
			compilerSymbol symbol = new compilerSymbol(scope,subScope,name,value,type,sclass);
			if (complexSym.length() != 0) {
				  compositeCompilerSymbol ci = findComplexSymbol(complexSym);
				  if (ci == null) {
					  ci = new compositeCompilerSymbol(complexSym);
					  complexSymbols.addElement(ci);
				  }
				  ci.addSymbol(symbol);
			} else {
				symbols.addElement(symbol);
			}
			return symbol;
		}
		public void deleteSymbol(String scope,String subScope,String name,symType type) {
			compilerSymbol symbol = findSymbol(scope,subScope,name,type);
			if (symbol != null) {
				symbols.removeElement(symbol);
			}
		}
		public String dumpSymbols() {
			String dump = "";
			for (int i=0;i<symbols.size();i++) {
				compilerSymbol s = (compilerSymbol)symbols.elementAt(i);
				dump = dump + s.dumpSymbol();
			}
			for (int i=0;i<complexSymbols.size();i++) {
				compositeCompilerSymbol s = (compositeCompilerSymbol)complexSymbols.elementAt(i);
				dump = dump + s.dumpSymbol();
			}
			return dump;
		}
	}
	public class compilerTokens {
		public Vector reservedWords = new Vector();
		public Vector types = new Vector();
		
		public String getKeywordORedString() {
			if (reservedWords.size() == 0) {return "";}
			String tmp = (String)reservedWords.elementAt(0);
			for (int i=1;i<reservedWords.size();i++) {
				tmp = tmp + "|" + (String)reservedWords.elementAt(i);
			}
			
			return tmp;
		}
		public String getTypeORedString() {
			if (types.size() == 0) {return "";}
			String tmp = (String)types.elementAt(0);
			for (int i=1;i<types.size();i++) {
				tmp = tmp + "|" + (String)types.elementAt(i);
			}
			
			return tmp;
		}
		public Vector tokenizeLine(String line) {
			return tokenizeLine(line,true);
		}
		public Vector tokenizeLine(String line,boolean bKeywords) {
			Vector tokens = new Vector();
			line = preProcessLine(line,bKeywords);
			tokens = supportFunctions.splitIntoTokensIncStringLit(line," ");
			return tokens;
		}
		public String preProcessLine(String line,boolean bKeywords) {
			TRACE("preProcessLine:compilerTokens",4);
			return line;
		}
		public Vector getReservedWords() {return reservedWords;}
		public Vector getTypes() {return types;}
		public String getStringOfTypes() {
			if (types.size() == 0) {return "";}
			String tmp = (String)types.elementAt(0);
			for (int i=1;i<types.size();i++) {
				tmp = tmp + "," + (String)types.elementAt(i);
			}
			
			return tmp;
		}
		public void setReservedWords(String words) {
			reservedWords.removeAllElements();
			reservedWords = supportFunctions.splitIntoTokens(words,",");
		}
		public void setTypes(String words) {
			types.removeAllElements();
			types = supportFunctions.splitIntoTokens(words,",");
		}
		public boolean isTemplateType(String token) {
			ehsRegExp p1 = new ehsRegExp();
			if (p1.regExpMatch(token,"<.*?>")) {return true;}
			return false;
		}
		public boolean isClassAContainer(String className) {
//			try {
//				Class c = Class.forName(className);
//				while (c.getSuperclass() != null) {
//					className = c.getName();
//					TRACE("Super class: " + className,4);
//					int pos = className.lastIndexOf('.');
//					if (pos != -1) {className = className.substring(pos + 1);}
//					if (className.equals("AbstractCollection")) {
//						TRACE("Class " + className + " is a container",4);
//						return true;
//					}
//				}
//			} catch (Exception e) {e.printStackTrace();}
			
			ehsFile f = new ehsFile(""+dataRelativePath+"/" + appDirectory + "/containerclasses.dat");
			String  s = f.loadFile();
			Vector v = supportFunctions.splitIntoTokens(s,",");
			for (int i=0;i<v.size();i++) {
				String tmp = (String)v.elementAt(i);
				if (tmp.equals(className)) {TRACE("Class " + className + " is a container",4);return true;}
			}

			TRACE("Class " + className + " is not a container",4);
			return false;
		}
		public boolean isReserved(String token) {
			return reservedWords.contains(token);
		}
		public boolean isNumeric(String token) {
			try {
				Integer.parseInt(token);
			} catch (Exception e) {return false;}
			return true;
		}	
		public boolean isString(String token) {
			if ((token.charAt(0) == '\"') && token.charAt(token.length()-1) == '\"')  {return true;}
			
			return false;
		}
		public boolean isType(String token) {
			// remove any [...] to get base type
			int index = token.indexOf("[");
			String tmp = token;
			if (index != -1) {
				tmp = token.substring(0,index);
			}
			return types.contains(tmp);
		}
		public boolean isComment(String token) {
			return false;
		}
		public boolean isSyntax(String token) {
			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(token,"\\p{Punct}");
			String[] tmp;
			tmp = p.getFoundStringsArray();
			if (tmp.length == 1) {return true;}
			return false;
		}
		public String basePreProcessLine(String line,boolean bKeywords) {
			TRACE("basePreProcessLine:compilerTokens",4);
				
			ehsRegExp p = new ehsRegExp();
			
			// save all the string literals in the input line
			p.regExpMatch(line,"(\".*?\")");
			String[] strings = p.getFoundStringsArray();			
					
			// put a space character ether side of any syntax character 
			p.regExpMatch(line,"[\\p{Punct}&&[^_'\\[\\]\"]]"); // GDB 18/05/2014
			String[] tokens = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				line = line.replace((String)tokens[i]," " + (String)tokens[i] + " ");
			}
		
			// remove space between '-' characters and numbers where there is a symbol before the '-' character or its
			// at the beginning of the line. (i.e. the unary operator)
			p.regExpMatch(line,"^-\\s(\\d+)");			
			tokens = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				String tmp = (String)tokens[i].replace(" ","");
				line = line.replace((String)tokens[i],tmp);
			}
			p.regExpMatch(line,"\\p{Punct}\\s-\\s(\\d+)");			
			tokens = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				String tmp = (String)tokens[i].replace("- ","-");
				line = line.replace((String)tokens[i],tmp);
			}

			// replace tabs with just one space
			line = line.replaceAll("\\t{2,}"," ");

			// replace n spaces with just one space
			line = line.replaceAll("\\s{2,}"," ");
			
			// replace double keywords with no space e.g. port map becomes portmap
			if (bKeywords) {
				for (int i=0;i<reservedWords.size();i++) {
					String tmp = (String)reservedWords.elementAt(i);
					line = line.replaceAll("(?i)" + tmp,tmp); // make all keywords lower case
					if (tmp.indexOf(' ') != -1) {
						line = line.replace(tmp,tmp.replace(" ","")); // remove space between double keywords
					}
				}
			}

			//line = line.replaceAll(" . ","."); // GDB 190714

			// replace any string literals in the input line that we have altered by any of the reg exps above
			p.regExpMatch(line,"(\".*?\")");			
			tokens = p.getFoundStringsArray();
			for (int i=0;i<strings.length;i++) {
				TRACE("SL:" + (String)tokens[i] + " with " + (String)strings[i],4);
				line = line.replace((String)tokens[i],(String)strings[i]);
			}
			
			// remove any whitespace at start and end of line
			line = line.trim();

			return line;
		}
		String processOperatorStrings(String line) {
			String[] ops = {"cat","and","or","xor","nand","nor","xnor","sll","srl","sla","sra","rol","ror"};
			
			for (int i=0;i<ops.length;i++) {
				String[] groups = regMatchGroups(line,"((\\w+)\\s"+ops[i]+"\\s(\\w+))");
				if (groups.length > 0) {
					line = line.replaceAll(groups[0],"op_"+ops[i]+"("+groups[1]+","+groups[2]+")");
				}
			}
			return line;
		}
		String processNumberStrings(String line) {
			ehsRegExp p = new ehsRegExp();

			// replace hex strings with their decimal equivalents
			p.regExpMatch(line,"(X\"[0-9a-f]+\")");
			String[] tokens = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				String tmp = tokens[i];
				int number = 0;
				try {
					number = Integer.parseInt(tmp.substring(1,tmp.length()-1),16);
				} catch (Exception e) {;}
				line = line.replace(tokens[i],Integer.toString(number));
				return line;
			}

			// replace octal strings with their decimal equivalents
			p.regExpMatch(line,"(O\"[0-7]+\")");
			tokens = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				String tmp = tokens[i];
				int number = 0;
				try {
					number = Integer.parseInt(tmp.substring(1,tmp.length()-1),8);
				} catch (Exception e) {;}
				line = line.replace(tokens[i],Integer.toString(number));
				return line;
			}

			// replace binary strings with their decimal equivalents
			p.regExpMatch(line,"(B*\"[0|1]+\")");
			tokens = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				String tmp = tokens[i];
				int number = 0;
				try {
					number = Integer.parseInt(tmp.substring(1,tmp.length()-1),2);
				} catch (Exception e) {;}
				line = line.replace(tokens[i],Integer.toString(number));
			}

			p.regExpMatch(line,"(([0-9a-fA-F_]+)#([0-9a-fA-F_]+)#E*(\\d*))");
			tokens = p.getFoundStringsArray();
			if (tokens.length > 0) {
				tokens[1] = tokens[1].replaceAll("_","");
				tokens[2] = tokens[2].replaceAll("_","");
				int num = Integer.parseInt(tokens[2],Integer.parseInt(tokens[1])); // num=tokens[2] in base tokens[1]
				int eNum = 0;
				if (tokens.length > 3) {eNum = Integer.parseInt(tokens[3]);}
				if (eNum != 0) {
					num = num * (eNum * Integer.parseInt(tokens[1]));
				}
				line = line.replaceAll(tokens[0],String.valueOf(num));
			}
			
			return line;
		}		
	}
	public class VerilogcompilerTokens extends compilerTokens {
		public String preProcessLine(String line,boolean bKeywords) {
			TRACE("preProcessLine:VerilogcompilerTokens",4);
			line = processNumberStrings(line);
			line = processOperatorStrings(line);
			line = basePreProcessLine(line,bKeywords);
			line = processNoNameProcesses(line);
			line = processAttributes(line); // has to be called after basePreProcessLine(...)
			
			// remove space between double syntax operators
			line = line.replaceAll("< =","<=");
			line = line.replaceAll("> =",">=");
			line = line.replaceAll(": =",":=");
			line = line.replaceAll("! =","!=");
			line = line.replaceAll("/ =","/=");
			//line = line.replaceAll("* *","**");

			// remove any spaces in time ids
			line = line.replaceAll(" ns ","ns ");
			line = line.replaceAll(" us ","us ");
			line = line.replaceAll(" ms ","ms ");
			line = line.replaceAll(" secs ","secs ");
			
			return line;
		}
		public String processNoNameProcesses(String line) {
			return line;
		}
		public String processAttributes(String line) {
			TRACE("processAttributes:VerilogcompilerTokens:" + line,4);
			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(line,"([0-9a-zA-Z_]+?)'([0-9a-zA-Z_]+?)\\s");
			String[] tokens = p.getFoundStringsArray();
			Vector v5 = supportFunctions.splitIntoTokens(VerilogAttribs,",");
			for (int j=0;j<tokens.length;j++) {
				//displayDialog("PA0: " + tokens[j]); // debug line
				Vector v4 = supportFunctions.splitIntoTokens(tokens[j],"\'");
				String attrib = (String)v4.elementAt(1);
				attrib = attrib.trim();
				boolean found = false;
				for (int i=0;i<v5.size();i=i+2) {
				//displayDialog("PA1: " + attrib + "," + (String)v5.elementAt(i)); // debug line
					if (attrib.equals((String)v5.elementAt(i))) {
						String transText = (String)v5.elementAt(i+1);
						//displayDialog("PA2: " + transText);
						transText = transText.replaceAll("\\*1",",");
						transText = transText.replaceAll("\\*2",(String)v4.elementAt(0));
						transText = transText.replaceAll("\\*3",hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName());
						transText = transText.replaceAll("\\*4",hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).currentScope());				
						//displayDialog("PA3: " + transText);
						line = line.replaceAll(tokens[j]," " + transText + " ");
						//displayDialog("PA4: " + line);
						found = true;
						break;
					}
				}
				if (!found) {
					displayDialog("Attribute " + attrib + " not supported.");
				}
			}
			return line;
		}
	}
	public class VHDLcompilerTokens extends compilerTokens {
		private	String		noNameProcesses = "";
		
		public String preProcessLine(String line,boolean bKeywords) {
			TRACE("preProcessLine:VHDLcompilerTokens",4);
			line = line.replaceAll(" postponed "," ");
			line = processNumberStrings(line);
			line = processOperatorStrings(line);
			line = preProcessAttributes(line);
			line = basePreProcessLine(line,bKeywords);
			line = processNoNameProcesses(line);
			line = processAttributes(line); // has to be called after basePreProcessLine(...)
			line = processExtras(line);
			
			// remove space between double syntax operators
			line = line.replaceAll(": =",":=");
			line = line.replaceAll("< =","<=");
			line = line.replaceAll("> =",">=");
			line = line.replaceAll("! =","!=");
			//line = line.replaceAll("* *","**");
			line = line.replaceAll("/ =","/=");
			
			// remove any spaces in time ids
			line = line.replaceAll(" ns ","ns ");
			line = line.replaceAll(" us ","us ");
			line = line.replaceAll(" ms ","ms ");
			line = line.replaceAll(" secs ","secs ");
			
			return line;
		}
		public String processExtras(String line) {
			if (line.indexOf(" wait ") != -1) { // has to be called after basePreProcessLine(...)
				line = line.replaceAll(" , ",","); // so a list of sensitivity signals appear as one token
			}
			
			line = line.replaceAll("now","getSimTime()");
			line = line.replaceAll("NOW","getSimTime()");
			
			return line;
		}
		public String processNoNameProcesses(String line) {
			TRACE("processNoNameProcesses:entered:line:"+line,4);
			if (line.indexOf("endprocess") != -1) {
				line = line.replaceAll("endprocess ;","endprocess " + currentProcessName + " ;");
				TRACE("processNoNameProcesses:exited(endprocess):line:"+line,4);
				return line;
			}
			if (line.indexOf("process") == -1) {TRACE("processNoNameProcesses:exited(process):line:"+line,4);return line;}
			if (line.indexOf(":") == -1) {
				// no process name specified
				line = "process" + String.valueOf(noNameProcessesID++) + " : " +line;
			}
			//line = line.replaceAll(" postponed "," "); // as done before calling basePreProcessLine(...)
			line = line.replaceAll(" is "," ");
			if (line.endsWith("process")) {
				int index = line.indexOf(":");
				String pname = line.substring(0,index-1); // -1 added GDB 22/06/2014 to remove space between end of process name and the :
				if (passNumber == 2) { // only add to list on pass 2 of the compiler!!!
					if (noNameProcesses.length() != 0) {noNameProcesses = noNameProcesses + ",";}
					noNameProcesses = noNameProcesses + pname;
				}
				line = line + " ( )";
			}
			TRACE("processNoNameProcesses:exited(processed):line:"+line,4);
			return line;
		}
		public compilerSymbol getCompilerSymbol(String typeName) {
			compilerSymbol cs = hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).symbolTable.findSymbol(hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName(),hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).currentScope(),typeName,symType.SIGNAL);
			if (cs == null) {cs = hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).symbolTable.findSymbol(hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName(),hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).currentScope(),typeName,symType.VARIABLE);}
			if (cs == null) {cs = hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).symbolTable.findSymbol(hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName(),hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).currentScope(),typeName,symType.TYPE);}
			
			return cs;
		}
		public String preProcessAttributes(String line) {
			TRACE("preProcessAttributes:VHDLcompilerTokens:start:" + line,4);

			String optParam = "";
			
			line = line.replaceAll("'driving value","'drivingvalue");
			line = line.replaceAll("UNSIGNED'","");
			line = line.replaceAll("STRING'","");
			
			line = line.replaceAll("integer'high",String.valueOf(unconstrainedArrayValue));
			line = line.replaceAll("integer'low",String.valueOf(-unconstrainedArrayValue));
			line = line.replaceAll("real'high",String.valueOf(unconstrainedArrayValue));
			line = line.replaceAll("real'low",String.valueOf(-unconstrainedArrayValue));

			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(line,"(?i)(\\w+)'simple\\sname");
			String[] tokens = p.getFoundGroupsArray();
			String[] tokens1 = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				line = line.replaceAll(tokens1[i] + "'name",hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName());
			}
			p.regExpMatch(line,"(?i)(\\w+)'instance\\sname");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				line = line.replaceAll(tokens1[i] + "'instance name",hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName());
			}
			p.regExpMatch(line,"(?i)(\\w+)'path\\sname");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				line = line.replaceAll(tokens1[i] + "'path name",hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName());
			}

			p.regExpMatch(line,"(?i)(\\w+)'base'\\w+");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				compilerSymbol cs = hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).symbolTable.findSymbol(hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName(),hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).currentScope(),tokens[i],symType.TYPE);
				if (cs == null) {displayDialog("Unrecognised type (base attrib) - " + tokens[i]);}
				else {line = line.replaceAll(tokens[i]+"'base'",cs.getSymbolValue() + "'");}
			}
			p.regExpMatch(line,"(?i)((\\w+)'leftof\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				int index = Integer.parseInt(tokens[2]);
				index--;
				if (index < 0) {index = 0;}
				line = line.replaceAll(tokens[0],cs.getEnumValue(index));
			}
			}
			p.regExpMatch(line,"(?i)((\\w+)'rightof\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				int index = Integer.parseInt(tokens[2]);
				index++;
				if (index >= cs.getEnumCount()) {index--;}
				line = line.replaceAll(tokens[0],cs.getEnumValue(index));
			}
			}
			p.regExpMatch(line,"(?i)((\\w+)'pred\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				int index = Integer.parseInt(tokens[2]);
				index--;
				if (index < 0) {index = 0;}
				line = line.replaceAll(tokens[0],cs.getEnumValue(index));
			}
			}
			p.regExpMatch(line,"(?i)((\\w+)'succ\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				int index = Integer.parseInt(tokens[2]);
				index++;
				if (index >= cs.getEnumCount()) {index--;}
				line = line.replaceAll(tokens[0],cs.getEnumValue(index));
			}
			}
			p.regExpMatch(line,"(?i)((\\w+)'val\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				int index = Integer.parseInt(tokens[2]);
				if (index >= cs.getEnumCount()) {index--;}
				if (index < 0) {index = 0;}
				line = line.replaceAll(tokens[0],cs.getEnumValue(index));
			}
			}
			p.regExpMatch(line,"(?i)((\\w+)'pos\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				int index = cs.getEnumIndex(tokens[2]);
				line = line.replaceAll(tokens[0],String.valueOf(index));
			}
			}
			p.regExpMatch(line,"(?i)((\\w+)'image\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				line = line.replaceAll(tokens[0],"'"+tokens[2]+"'");
			}
			}
			p.regExpMatch(line,"(?i)((\\w+)'value\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			if (tokens.length != 0) {
			compilerSymbol cs = getCompilerSymbol(tokens[1]);
			if (cs == null) {
				displayDialog("Unrecognised " + tokens[0]);
			} else {
				line = line.replaceAll(tokens[0],tokens[2].substring(1,tokens[2].length()-1));
			}
			}
			
			p.regExpMatch(line,"(?i)((\\w+)'range\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (range attrib) - " + tokens[1]);}
				else {
					if (cs.getStringLowerRange().length() != 0) {displayDialog("range NYS for string ranges");} else
					{
						int lower = cs.getLowerRange();
						int upper = cs.getUpperRange();
						String newRange = String.valueOf(lower);
						if(lower < upper) {newRange = newRange + " to ";} else {newRange = newRange + " downto ";}
						newRange = newRange + String.valueOf(upper);
						line = line.replaceAll(tokens[0],newRange);
					}
				}
			}
				
			p.regExpMatch(line,"(?i)((\\w+)'reverse_range\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (reverse_range attrib) - " + tokens[1]);}
				else {
					if (cs.getStringLowerRange().length() != 0) {displayDialog("reverse_range NYS for string ranges");} else
					{
						int lower = cs.getUpperRange(); // remember we are swapping them around !!!
						int upper = cs.getLowerRange();
						String newRange = String.valueOf(lower);
						if(lower < upper) {newRange = newRange + " to ";} else {newRange = newRange + " downto ";}
						newRange = newRange + String.valueOf(upper);
						line = line.replaceAll(tokens[0],newRange);
					}
				}
			}
				
			p.regExpMatch(line,"(?i)((\\w+)'length\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (length attrib) - " + tokens[1]);}
				else {
					if (cs.isArray()) {
						line = line.replaceAll(tokens[0],String.valueOf(cs.size()));
					} else {
						displayDialog("length attribute only supported for arrays");
					}
				}
			}
			
			p.regExpMatch(line,"(?i)((\\w+)'ascending\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (ascending attrib) - " + tokens[1]);}
				else {
					if (cs.isAscending()) {
						line = line.replaceAll(tokens[0],"true");
					} else {
						line = line.replaceAll(tokens[0],"false");
					}
				}
			}
			
			p.regExpMatch(line,"(?i)((\\w+)'low\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (low attrib) - " + tokens[1]);}
				else {
					if (cs.isArray()) {
						line = line.replaceAll(tokens[0],String.valueOf(Math.min(cs.getLowestBound(),cs.getHighestBound())));
					} else {
						String replace = "";
						if (cs.getEnum()) {
							String[] values = cs.getEnumValues();
							if (values.length != 0) {
								Arrays.sort(values);
								replace = values[0];
							} else {replace = "0";}
						} else {displayDialog("Unrecognised part (low attrib) - " + tokens[1]);}
						line = line.replaceAll(tokens[0],replace); 
					}
				}
			}
			
			p.regExpMatch(line,"(?i)((\\w+)'high\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (high attrib) - " + tokens[1]);}
				else {
					if (cs.isArray()) {
						line = line.replaceAll(tokens[0],String.valueOf(Math.max(cs.getHighestBound(),cs.getLowestBound())));
					} else {
						String replace = "";
						if (cs.getEnum()) {
							String[] values = cs.getEnumValues();
							if (values.length != 0) {
								Arrays.sort(values);
								replace = values[values.length - 1];
							} else {replace = "0";}
						} else {displayDialog("Unrecognised part (high attrib) - " + tokens[1]);}
						line = line.replaceAll(tokens[0],replace); 
					}
				}
			}
				
			p.regExpMatch(line,"(?i)((\\w+)'left\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (left attrib) - " + tokens[1]);}
				else {
					if (cs.isArray()) {
						line = line.replaceAll(tokens[0],String.valueOf(cs.getLowerBound()));
					} else {
						String replace = "";
						if (cs.getEnum()) {
							String[] values = cs.getEnumValues();
							if (values.length != 0) {
								replace = values[0];
							} else {replace = "0";}
						} else {displayDialog("Unrecognised part (left attrib) - " + tokens[1]);}
						line = line.replaceAll(tokens[0],replace); 
					}
				}
			}
			
			p.regExpMatch(line,"(?i)((\\w+)'right\\((.*)\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			if (tokens.length != 0) {
				if (tokens.length > 2) {optParam=tokens[2];} else {optParam="";}
				compilerSymbol cs = getCompilerSymbol(tokens[1]);
				if (cs == null) {displayDialog("Unrecognised Signal, Variable or Type (right attrib) - " + tokens[1]);}
				else {
					if (cs.isArray()) {
						line = line.replaceAll(tokens[0],String.valueOf(cs.getUpperBound()));
					} else {
						String replace = "";
						if (cs.getEnum()) {
							String[] values = cs.getEnumValues();
							if (values.length != 0) {
								replace = values[values.length - 1];
							} else {replace = "0";}
						} else {displayDialog("Unrecognised part (right attrib) - " + tokens[1]);}
						line = line.replaceAll(tokens[0],replace); 
					}
				}
			}
			
			// replace any remaining instances of (...) with [...]
			p.regExpMatch(line,"(?i)\\w+'(\\w+\\(.*\\))");
			tokens = p.getFoundGroupsArray();
			tokens1 = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				String tmp = tokens[i].replaceAll("(","[");
				tmp = tmp.replaceAll(")","]");
				line = line.replaceAll(tokens[i],tmp);
			}
			
			TRACE("preProcessAttributes:VHDLcompilerTokens:end:" + line,4);
			return line;
		}
		public String processAttributes(String line) {
			TRACE("processAttributes:VHDLcompilerTokens:" + line,4);
			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(line,"([0-9a-zA-Z_]+?)'([\\[\\]0-9a-zA-Z_]+?)\\s");
			String[] tokens = p.getFoundStringsArray();
			Vector v5 = supportFunctions.splitIntoTokens(VHDLAttribs,",");
			for (int j=0;j<tokens.length;j++) {
				TRACE("PA0: " + tokens[j],4); // debug line
				Vector v4 = supportFunctions.splitIntoTokens(tokens[j],"\'");
				String attrib = (String)v4.elementAt(1);
				attrib = attrib.trim();
				String optParam = "''";
				String optParamI = "0";
				int g = attrib.indexOf("[");
				if (g != -1) {
					optParam = "'" + attrib.substring(g+1,attrib.length()-1) + "'"; // remove trailing ] character
					try {
						Integer.parseInt(attrib.substring(g+1,attrib.length()-1));
						optParamI = attrib.substring(g+1,attrib.length()-1);
					} catch (Exception e) {optParamI = "0";}
					attrib = attrib.substring(0,g-1);
				}
				boolean found = false;
				for (int i=0;i<v5.size();i=i+2) {
				TRACE("PA1: " + attrib + "," + (String)v5.elementAt(i),4); // debug line
					if (attrib.equals((String)v5.elementAt(i))) { // check if we match a VHDLAttribs (1st entry in the pair)
						String transText = (String)v5.elementAt(i+1); // trans text starts as the 2nd entry in the pair
						TRACE("PA2: " + transText,4);
						transText = transText.replaceAll("\\*1",",");
						transText = transText.replaceAll("\\*2",(String)v4.elementAt(0));
						transText = transText.replaceAll("\\*3",hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).getEntityName());
						transText = transText.replaceAll("\\*4",hdlworkbench.getCompiler(hdlworkbench.getCompilerIndex()).currentScope());				
						transText = transText.replaceAll("\\*5",optParamI);				
						transText = transText.replaceAll("\\*6",optParam);				
						TRACE("PA3: " + transText,4);
						line = line.replaceAll(tokens[j]," " + transText + " ");
						TRACE("PA4: " + line,4);
						found = true;
						break;
					}
				}
				if (!found) {
					displayDialog("Attribute " + attrib + " not supported.");
				}
			}
			return line;
		}
	}
	public class translationTableToken {
		private String text;
		private String flags;
		private String transText;
		
		public translationTableToken(String text,String transText,String flags) {
			this.text = text;
			this.flags = flags;
			this.transText = transText;
		}
		public String getText() {return text;}
		public void setText(String s) {text = s;}
		public String getFlags() {return flags;}
		public void setFlags(String s) {flags = s;}
		public String getTransText() {return transText;}
		public void setTransText(String s) {transText = s;}
	}
	public class translationTableEntry {
		private Vector tokens = new Vector();
		private String keyword;
		private String preEntryString,postEntryString;
		
		public translationTableEntry(String keyword) {
			removeAllTranslationTableTokens();
			this.keyword = keyword;
			this.preEntryString = "";
			this.postEntryString = "";
		}
		public void removeAllTranslationTableTokens() {tokens.removeAllElements();}
		public void addTranslationTableToken(translationTableToken token) 
			{tokens.addElement(token);}
		public Vector getTokens() {return tokens;}
		public String getKeyword() {return keyword;}
		public String getpostEntryString() {return postEntryString;}
		public String getpreEntryString() {return preEntryString;}
		public void setpostEntryString(String s) {postEntryString = s;}
		public void setpreEntryString(String s) {preEntryString = s;}
	}
	public class translationTable {
		private Vector entries = new Vector();
		private String translationTableName = "";
		
		public Vector getEntries() {return entries;}
		public void loadTranslationTable(String name) {
			clearTranslationTable();
			translationTableName = name;
			
			xmlDataFile ttItems = new xmlDataFile();
			if (ttItems.openXMLDataFile(supportFunctions.getPathFilenameNoExt(name),"transtable",false)) {
				org.w3c.dom.Element root = ttItems.getRootElement();
				org.w3c.dom.Document doc = ttItems.getXMLDocument();
				NodeList n = executeXPathExpr(doc,"/transtable/ttkeyword");
				for (int i=0;i<n.getLength();i++) {
					org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(i);
					String keyword = e.getAttribute("keyword");
					TRACE("loadTranslationTable:keyword:" + keyword,4);
					
					String line = keyword + ",";					
				    NodeList n1 = executeXPathExpr(doc,"/transtable/ttkeyword[@keyword='" + keyword + "']/ttentry");
				    if (n1.getLength() == 0) {
				    	displayDialog("loadTranslationTable:No child nodes for keyword " + keyword);
				    }
				    for (int i1=0 ; i1<n1.getLength() ; i1++) {	    	
				    	org.w3c.dom.Element e1 = (org.w3c.dom.Element)n1.item(i1);
						String text = e1.getAttribute("syntax");
						String transtext = e1.getAttribute("transtext");
						String flags = e1.getAttribute("flags");
						String groupid = e1.getAttribute("groupid");
						String prestring = e1.getAttribute("prestring");
						String poststring = e1.getAttribute("poststring");
						TRACE("loadTranslationTable:syntax:" + text,4);
						
						if (i1 == 0) {
							line = line + prestring + "," + poststring + ",";
						}
				    } 
				    TRACE("loadTranslationTable:line:" + line,4);
				}
			} else {
				displayDialog("loadTranslationTable:Can't load XML translation table");
			}

			ehsFile table = new ehsFile(name);
			String tmp = "";
			do {
				tmp = table.readFileLine();
				if (tmp != null) {
					processTranslationTableEntry(tmp);
				}
			} while (tmp != null);
		}
		public void processTranslationTableEntry(String entry) {
			int commentIndex = entry.indexOf("//");
			if (commentIndex != -1) {
				if (commentIndex == 0) {entry = "";} else {
					entry = entry.substring(0,commentIndex);
				}
				entry = entry.trim();
				//displayDialog("comment removal: " + entry);
			}
//			if (entry.startsWith("//") || entry.length()==0) {return;} // ignore comment and blank lines 
			if (entry.length()==0) {return;} // ignore blank lines 
			//displayDialog(entry);
			Vector v = supportFunctions.splitIntoTokens(entry,",");
			translationTableEntry tentry = new translationTableEntry((String)v.elementAt(0));	
			if (v.size() <= 3) {return;}
			String pre = (String)v.elementAt(1);
			String post = (String)v.elementAt(2);
			if (pre.equals("*")) {tentry.setpreEntryString("");} else {tentry.setpreEntryString(pre);}
			if (post.equals("*")) {tentry.setpostEntryString("");} else {tentry.setpostEntryString(post);}
			for (int i=3;i<v.size();i++) {
				//displayDialog("PTTE:"+(String)v.elementAt(i));
				Vector v1 = supportFunctions.splitIntoTokens((String)v.elementAt(i),"@@",false);
				String tokenText = (String)v1.elementAt(0);
				String transText = "";
				String tokenFlags = "";
				if (v1.size() > 1) {transText = (String)v1.elementAt(1);}
				if (v1.size() > 2) {tokenFlags = (String)v1.elementAt(2);}
//				displayDialog("PTTE:tokenText="+tokenText+" transtext="+transText+" flags="+tokenFlags);
				translationTableToken token = new translationTableToken(tokenText,transText,tokenFlags);
				tentry.addTranslationTableToken(token);
			}
			entries.addElement(tentry);
		}
		public void clearTranslationTable() {entries.removeAllElements();}
		public Vector getKeywords() {
			Vector v = new Vector();
			
			for (int i=0;i<entries.size();i++) {
				translationTableEntry entry = (translationTableEntry)entries.elementAt(i);
				v.addElement(entry.getKeyword());
			}
			
			return v;
		}
		public translationTableEntry getTranslationTableEntry(String keyword) {
			for (int i=0;i<entries.size();i++) {
				translationTableEntry entry = (translationTableEntry)entries.elementAt(i);
				if (keyword.equals(entry.getKeyword())) {return entry;}
			}
			
			return (translationTableEntry)null;
		}
		public Vector getTokens(String keyword) {
			for (int i=0;i<entries.size();i++) {
				translationTableEntry entry = (translationTableEntry)entries.elementAt(i);
				if (keyword.equals(entry.getKeyword())) {return entry.getTokens();}
			}
			displayDialog("Unrecogized keyword : " + keyword);
			return new Vector();
		}
		public Vector expandTokens(Vector v) {
			Vector v1 = new Vector();
			for (int i=0;i<v.size();i++) {
				translationTableToken token = (translationTableToken)v.elementAt(i);
				String tokenText = token.getText();
//				displayDialog("old token text:"+tokenText);
				ehsRegExp p = new ehsRegExp();
				p.regExpMatch(tokenText,"\\{.*?\\}");
				String[] tokens;
				tokens = p.getFoundStringsArray();
				if (tokens.length != 0) {
					// a line can have more then one keyword to expand
					for (int j=0;j<tokens.length;j++) {
						Vector v2 = expandTokens(getTokens(tokens[j].substring(1,tokens[j].length()-1)));
						String tmp = "";
						for (int k=0;k<v2.size();k++) {
							translationTableToken t = (translationTableToken)v2.elementAt(k);
							tmp = tmp + t.getText();
							if (k < v2.size()-1) {tmp = tmp + " ";}
						}
						tokenText = tokenText.replace(tokens[j],tmp);
//						displayDialog("new token text:"+tokenText);
					}
					token.setText(tokenText);
				}
//				displayDialog("ET:Text="+token.getText()+" transtext="+token.getTransText());
				v1.addElement(token);
			}
			return v1;
		}
	}
	
	public class scriptHelper {
		public String htmlHeader(String title) {
			return "<html><head><title>" + title + "</title></head><body>";
		}
		public String htmlFooter() {
			return "</body></html>";
		}
		public String htmlText(String text) {
			return text;
		}
	}
	
	public enum timeUnits {SECS,MILLISECS,MICROSECS,NANOSECS};
	int getMilliSeconds(int time,timeUnits timeUnit) {
		int ret = time;
		switch (timeUnit) {
		case SECS:
			ret = ret * 1000;
			break;
		case MICROSECS:
			ret = ret / 1000;
			break;
		case NANOSECS:
			ret = ret / 1000000;
			break;
		}
		return ret;
	}
		
	public class compiler {
		private boolean varPreDefined,multilineComment;
		protected String syntaxError,commentString,statmentTerminator;
		protected String startMultiLineCommentString,endMultiLineCommentString;
		protected String transTableName;
		protected translationTable transTable;
		private msg2Dialog 	msgD;
		private int passNumber;
		private int lineNumber;
		public compilerSymbolTable symbolTable = new compilerSymbolTable();
		private int errorLineNumber;
		private String exErrorMsg;
		protected scriptHelper scripthelper = new scriptHelper();
		protected String	moduleName;
		protected int 		indentionCount;
		protected Vector	extraCompileFiles = new Vector();
		public Vector extraLines = new Vector();
		protected boolean	bProcessHeaders = false;
		protected boolean	bCompileLine = false;	
		public ehsFile f = null;
		public int tmpNameID = 0;
		public Properties placeHolders = new Properties();
		private int numBlankLines,numCommentLines;
		private String sourceFileLine = "";
		
		public void updateSourceFileLine(String s) {
			sourceFileLine = s;
		}
			
		public compiler(String transTableName) {
			// new tokenizer and set reserved words in dirved class
			this.transTableName = transTableName;
			commentString = "////";
			startMultiLineCommentString = "//*";
			endMultiLineCommentString = "*//";
			statmentTerminator = ";";
			varPreDefined = true;
			multilineComment = false;
			msgD = null;
			passNumber = -1;
			lineNumber = -1;
			transTable = null;
		}
		public translationTable getTransTable() {return transTable;}
		public String currentScope() {return "";}
		public String getEntityName() {return "";}
		public String getTmpName(String prefix) {
			return prefix + "_" + "tmpName" + "_" + String.valueOf(tmpNameID++);
		}
		public void writeDirectToOutput(String line) {;}
		public ehsFile getCompilerFile() {return f;}
		public compilerSymbolTable getSymbolTable() {return symbolTable;}
		public String getstatmentTerminator() {return statmentTerminator;}
		public void setstatmentTerminator(String s) {statmentTerminator = s;}
		public boolean getCompileLine() {return bCompileLine;}
		public void setCompileLine(boolean b) {bCompileLine = b;}
		public void setPassNumber(int i) {passNumber = i;}
		public void setLineNumber(int i) {lineNumber = i;}
		public int getPassNumber() {return passNumber;}
		public int getLineNumber() {return lineNumber;}
		public void setVarPreDefined(Boolean b) {varPreDefined = b;}
		public void setCommentString(String s) {commentString = s;}
		public void setStartMultiLineCommentString(String s) {startMultiLineCommentString = s;}
		public void setEndMultiLineCommentString(String s) {endMultiLineCommentString = s;}
		public boolean getVarPreDefined() {return varPreDefined;}
		public String getCommentString() {return commentString;}
		public String getStartMultiLineCommentString() {return startMultiLineCommentString;}
		public String getEndMultiLineCommentString() {return endMultiLineCommentString;}
		public int getErrorLineNumber() {return errorLineNumber;}
		public void setErrorLineNumber(int i) {errorLineNumber = i;}
		public String getExErrorMsg() {return exErrorMsg;}
		public void setExErrorMsg(String s) {exErrorMsg = s;}
		public String getErrorString() {return syntaxError;}
		public String stripComments(String s) {
			if (s == null) {return (String)null;}
			s = s.trim();
			int ci = s.indexOf(getStartMultiLineCommentString());
			if (ci != -1) {
				multilineComment = true;
				numCommentLines++;
				if (s.indexOf(getEndMultiLineCommentString()) != -1) {
					multilineComment = false;
				}
				s = s.substring(0,ci);
			}
			ci = s.indexOf(getEndMultiLineCommentString());
			if (ci != -1) {
				multilineComment = false;
				numCommentLines++;
				if (ci == s.length() - getEndMultiLineCommentString().length()) {
					s = "";
				} else {
					s.substring(ci + getEndMultiLineCommentString().length());
				}
			}
			if (multilineComment) {return "";}
			ci = s.indexOf(getCommentString());
			if (ci != -1) {
				ehsRegExp r = new ehsRegExp();
				if (r.regExpMatch(s,"\\[(.*)\\]")) {
					String[] groups = r.getFoundGroupsArray();
					processingInstructions(supportFunctions.splitIntoTokens(groups[0],","));
					return "";
				}
				numCommentLines++;
				s = s.substring(0,ci);
			}
			
			return s;
		}
		public String stripComments1(String s) {
			int commentIndex = s.indexOf(getCommentString());
			if (commentIndex != -1) {
				ehsRegExp r = new ehsRegExp();
				if (r.regExpMatch(s,"\\[(.*)\\]")) {
					String[] groups = r.getFoundGroupsArray();
					processingInstructions(supportFunctions.splitIntoTokens(groups[0],","));
					return "";
				}
				numCommentLines++;
				if (commentIndex == 0) {s = "";} else {s = s.substring(0,commentIndex);}
				s = s.trim();
			}
			return s;
		}
		public void processingInstructions(Vector instructions) {
			
		}
		public void setErrorString(String line,String token) {
			if (line.length() != 0) {
				syntaxError = "Syntax Error: " + line + " near " + token;
			} else {
				syntaxError = "";
			}
			String tmp = getExErrorMsg();
			if (tmp.length() != 0) {
				syntaxError = syntaxError + "\n" + tmp;
			}
			setErrorLineNumber(getLineNumber()+1);
		}
		public boolean compile(String filename) {
			return compile(filename,true);
		}
		public int getNumBlankLines() {return numBlankLines;}
		public int getNumCommentLines() {return numCommentLines;}
		public void removeAllExtraLines() {extraLines.removeAllElements();}
		public void addExtraLine(String line) {TRACE("addExtraLine:"+line,4);extraLines.addElement(line);}
		public boolean completeLine(String line) {return true;}
		public boolean compile(String filename,boolean bHeaders) {
			//displayDialog(filename);
			multilineComment = false;
			extraLines.removeAllElements();
			moduleName = supportFunctions.getFilenameNoExt(filename);
			msgD = displayModelessStatusDialog("Compile Status");
			setCompilerStatusMsg("Initalizing");
			bProcessHeaders = bHeaders;
			if (!preCompile(filename,bHeaders)) {return false;}
			syntaxError = "";
			exErrorMsg = "";
			errorLineNumber = 0;
			numBlankLines = 0;
			numCommentLines = 0;
			if (!supportFunctions.urlExists(filename)) {
				setExErrorMsg("Source file not found: " + filename);
				setErrorString("","");
				msgD.destory();
				msgD.dispose();
				msgD = null;
				return false;
			}
			f = new ehsFile(filename);
			for (int pass=1;pass<3;pass++) {
			if (pass == 2) {
				if (!betweenPassProcesses()) {
					msgD.destory();
					msgD.dispose();
					msgD = null;
					setErrorString("","");
					return false;
				}
			}
			setPassNumber(pass);
			int line = 0;
			f.resetReadFlag();
			do {
				if (extraLines.size() == 0) {
					sourceFileLine = f.readFileLine();
				} else {
					sourceFileLine = (String)extraLines.elementAt(0);
					extraLines.removeElementAt(0);
					TRACE("compile:extralines:"+sourceFileLine,4);
					//displayDialog("compiler:" + sourceFileLine);
				}
				
				sourceFileLine = stripComments(sourceFileLine);
				
				if (sourceFileLine != null && sourceFileLine.length() == 0) {numBlankLines++;}
				if (sourceFileLine != null && sourceFileLine.length() != 0) {
					preCompleteLine(sourceFileLine);
//					displayDialog("Line Read:"+sourceFileLine);
					do {
						if (completeLine(sourceFileLine)) {break;}
						String tmp1 = f.readFileLine();
						if ( tmp1 == null ) {break;}
						sourceFileLine = sourceFileLine + " " + tmp1;
						sourceFileLine = sourceFileLine.replaceAll("\\n","");
					} while (true);
					postCompleteLine(sourceFileLine);
					//TRACE("Complete Line:"+sourceFileLine,4);
					setLineNumber(line++);
					setCompilerStatusMsg("Compiling Pass " + String.valueOf(getPassNumber()) + " Line " + String.valueOf(getLineNumber()+1) + " (" + moduleName + ")");
					if (getPassNumber() == 1) {firstPassLine(getLineNumber(),sourceFileLine);}
					if (sourceFileLine.charAt(0) == '&') {
						writeDirectToOutput(sourceFileLine.substring(1));
					} else {
						if (!syntaxCheck(sourceFileLine)) {
							msgD.destory();
							msgD.dispose();
							msgD = null;
							return false;
						}
					}
				}
			} while (sourceFileLine != null);
			}
			msgD.destory();
			msgD.dispose();
			msgD = null;
			symbolTable.unresolvedForwardDecls();
			return postCompile(filename,bHeaders);
		}
		public void postCompleteLine(String line) {}
		public void preCompleteLine(String line) {}
		public void firstPassLine(int lineNumber,String line) {;}
		public boolean betweenPassProcesses() {
			return true;
		}
		public void setCompilerStatusMsg(String msg) {
			if (msgD != null) {msgD.setText(msg);}
		}
		public int processLine(String line,String keyword,Vector tokens) {
			int retStatus = 0;
			Vector tmp = transTable.getEntries();
			for (int i=0;i<tmp.size();i++) {
				translationTableEntry entry = (translationTableEntry)tmp.elementAt(i);
				if (keyword.toLowerCase().equals(entry.getKeyword())) {
					retStatus = processTokens(line,keyword,tokens,entry);
					if (retStatus == -1) {return retStatus;}
				}
			}
			return retStatus; // for failure 0 or greater - token index
		}
		public boolean isValidID(String ident) {
			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(ident,"^[a-zA-Z0-9][\\w]*$");
			String[] tokens;
			tokens = p.getFoundStringsArray();
			if (tokens.length != 0) {
				return true;
			}
			return false;
		}
		// the following ten functions need to be overridden in dervied class
		public String getKeywordFromLine(Vector tokens,String line) {
			return "";
		}
		public String compileLine(String line) {
			return line;
		}
		public boolean syntaxCheck(String line) {
			return false;
		}
		public boolean isValidIdentifier(String ident) {
			return isValidID(ident);
		}
		public boolean syntaxCheckInternal(String line,Vector tokens) {
			displayDialog("syntaxCheckInternal - " + line);
			return true;
		}
		public boolean preCompile(String filename,boolean bHeaders) {
			if (bHeaders) {
				transTable = new translationTable();
				transTable.loadTranslationTable(transTableName);
			}
			return true;
		}
		public boolean postCompile(String filename,boolean bHeaders) {return true;}
		public String getName() {return "Undefined";}
		public String getFileExt() {return "xxx";}
		public int processTokens(String line,String keyword,Vector lineTokens,translationTableEntry entry) {
			return -1; // for success
		}
	}
	
	public class HDLCompiler extends compiler {
		public compilerSymbolTable allSymbolTable = null;
		public Stack loopLabels;
		public Stack loopVariables;
		
		public HDLCompiler(String s) {
			super(s);
			allSymbolTable = new compilerSymbolTable();
			loopLabels = new Stack();
			loopVariables = new Stack();
		}
		public compilerSymbolTable getAllSymbolTable() {return allSymbolTable;}
		public boolean isLoop() {if (loopLabels.size() == 0) {return false;} else {return true;}}
		public int getLoopDepth() {return loopLabels.size();}
		public void addLoopLabel(String label) {loopLabels.push(label);}
		public String removeLoopLabel() {return (String)loopLabels.pop();}
		public String getLoopLabel() {return (String)loopLabels.peek();}
		public void addLoopVariable(String label) {loopVariables.push(label);}
		public String removeLoopVariable() {return (String)loopVariables.pop();}
		public String getLoopVariable() {return (String)loopVariables.peek();}
	}

 	public class VHDLCompiler extends HDLCompiler {
		private Properties 	componentPorts = new Properties();
		private String		componentDefName;
		private	pseduoFile	compilerPHPFile;
//		private	ehsFile		compilerPHPFile;
		private String		transFunctionPrefix;
		private String 		entityName,archName;
		
		private Vector 		signalFuncLines = new Vector();
		private Vector 		forcesFuncLines = new Vector();
		private Vector 		endOfFuncLines = new Vector();		
		private Vector 		endOfModuleLines = new Vector();
		private	Vector		portDefLines = new Vector();
		private	Vector		portmapDefLines = new Vector();
		
		//private	String 		currentProcessName; // moved up one level so that tokenizer class can access it
		private	String 		currentProcedureName;
		private	String 		currentFunctionName;
		private String		currentSigVarConstantName;
		private symType 	currentSigVarConstantType;
		private	String		currentType;

		private	String		currentParameterName;
		private	String		currentParameterModifier;
		private	String		currentParameterType;
		private	String		currentParameterMode;
		private	String		currentParameterDefault;
		private	int			currentParameterRet;
		private	int			currentParameterPos;
		
		protected String	compiledLine = "";
		protected VHDLcompilerTokens tokenizer;
		
		private	  String	waitStartChain;
				
		public VHDLCompiler() {
			super(VHDLTransTableName);
			tokenizer = new VHDLcompilerTokens();
			tokenizer.setReservedWords(VHDLReservedWords);
			tokenizer.setTypes(VHDLTypes);
			setVarPreDefined(true);
			setCommentString("////");
			setStartMultiLineCommentString("//*");
			setEndMultiLineCommentString("*//");
			
			transFunctionPrefix = "";
			componentDefName = "";
			currentFunctionName = "";
			currentSigVarConstantName = "";
			currentSigVarConstantType = symType.NONE;
			currentType = "";
			currentProcessName = "";
			currentProcedureName = "";
			currentParameterName = "";
			currentParameterModifier = "";
			currentParameterType = "";
			currentParameterMode = "in";
			currentParameterDefault = "";
			currentParameterRet = 0;
			currentParameterPos = 1;
			waitStartChain = "";
			endOfFuncLines.removeAllElements();
			endOfModuleLines.removeAllElements();
		}
		public String getEntityName() {return entityName;}
		public boolean isValidIdentifier(String ident) {
			if (tokenizer.isReserved(ident)) {return false;}
			return isValidID(ident);
		}
		public String compileLine(String line) {
			String PHPCode = "";
			setCompileLine(true);
			Vector lines = supportFunctions.splitIntoTokens(line,";");
			for (int lineNumber=0;lineNumber<lines.size();lineNumber++) {
				compiledLine = "";
				if(!syntaxCheck((String)lines.elementAt(lineNumber))) {return "";}
				PHPCode = PHPCode + compiledLine;
			}
			setCompileLine(false);
			return PHPCode;
		}
		public String clearQuotedStrings(String line) {
			String tmp = line;
			
			String[] groups = regMatchGroups(tmp,"\"(.*)\"");
			for (int i=0;i<groups.length;i++) {
				tmp = tmp.replaceAll("\""+groups[i]+"\"","\"\"");
			}
			return tmp;
		}
		public boolean syntaxCheck(String line) {
			ehsRegExp p = new ehsRegExp();
			
			p.regExpMatch(line,"(?i)disconnect\\s*(\\w+)\\s*:\\s*.*(after\\s*.*);");
			String[] tokens1 = p.getFoundGroupsArray();
			if(tokens1.length > 0) {
				line = tokens1[0]+"<='Z' " + tokens1[1] + ";";
				//displayDialog(line);
			}
			
			p.regExpMatch(line,"((\\w+)\\s*&\\s*(\\w+))");
			tokens1 = p.getFoundGroupsArray();
			if (tokens1.length > 0) {
				line = line.replaceAll(tokens1[0],tokens1[1] + " cat " + tokens1[2]);
			}
			
			p.regExpMatch(line,"(?i)block\\s*is\\s*$");
			tokens1 = p.getFoundGroupsArray();
			if(tokens1.length > 0) {
				line = line.replaceAll("block","block true");
			}
			
			p.regExpMatch(line,"(?i)block\\s*$");
			tokens1 = p.getFoundGroupsArray();
			if(tokens1.length > 0) {
				line = line.replaceAll("block","block true");
			}

			Vector v = tokenizer.tokenizeLine(line);
			syntaxError = "";

			return syntaxCheckInternal(line,v);
		}
		compilerSymbol isType(String entity,String symbolName) {
			// is symbolName a type or a constant in the symbol table?
			compilerSymbol tmp = null;
			tmp = symbolTable.findSymbol(entity,currentScope(),symbolName,symType.TYPE);
			if (tmp != null) {return tmp;}
			tmp = symbolTable.findSymbol(entity,currentScope(),symbolName,symType.CONSTANT);
			if (tmp != null) {return tmp;}
			symbolName = symbolName.toLowerCase();
			
			if (tokenizer.isType(symbolName)) {
				tmp = new compilerSymbol(entity,"",symbolName,symbolName,symType.INTERNAL,symClass.NONE);
				return tmp;
			}
			
			return (compilerSymbol)null;
		}
		String getRecordType(String entity,String typeName,String typeDef) {
			String retType = "";
			
			//displayDialog("in:"+typeDef);
			Vector v = supportFunctions.splitIntoTokens(typeDef,";");
			writeDirectToOutput("\nclass " + typeName + " {");
			for (int i=0;i<v.size();i++) {
				Vector v1 = supportFunctions.splitIntoTokens((String)v.elementAt(i),":");
				if (v1.size()==0) {continue;}
				String tmp = (String)v1.elementAt(1);
				Vector v2 = supportFunctions.splitIntoTokens((String)v1.elementAt(0),",");
				for (int ii=0;ii<v2.size();ii++) {
				if (retType.length() != 0) {retType = retType + "&";}
					retType = retType + (String)v2.elementAt(ii) + "&" + tmp;
					String tmp1 = (String)v2.elementAt(ii);
					writeDirectToOutput("\n\tvar $" +  tmp1.trim() + ";");
				}
			}
			writeDirectToOutput("\n}\n");
			retType = retType.replaceAll(" & ","&");
			//displayDialog("out:"+retType);
			return retType;
		}
		String getTypeType (String entity,String typeName,String typeDef) {
			// the supplied string for checking is from the start of the type definition to the
			// terminating ; or := or ) characters
			
			String type = "";
			ehsRegExp p = new ehsRegExp();
			typeDef.trim();

			p.regExpMatch(typeDef,"(?i)record(.*)end\\s*record");
			String[] tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				return getRecordType(entity,typeName,tokens[0].trim());
			}
			
			p.regExpMatch(typeDef,"(?i)of\\s(\\w+)");
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				TRACE("Point A",5);
				type = tokens[0];
			}

			p.regExpMatch(typeDef,"(?i)(\\w+)\\s\\(\\s(\\w+)\\s(?:to|downto)\\s(\\w+)\\s\\)");
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0 && type.length() == 0) {
				TRACE("Point B",5);
				type = tokens[0];
			}

			p.regExpMatch(typeDef,"(?i)(\\w+)\\srange");
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0 && type.length() == 0) {
				TRACE("Point C",5);
				type = tokens[0];
			}

			p.regExpMatch(typeDef,"(?i)(\\w+)\\s\\(\\s(\\w+)\\s\\)");
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0 && type.length() == 0) {
				TRACE("Point D",5);
				type = tokens[0];
			}

			p.regExpMatch(typeDef,"\\(\\s(.*)\\s\\)"); 
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0 && type.length() == 0) {
				TRACE("Point E",5);
				type = tokens[0];
				type = type.replaceAll(",","#"); // enum type - can't use comma character to separate elements!
				type = "enum" + type;
			}

			p.regExpMatch(typeDef,"(\\w+)\\s(\\w+)"); 
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0 && type.length() == 0) {
				TRACE("Point F",5);
				type = tokens[0];
			}

			p.regExpMatch(typeDef,"(\\w+)"); 
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0 && type.length() == 0) {
				TRACE("Point G",5);
				type = tokens[0];
			}

			if (type.length() !=0) {
				// got a type that will either be built-in, in the symbol table or an undefined type
				TRACE("Point H",5);
				compilerSymbol tmp = isType(entity,type);
				if (tmp != null) {
					TRACE("Point I",5);
					String tmp1 = tmp.getSymbolValue();
					if (tmp.getEnum() == true) { tmp1 = "enum" + tmp1;}
					type = tmp1;
					TRACE("Point J",5);
				}
			} else {
				displayDialog("Invalid type definition: " + typeDef);
			}
			
			TRACE("getTypeType:typedef:"+typeDef+" and type:"+type,5);
			return type;
		}
		public int getNumericTypeStringValue(String entity,String token) {
			TRACE("getNumericTypeStringValue:"+token,4);
			if (tokenizer.isNumeric(token)) {return Integer.parseInt(token);}
			compilerSymbol tmp = isType(entity,token);
			if (tmp != null) {return Integer.parseInt(tmp.getSymbolValue());}
			
			return -unconstrainedArrayValue - 1;
		}
		String lowerStringRange = "";
		String upperStringRange = "";
		String getLowerStringRange() {return lowerStringRange;}
		String getUpperStringRange() {return upperStringRange;}
		int[] getTypeRange(String entity,String typeDef) {
			int[] range = new int[2];
			range[0] = 0;
			range[1] = 0;
			lowerStringRange = "";
			upperStringRange = "";
			
			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(typeDef,"(?i)range\\s('*\\w+'*)\\s(?:to|downto)\\s('*\\w+'*)");
			String[] tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				range[0] = getNumericTypeStringValue(entity,tokens[0]);
				range[1] = getNumericTypeStringValue(entity,tokens[1]);	
				if (range[0] == -unconstrainedArrayValue - 1) {lowerStringRange = tokens[0];}
				if (range[1] == -unconstrainedArrayValue - 1) {upperStringRange = tokens[1];}			
				return range;
			}

			p.regExpMatch(typeDef,"(?i)range\\s(\\w+)"); 
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				range[0] = -unconstrainedArrayValue;
				range[1] = unconstrainedArrayValue;				
			}
			
			// this is the last check in the chain, so if it fails just return 0 for the lower and upper range values
			p.regExpMatch(typeDef,"(\\w+)"); // check just for a type identifier
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				compilerSymbol tmp = isType(entity,tokens[0]); // assuming a symType.TYPE or symType.CONSTANT or built in type
				if (tmp == null) {
					range[0] = 0;
					range[1] = 0;
				} else {
					range[0] = tmp.getLowerRange();
					range[1] = tmp.getUpperRange();
				}
				
				return range;
			}

			return range;
		}
		int[] getTypeBounds(String entity,String typeDef) {
			int[] bounds = new int[2];
			bounds[0] = 0;
			bounds[1] = 0;
			
			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(typeDef,"(?i)\\((\\w+)\\s(?:to|downto)\\s(\\w+)\\)");
			String[] tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				bounds[0] = getNumericTypeStringValue(entity,tokens[0]);
				bounds[1] = getNumericTypeStringValue(entity,tokens[1]);								
				return bounds;
			}
		
			p.regExpMatch(typeDef,"\\((\\w+)\\)");
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				// found term will either be an integer representing upper bound (lower bound=0) or another type id
				if (tokenizer.isNumeric(tokens[0])) {
					bounds[0] = 0;
					bounds[1] = Integer.parseInt(tokens[0]);
				} else {
					compilerSymbol tmp = isType(entity,tokens[0]); // assuming a symType.TYPE or symType.CONSTANT or built in type
					if (tmp != null) {
						bounds[0] = tmp.getLowerBound();
						bounds[1] = tmp.getUpperBound();
					} else {
						displayDialog("getTypeBounds1: Error " + tokens[0] + " is not a valid type identifier");
						bounds[0] = 0;
						bounds[1] = 0;
					}
				}
				
				return bounds;
			}
			
			// check for a unconstrained array
			p.regExpMatch(typeDef,"(?i)\\((\\w+)\\srange\\s<>\\)");
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
					bounds[0] = -unconstrainedArrayValue;
					bounds[1] = unconstrainedArrayValue;
				
				return bounds;
			}
			
			// this is the last check in the chain, so if it fails just return 0 for the lower and upper bound values
			p.regExpMatch(typeDef,"(\\w+)"); // check just for a type identifier
			tokens = p.getFoundGroupsArray();
			if(tokens.length > 0) {
				compilerSymbol tmp = isType(entity,tokens[0]); // assuming a symType.TYPE or symType.CONSTANT or built in type
				if (tmp == null) {
					bounds[0] = 0;
					bounds[1] = 0;
				} else {
					bounds[0] = tmp.getLowerBound();
					bounds[1] = tmp.getUpperBound();
				}
				return bounds;
			}

			return bounds;
		}
		String processTypeUse(String entity,String typeName,String typeDef,String complierToken,String subscope,symType symtype) {
			compilerSymbol sigvarconSym = null;
			if (typeName.length() != 0) { // for signal, variable and constant keywords
				// see last part of this function for where we update this symbol table entry
				sigvarconSym = symbolTable.findSymbol(entity,currentScope(),typeName,symtype);
				if (sigvarconSym == null) {
					displayDialog("ProcessTypeUse: Error " + typeName + " not found in symbol table");
					return ""; // error condition?
				}
			}
			
			boolean bArray = false;
			if (typeDef.indexOf("array") != -1) {bArray = true;} else {bArray = false;}
			boolean bDynamic = false;
			if (typeDef.indexOf("access") != -1) {bDynamic = true;} else {bDynamic = false;}
			typeDef = typeDef.replaceAll("access","");
			
			boolean bEnum = false;
			String retstring = "";
			int[] range = new int[2];
			int[] bounds = new int[2];
			String type = getTypeType(entity,typeName,typeDef);
			if (type.startsWith("enum")) {
				bEnum = true;
				type = type.substring(4);
			}

			range = getTypeRange(entity,typeDef);
			bounds = getTypeBounds(entity,typeDef);
			retstring = type + "," + String.valueOf(bounds[0]) + "," + String.valueOf(bounds[1]) + "," + String.valueOf(range[0]) + "," + String.valueOf(range[1]) + "," + subscope + "," + getLowerStringRange() + "," + getUpperStringRange() + "," + valueOf(bEnum) + "," + valueOf(bArray) + "," + valueOf(bDynamic);
			
			// update symbol table entry for 'signal', 'variable' or 'constant' keywords
			if (sigvarconSym != null) {
				sigvarconSym.setRanges(range[0],range[1]);
				sigvarconSym.setBounds(bounds[0],bounds[1]);
				sigvarconSym.setSymbolValue(type);
				sigvarconSym.setSubScope(subscope);
				sigvarconSym.setEnum(bEnum);
				sigvarconSym.setArray(bArray);
				sigvarconSym.setDynamic(bDynamic);
				sigvarconSym.setStringLowerRange(getLowerStringRange());
				sigvarconSym.setStringUpperRange(getUpperStringRange());
			}
			
			return retstring;
		}
		String processTypeDef(String entity,String typeName,String typeDef,String subscope) {
			//displayDialog("processTypeDef:"+typeName+":"+typeDef);
			compilerSymbol sym = symbolTable.findSymbol(entity,currentScope(),typeName,symType.TYPE);
			if (sym != null) {
				
				if (typeDef.indexOf("access") != -1) {sym.setDynamic(true);} else {sym.setDynamic(false);}
				typeDef = typeDef.replaceAll("access","");
				
				int[] range = getTypeRange(entity,typeDef);
				int[] bounds = getTypeBounds(entity,typeDef);
				sym.setRanges(range[0],range[1]);
				sym.setBounds(bounds[0],bounds[1]);
				sym.setEnum(false);
				String tmp = getTypeType(entity,typeName,typeDef);
				if (tmp.startsWith("enum")) {
					tmp = tmp.substring(4);
					sym.setEnum(true);
				}
				if (typeDef.indexOf("array") != -1) {
					sym.setArray(true);
					if(arrayNamesProcessed.length() != 0) {arrayNamesProcessed = arrayNamesProcessed  + ",";}
					arrayNamesProcessed = arrayNamesProcessed  + entity + "," + tmp;
				} else {sym.setArray(false);}
				sym.setSymbolValue(tmp);
				sym.setSubScope(subscope);
				sym.setStringLowerRange(getLowerStringRange());
				sym.setStringUpperRange(getUpperStringRange());
			}
			return typeDef;
		}
		public String getKeywordFromLine(Vector tokens) {
			if (tokens.size() == 0) {return "";}
			//TRACE("getKeywordFromLine:",tokens,4);
			// if line does a signal or variable assignment return the "airtheng" keyword
			if (tokens.contains("<=") || tokens.contains(":=")) {
				if (tokens.contains("signal") || tokens.contains("variable")) {
				} else {
					return "airtheng";
				}
			}
			// special case for keywords - processs, portmap and useentity
			// no space between for example, portmap, because called after preProcessLine(..)
			if (tokens.contains("process")) {return "process";}
			if (tokens.contains("portmap")) {return "portmap";}
			if (tokens.contains("useentity")) {return "useentity";}
			
			// default case first token on line unless first token is a line label
			String tmp = (String)tokens.elementAt(0);
			
			if (tokens.size() > 2) {
				String tmp1 = (String)tokens.elementAt(1);
				if (tmp1.equals(":") && !tokens.contains("process") && !tokens.contains("end") && !tokens.contains("port")) {
					TRACE("getKeywordFromLine:Got line label:"+tmp,4);
					tokens.setElementAt((String)tokens.elementAt(0)+":",0);
					tokens.setElementAt("",1);
					if (tokens.size() > 2) {
						tmp =  (String)tokens.elementAt(2);
					} else {
						return "linelabel";
					}
				}
			}
			
			// check to see if we have a valid keyword (check reserved words)
			Vector v = supportFunctions.splitIntoTokens(VHDLReservedWords);
			if (v.contains(tmp)) {
				if (tmp.equals("for")) {
					if (!tokens.contains("to") && !tokens.contains("downto")) {tmp = "forenum";}
				}
				return tmp;
			}
				
			return "justfunctions";
		}
		public boolean syntaxCheckInternal(String line,Vector tokens) {
			if (tokens.size() == 0) {TRACE("syntaxCheckInternal:Empty Line",4);return true;}
		
			TRACE("VHDL Syntax Check Internal Line : " + line,4);
			
			// delete the NYS keywords
			boolean bFound = false;
			for (int i=0;i<VHDLNYSWords.length;i++) {
				tokens.removeElement(VHDLNYSWords[i]);
				bFound = true;
			}
			if (bFound) {line = reasembleTokens(tokens," ");}
			
			// get the VHDL keyword from the line
			String keyword = getKeywordFromLine(tokens);
			
			// for FILE keyword swap tokens 5 and 6 (zero based)(in##out and filename)
			if (keyword.equals("file")) {
				String tmp = (String)tokens.elementAt(5);
				//displayDialog("FILE (t5): " + tmp); // debug line
				//displayDialog("FILE (t6): " + (String)tokens.elementAt(6)); // debug line
				tokens.setElementAt((String)tokens.elementAt(6),5);
				tokens.setElementAt(tmp,6);
				line = reasembleTokens(tokens," ");
				//displayDialog("FILE: " + line); // debug line
			}

			if (line.indexOf("wait") != -1) {
				if (getPassNumber() == 2) {processWaits(line,tokens);}
				return true;
			}
		
			// process the line using the translation table entry defined by the above keyword
			int status = processLine(line,keyword,tokens);
			if (status != -1) {
				setErrorString("Line:" + String.valueOf(getLineNumber()+1)+" " + line,(String)tokens.elementAt(status));
				return false;
			}
			return true;
		}
		public void writeWaitBlock(String pname,String sname,String tiggertime,boolean bDeleteSignal) {
			TRACE("writeWaitBlock:pname:"+pname+":sname:"+sname,4);
			int startLine = getCompilerFile().getCurrentLineNum() + 1; 
			int endProcessLine = getCompilerFile().find("end process",startLine);
			int waitLine = getCompilerFile().find("wait",startLine);
			TRACE("writeWaitBlock:startLine="+String.valueOf(startLine)+",endProcessLine="+String.valueOf(endProcessLine)+",waitLine="+String.valueOf(waitLine),4);
			
			
			Vector signals = supportFunctions.splitIntoTokens(sname,",");
			for (int i=0;i<signals.size();i++) {
				writeDirectToOutput("\ncreateSPMap('"+entityName+"','"+pname+"','"+(String)signals.elementAt(i)+"');");
				if (tiggertime.length() != 0) {writeDirectToOutput("\nprocessWaitForSignal('"+tiggertime+"');");}
			}
			addExtraLine("end process " + currentProcessName + ";");
			addExtraLine(pname + ": process("+sname+")");
			addExtraLine("begin");
			for (int i=0;i<signals.size();i++) {
				addExtraLine("&\ndeleteSPMap('"+entityName+"','"+pname+"','"+(String)signals.elementAt(i)+"');"); // note & char for write direct
				if (bDeleteSignal) {addExtraLine("&\ndeleteSignal('"+entityName+"','"+(String)signals.elementAt(i)+"');");}
			}
			
			TRACE("writeWaitBlock:Set file line:" + String.valueOf(endProcessLine) + ":end process " + pname + ";",4);
			getCompilerFile().setFileLine(endProcessLine,"end process " + pname + ";");

			if (waitStartChain.length() == 0) { // start of wait chain
				TRACE("writeWaitBlock:start of wait chain",4);
				waitStartChain = currentProcessName; // GDB 01/03/2015 used to be pname
			}
			if (waitLine == -1 || endProcessLine < waitLine) { // end of wait chain
				TRACE("writeWaitBlock:end of wait chain",4);
				addExtraLine("&\nrerunwaitchain('" + waitStartChain + "');");
				waitStartChain = "";
			}
		}
		public void processWaits(String line,Vector tokens) {
			TRACE("processWaits:Enterted",4);
			
			String sname = "";
			String tiggertime = "";
			String pname = "process" + String.valueOf(noNameProcessesID++);
			
			if (line.indexOf(" on ") != -1) {
				TRACE("processWaits:on",4);
				int index = tokens.indexOf("on");
				sname = (String)tokens.elementAt(index + 1);
				writeWaitBlock(pname,sname,tiggertime,false);
				return;
			}
			if (line.indexOf(" until ") != -1) {
				TRACE("processWaits:until",4);
				int index = tokens.indexOf("until");
				sname = "intsignal" + String.valueOf(noNameProcessesID++);
				int index1 = line.indexOf("until");
				index1 = index1 + 6; // get to rest of line after until keyword
				String waitCondition = line.substring(index1,line.length()-1); // also removes trailing ; character
				waitCondition = processFuncArgs(waitCondition);
				writeDirectToOutput("\ncreateSignal('"+entityName+"','"+entityName+"','"+sname+"','out','bit,0,0,0,0,"+entityName+",,,0,0',0,'0');");
				symbolTable.addSymbol(entityName,currentScope(),sname,String.valueOf(0),symType.SIGNAL,symClass.NONE);
				writeDirectToOutput("\nprocessWaitUntilSignal('"+entityName+"','"+sname+"','"+waitCondition+"');");
				writeWaitBlock(pname,sname,tiggertime,true);
				return;
			}
			if (line.indexOf(" for ") != -1) {
				TRACE("processWaits:for",4);
				int index = tokens.indexOf("for");
				sname = "intsignal" + String.valueOf(noNameProcessesID++);
				String timespec = (String)tokens.elementAt(index + 1);
				tiggertime = entityName +":" + sname + ":" + numberPart(timespec) + ":" + stringPart(timespec); // module:signalname:time value:time unit
				writeDirectToOutput("\ncreateSignal('"+entityName+"','"+entityName+"','"+sname+"','out','bit,0,0,0,0,"+entityName+",,,0,0',0,'0');");
				symbolTable.addSymbol(entityName,currentScope(),sname,String.valueOf(0),symType.SIGNAL,symClass.NONE);
				writeWaitBlock(pname,sname,tiggertime,true);
				return;
			}
			// get here and its wait; - default case (ignore?)
			TRACE("processWaits:wait;",4);
			waitStartChain = ""; // cancel any wait chain
		}
		public String getName() {return "VHDL";}
		public String getFileExt() {return "vhdl";}
		public void writeDirectToOutput(String line) {compilerPHPFile.appendFile(line);}
		public boolean preCompile(String filename,boolean bHeaders) {
			indentionCount = 0;
			archName = "";
			entityName = "";
			componentPorts.clear();
			transFunctionPrefix = "";
			waitStartChain = "";
			arrayNamesProcessed = "";
			
			// clear compile place holder list
			placeHolders.remove("*e");
			placeHolders.remove("*f");
			placeHolders.remove("*g");
			placeHolders.remove("*h");
			
			// start with an empty symbol table
			symbolTable.removeAllSymbols();
			
			TRACE("PC1: PreCompile",4); // debug line
			
			if (bHeaders) {
				portDefLines.removeAllElements();
				portmapDefLines.removeAllElements();
				signalFuncLines.removeAllElements();
				signalFuncLines.addElement("function initSignals() {");
				signalFuncLines.addElement("}");
				forcesFuncLines.removeAllElements();
				forcesFuncLines.addElement("function storeProcessNames() {");
				forcesFuncLines.addElement("}");
			
				extraCompileFiles.removeAllElements();
				transTable = new translationTable();
				transTable.loadTranslationTable(transTableName);
//				compilerPHPFile = new ehsFile("../hdlworkbench/output",supportFunctions.getFilenameNoExt(filename) + ".php");
				compilerPHPFile = new pseduoFile(""+dataRelativePath+"/"+appDirectory+"/output",supportFunctions.getFilenameNoExt(filename) + ".php");
				TRACE("PC2: PreCompile",4); // debug line
				compilerPHPFile.saveFile("<html>\n<head>"); // saveFile used to remove any existing file
				if(systemUserReg.getAppRemotedHosted()) {
					compilerPHPFile.appendFile("\n<script src=\""+appBaseURL+"/website/scripts/common.js\" type=\"text/javascript\"></script>");
					compilerPHPFile.appendFile("\n<script src=\""+appBaseURL+"/website/scripts/jquery-1.9.0.js\" type=\"text/javascript\"></script>");
					compilerPHPFile.appendFile("\n<link rel=\"stylesheet\" href=\""+appBaseURL+"/website/css/ehs_default.css\" type=\"text/css\" media=\"screen\">");
				} else {
					compilerPHPFile.appendFile("\n<script src=\""+remoteHostRelativePath+"/scripts/common.js\" type=\"text/javascript\"></script>");
					compilerPHPFile.appendFile("\n<script src=\""+remoteHostRelativePath+"/scripts/jquery-1.9.0.js\" type=\"text/javascript\"></script>");
					compilerPHPFile.appendFile("\n<link rel=\"stylesheet\" href=\""+remoteHostRelativePath+"/css/ehs_default.css\" type=\"text/css\" media=\"screen\">");
				}
				compilerPHPFile.appendFile("\n</head>\n<body>");
				compilerPHPFile.appendFile("\n<?");
				compilerPHPFile.appendFile("\n\n// Generated by: " + systemUserReg.getSingleLineInfoText());
				compilerPHPFile.appendFile("\n// Generation date: " + currentShortDate() + " " + currentShortTime());
				compilerPHPFile.appendFile("\n");
				if(!systemUserReg.getAppRemotedHosted()) {
					compilerPHPFile.appendFile("\ninclude(\""+remoteHostRelativePath+"/website/scripts/common.php\");");
				} else {
					compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/website/scripts/common.php\");");
				}
				// has to be before the line that includes simlib.php as this files will set it to a default of "" if not already set
				compilerPHPFile.appendFile("\n$langkeywords = \""+VHDLReservedWords+"\";\n");
				if(!systemUserReg.getAppRemotedHosted()) {
					compilerPHPFile.appendFile("\ninclude(\"../support/simlib.php\");");
					compilerPHPFile.appendFile("\ninclude(\"../support/vhdlstandardfuncs.php\");");
					compilerPHPFile.appendFile("\ninclude(\"../support/textio.php\");");
					compilerPHPFile.appendFile("\ninclude(\"../support/std_logic_1164.php\");");
					compilerPHPFile.appendFile("\ninclude(\"../support/numeric_std.php\");");
					compilerPHPFile.appendFile("\ninclude(\"../support/standard.php\");");
				} else {
					compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/applications/hdlworkbench/support/simlib.php\");");
					compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/applications/hdlworkbench/support/vhdlstandardfuncs.php\");");
					compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/applications/hdlworkbench/support/textio.php\");");
					compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/applications/hdlworkbench/support/std_logic_1164.php\");");
					compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/applications/hdlworkbench/support/numeric_std.php\");");
					compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/applications/hdlworkbench/support/standard.php\");");
				}
			
				compilerPHPFile.appendFile("\n$link = mysqlConnect();");
				compilerPHPFile.appendFile("\nclearDatabase($_GET[\"entity\"]);");
			}
			
			TRACE("PC3: PreCompile",4); // debug line
			return true;
		}
		public boolean postCompile(String filename,boolean bHeaders) {
				TRACE("PC1: PostCompile",4); // debug line
				waitStartChain = "";
				
				if (bHeaders) {	
				TRACE("postCompile:filename:"+filename,4);
				String entitiesProcessed = supportFunctions.getFilenameNoExt(filename);
				String dirsProcessed = supportFunctions.getPath(filename);
				getAllSymbolTable().mergeSymbolTable(symbolTable);

				for (int i=0;i<extraCompileFiles.size();i++) {
						//displayDialog("Compile Extra File " + (String)extraCompileFiles.elementAt(i));
						TRACE("PC2: PostCompile ExtraFile:" + (String)extraCompileFiles.elementAt(i),4); // debug line
						if (!compile((String)extraCompileFiles.elementAt(i),false)) {
						return false;
					}
					entitiesProcessed = entitiesProcessed + ",";
					entitiesProcessed = entitiesProcessed + supportFunctions.getFilenameNoExt((String)extraCompileFiles.elementAt(i));
					dirsProcessed = dirsProcessed + ",";
					dirsProcessed = dirsProcessed + supportFunctions.getPath((String)extraCompileFiles.elementAt(i));
					getAllSymbolTable().mergeSymbolTable(symbolTable);
				}

				compilerPHPFile.appendFile("\nfunction getEntities() {\n\treturn \"");
				compilerPHPFile.appendFile(entitiesProcessed);
				compilerPHPFile.appendFile("\";\n}\n");

				compilerPHPFile.appendFile("\nfunction getTypes() {\n\treturn \"");
				compilerPHPFile.appendFile(tokenizer.getStringOfTypes());
				compilerPHPFile.appendFile("\";\n}\n");

				compilerPHPFile.appendFile("\nfunction getNoNameProcesses() {\n\treturn \"");
				compilerPHPFile.appendFile(tokenizer.noNameProcesses);
				compilerPHPFile.appendFile("\";\n}\n");

				compilerPHPFile.appendFile("\nfunction getArrayNames() {\n\treturn \"");
				compilerPHPFile.appendFile(arrayNamesProcessed);
				compilerPHPFile.appendFile("\";\n}\n");

				for (int j=0;j<signalFuncLines.size();j++) {
					compilerPHPFile.appendFile("\n" + (String)signalFuncLines.elementAt(j));
				}
				for (int j=0;j<forcesFuncLines.size();j++) {
					compilerPHPFile.appendFile("\n" + (String)forcesFuncLines.elementAt(j));
				}
			
				compilerPHPFile.appendFile("\nsimulate($_GET[\"entity\"]);\nmysql_close($link);\n?>");
				compilerPHPFile.appendFile("\n</body>\n</html>\n");
				compilerPHPFile.flush();
				
				processHDLDrawingItems(filename,dirsProcessed,entitiesProcessed);				
				if (isApplet()) {getAllSymbolTable().createSymbolDialog("Data Dictionary","");}
			}
			return true;
		}
		public void processHDLDrawingItems(String filename,String dirsProcessed,String entitiesProcessed) {
			ehsFile f = new ehsFile(filename);
			pseduoFile HDLDrawingItemsFile = new pseduoFile(""+dataRelativePath+"/"+appDirectory+"/output",supportFunctions.getFilenameNoExt(filename) + "_hdlitems.xml");
			HDLDrawingItemsFile.saveFile("<?xml version=\"1.0\"?>"); // saveFile used to remove any existing file
			HDLDrawingItemsFile.appendFile("\n");
			HDLDrawingItemsFile.appendFile("<hdldrawingitems>");
			HDLDrawingItemsFile.appendFile("\n");
			
			String basePath = ""+dataRelativePath+"/"+appDirectory;
			HDLDrawingItemsFile.appendFile("\t<config date=\"" + currentShortDate() + "\" time =\"" + currentShortTime() + "\" basepath =\"" + basePath + "\" />\n");

			TRACE("processHDLDrawingItems:entitiesProcessed:"+entitiesProcessed,4);
			TRACE("processHDLDrawingItems:dirsProcessed:"+dirsProcessed,4);
			Vector v = supportFunctions.splitIntoTokens(entitiesProcessed,",");
			Vector v4 = supportFunctions.splitIntoTokens(dirsProcessed,",");
			for (int i=0;i<v.size();i++) {
				String entity = (String)v.elementAt(i);
				String dir = (String)v4.elementAt(i);
				if (dir.startsWith(basePath)) {dir = dir.substring(basePath.length() + 1);}
				HDLDrawingItemsFile.appendFile("\t<entity name=\"" + entity + "\" path =\"" + dir + "\">\n");
				String allPorts = "";
				for (int ii=0;ii<portDefLines.size();ii++) {
					String tmp = (String)portDefLines.elementAt(ii);
					Vector v1 = supportFunctions.splitIntoTokens(tmp,",");
					if (entity.equals((String)v1.elementAt(0))) {
						HDLDrawingItemsFile.appendFile("\t\t<port name=\"" + (String)v1.elementAt(2) + "\" mode=\"" + (String)v1.elementAt(3) + "\" type=\"" + (String)v1.elementAt(4) + "\" />\n");
						if (allPorts.length() != 0) {allPorts = allPorts + ";";}
						allPorts = allPorts + (String)v1.elementAt(2) + "," + (String)v1.elementAt(3) + "," + (String)v1.elementAt(4);
					}
				}
				HDLDrawingItemsFile.appendFile("\t\t<allports name=\"" + allPorts + "\" />\n");
				HDLDrawingItemsFile.appendFile("\t</entity>\n");
			}
			TRACE("processHDLDrawingItems:PC1",4);
			int connID = 0;
			Vector keys = new Vector();
			Vector values = new Vector();
			for (int i=0;i<portmapDefLines.size();i++) {
				String tmp = (String)portmapDefLines.elementAt(i);
				Vector v1 = supportFunctions.splitIntoTokens(tmp,",");
				Vector v2 = supportFunctions.splitIntoTokens((String)v1.elementAt(1),";");
				int startIndex = 3;
				for (int ii=0;ii<v2.size();ii++) {
					Vector v3 = supportFunctions.splitIntoTokens((String)v2.elementAt(ii),":");
					HDLDrawingItemsFile.appendFile("\t<connection name=\"connection" + String.valueOf(connID++) + "\" fromentity=\"" + (String)v1.elementAt(0) + "\" toentity=\"" + (String)v1.elementAt(2) + "\" fromport=\"" + (String)v3.elementAt(0) + "\" toport=\"" + (String)v1.elementAt(startIndex++) + "\" />\n");
					String key = (String)v1.elementAt(0) + ":" + (String)v3.elementAt(0);
					// for the other end of the connection
					String otherEndKey = "";
					String otherEndData = key;
					
					int index = keys.indexOf(key);
					if (index == -1) {
						keys.addElement(key);
						values.addElement((String)v1.elementAt(2) + ":" + (String)v1.elementAt(startIndex-1));
						otherEndKey = (String)v1.elementAt(2) + ":" + (String)v1.elementAt(startIndex-1);
					} else {
						String tmp1 = (String)values.elementAt(index);
						tmp1 = tmp1 + "," + (String)v1.elementAt(2) + ":" + (String)v1.elementAt(startIndex-1);
						values.setElementAt(tmp1,index);
						otherEndKey = (String)v1.elementAt(2) + ":" + (String)v1.elementAt(startIndex-1);
					}
					
					TRACE("processHDLDrawingItems:otherendkey:"+otherEndKey+":otherenddata:,"+otherEndData,4);
					index = keys.indexOf(otherEndKey);
					if (index == -1) {
						keys.addElement(otherEndKey);
						values.addElement(otherEndData);
					} else {
						String tmp1 = (String)values.elementAt(index);
						tmp1 = tmp1 + "," + otherEndData;					
						values.setElementAt(tmp1,index);
					}
				}
			}
			TRACE("processHDLDrawingItems:PC2",4);
			connID = 0;
			for (int i=0;i<keys.size();i++) {
				String tmp = (String)keys.elementAt(i);
				Vector v5 = supportFunctions.splitIntoTokens(tmp,":");
				String entity = (String)v5.elementAt(0);
				String port = (String)v5.elementAt(1);
				String connlist = (String)values.elementAt(i);
				HDLDrawingItemsFile.appendFile("\t<connlist name=\"connlist" + String.valueOf(connID++) + "\" entity=\"" + entity + "\" port=\"" + port + "\" clist=\"" + connlist + "\" />\n");			
			}
			
			HDLDrawingItemsFile.appendFile("</hdldrawingitems>\n");
			HDLDrawingItemsFile.flush();

			TRACE("processHDLDrawingItems:PC3",4);
		}
		public boolean betweenPassProcesses() {
			if (transFunctionPrefix.length() == 0) {
				setExErrorMsg("Not an Entity or a Package");
				return false;
			} else {
				if (bProcessHeaders) {
				}
			}
			return true;
		}
		public boolean completeLine(String line) {
			int bracketMatchCount = strCount(line,'(') - strCount(line,')');
		
			// check for complete lines that do not end in a ';' character
			if (line.contains("begin")) {return true;}
			if (line.contains("process") && strCount(line,'(') == 1 && strCount(line,')') == 1) {return true;}
			
			// the next four lines must be tested in this order and before the test for line ending in 'is'
			if (line.contains("type") && line.contains("record") && line.contains("end record")) {return true;}
			if (line.contains("type") && line.contains("record")) {return false;}
			if (line.contains("type") && line.endsWith(";")) {return true;}
			if (line.contains("type")) {return  false;}
			
			if (line.startsWith("component")) {return true;}
			if (line.endsWith("is")) {return true;}
			if (line.endsWith("then")) {return true;}
			if (line.endsWith("else")) {return true;}
			if (line.endsWith("process")) {return true;}

			// check for complete lines that do end in a ';' character
			if (line.contains("port") && bracketMatchCount == 0) {return true;}
			if (line.endsWith(";") && !line.contains("port")) {return true;}
			
			return false;
		}
		String processFuncArgs(String line) {
			// This fuction look for signals, variables or constants in the input line and replaces
			// with getSignal ( entityName , signalName [,arrayIndex] ) for example - note the spaces!
			// Called for 'justfunctions', 'airtheng', 'pfstring' and the wait keyword processing
			// For all other keywords the 'getSignal', etc. will occur in the translation table entry.
			
			TRACE("processFuncArgs:Enter:"+line,4);
			
			line = line.replaceAll("else unaffected","");
			String[] tokens = regMatchGroups(line,"((\\w+)\\.(\\w+))");
			if (tokens.length > 0) {
				compilerSymbol tmp = symbolTable.findSymbol(entityName,currentScope(),tokens[1],symType.NEWDATATYPE);
				if (tmp != null) {
					line = line.replaceAll(tokens[0],"$" + tokens[1] + "->$" + tokens[2]);
				}
			}
			compilerSymbol tmp1 = symbolTable.findSymbol(entityName,currentScope(),line,symType.VARIABLE); // every NEWDATATYPE will have a matching VARIABLE
			if (tmp1 != null) {
				if (tmp1.isDynamic()) {
					line = "$" + line;
				}
			}
		
			String line1 = "";
			String unquotedLine = clearQuotedStrings(line);
			unquotedLine = unquotedLine.replaceAll("\\("," \\( ");
			unquotedLine = unquotedLine.replaceAll("\\)"," \\) ");
			unquotedLine = unquotedLine.replaceAll(";"," ; ");
			unquotedLine = unquotedLine.replaceAll("\\s{2,}"," ");
			unquotedLine = unquotedLine.trim();
			//displayDialog("PFA:"+unquotedLine);

			Vector v = supportFunctions.splitIntoTokens(unquotedLine," ");
			//displayDialog("PFA:Num:"+String.valueOf(v.size()));
			
			for (int i=0;i<v.size();i++) {
				String token = (String)v.elementAt(i);	
				token = token.trim();
				String indexString = "-1";
				compilerSymbol tmp = symbolTable.findSymbol(entityName,currentScope(),token); // used to be findsymbol2(...)
				if (tmp != null) {
					int bracketCount = 1; // 1 to count initial opening ( character
					indexString = "";
					String nextToken = (String)v.elementAt(i+1); // just peek at next token
					nextToken = nextToken.trim();
					if (nextToken.equals("(")) { // eat up all index string
						i = i + 2; // skip over opening ( token and point to next token
						do {
							if (i >= v.size()) {displayDialog("Index String Overflow");break;}
							nextToken = (String)v.elementAt(i++);
							if (nextToken.equals("(")) {bracketCount++;}
							if (nextToken.equals(")")) {bracketCount--;} 
							if (bracketCount == 0) {nextToken = "";} // clear nextToken so we don't add closing ) token
							indexString = indexString + nextToken + " ";
						} while (bracketCount != 0);
						indexString = processFuncArgs(indexString);
						// GDB 13/09/15 indexString = "eval(" + indexString + ")";
					}
					
					// some functions take the signal name, etc. as the parameter instead of its value
					// check for these cases ... note: some attributes work this way too ...
					
					switch (tmp.getSymbolType()) {
						case SIGNAL:
							token = "getSignal ( '" + entityName + "' , '" + token + "' , '" + indexString + "' )";
							break;
						case VARIABLE:
							token = "getVariable ( '" + entityName + "' , '" + token + "' , '" + indexString + "' )";
							break;
						case CONSTANT:
							token = "getConstant ( '" + entityName + "' , '" + token + "' , '" + indexString + "' )";
							break;
					}
				}
				line1 = line1 + token + " ";
			}
			line1 = line1.trim(); 
			TRACE("processFuncArgs:Exit:"+line1,4);
			return line1;
		}
		public int processTokens(String line,String keyword,Vector lineTokens,translationTableEntry entry) {
			Vector compilerTokens = entry.getTokens();
			Vector expComplierTokens = transTable.expandTokens(compilerTokens);
			//placeHolders = new Properties();
			// clear line only place holder list
			placeHolders.remove("*1");
			placeHolders.remove("*2");
			placeHolders.remove("*3");
			placeHolders.remove("*4");
			String debugLine = "";
			currentParameterName = "";
			currentParameterModifier = "";
			currentParameterType = "";
			currentParameterMode = "in";
			currentParameterDefault = "";
			currentParameterRet = 0;
			currentParameterPos = 1;
			int compilerTokenIndex,lineTokenIndex;
			boolean bNoTransText = false;
			loopLabels.clear();
			loopVariables.clear();
			
			TRACE("PT: line:"+line+" Keyword:"+keyword,4);
			
			// we do not want to include bracket characters inside strings!
			//if (strCount(line,'(') != strCount(line,')')) {
			//	setExErrorMsg("Missing ( or ) characters");
			//	return 0;
			//}
			
			if (getPassNumber() == 1 && !getCompileLine()) {
				compilerTokenIndex = 0;
				lineTokenIndex = 0;

				placeHolders.setProperty("*0","");
				placeHolders.setProperty("*8"," ");
				placeHolders.setProperty("*5","lineex");
				placeHolders.setProperty("*6",",");
				placeHolders.setProperty("*9",moduleName);
				
				Pattern p = Pattern.compile("(?i)entity (.*?) is");
				Matcher m = p.matcher(line);
				if (m.find()) {
					//moduleName = m.group(1);
					transFunctionPrefix = "entity";
				}
				p = Pattern.compile("(?i)package (.*?) is");
				m = p.matcher(line);
				if (m.find()) {
					//moduleName = m.group(1);
					transFunctionPrefix = "package";
				}
			} else {
				compilerTokenIndex = 0;
				lineTokenIndex = 0;

				placeHolders.setProperty("*0","");
				placeHolders.setProperty("*8"," ");
				placeHolders.setProperty("*5","lineex");
				placeHolders.setProperty("*6",",");
				placeHolders.setProperty("*9",moduleName);

				setExErrorMsg("");
				String lineEX = "";
				String lineEX1 = "";
				debugLine = "";
				String lineToken = "";
				String prevLineToken = "";
				String nextLineToken = "";
				String complierToken = "";
				if (!getCompileLine()) {
					compilerPHPFile.appendFile("\n");
					for (int i=0;i<indentionCount;i++) {
						compilerPHPFile.appendFile("\t");
					}
				}
				do {
					setExErrorMsg(""); // reset the extended error message
					lineToken = (String)lineTokens.elementAt(lineTokenIndex);
					TRACE("PT:Line Token:"+lineToken,4);
					if (lineTokenIndex>0) {prevLineToken = (String)lineTokens.elementAt(lineTokenIndex-1);} else {prevLineToken = lineToken;}
					if (lineTokenIndex<lineTokens.size()-1) {nextLineToken = (String)lineTokens.elementAt(lineTokenIndex+1);} else {nextLineToken = lineToken;}
//xxx					placeHolders.setProperty("*7",lineToken);
					//displayDialog("Line Token1:" + lineToken);
					if (lineToken.length() == 0) {lineTokenIndex++;continue;}
					// check for line labels
					if (lineTokenIndex == 0 && lineToken.endsWith(":")) {
						symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(getLineNumber()),symType.LABEL,symClass.NONE);
						if (!getCompileLine()) {compilerPHPFile.appendFile("/n" + lineToken + "/n");}
						lineTokenIndex++;
						if (lineTokenIndex < lineTokens.size()) {break;} else {continue;}
					}
					boolean bTokensMatch = false;
					int multiTransTextIndex = 0;
					
					//if (line.contains("if ")) {
					//	displayDialog("line:"+line);
					//	displayDialog("Previous file line: "+debugLine);
					//	displayDialog("Line token: "+lineToken);
					//	translationTableToken t = (translationTableToken)compilerTokens.elementAt(compilerTokenIndex);
					//	displayDialog("compiler token: "+t.getText());
					//}
					
					if (expComplierTokens.size() < compilerTokenIndex) {
						setExErrorMsg("Incomplete translation table entry");
						return lineTokenIndex;
					}
					translationTableToken token = null;
					try {
						token = (translationTableToken)expComplierTokens.elementAt(compilerTokenIndex);
					} catch (Exception e) {displayDialog("Caught A");}
					TRACE("PT:Compiler Token:"+token.getText(),4);
					Vector v = supportFunctions.splitIntoTokens(token.getText()," ");
					for (int j=0;j<v.size();j++) {
						Vector v1 = supportFunctions.splitIntoTokens((String)v.elementAt(j),"##",false);
						for (int k=0;k<v1.size();k++) {
							multiTransTextIndex = k;
							complierToken = (String)v1.elementAt(k);
							//displayDialog("Complier Token:" + complierToken);
							
							// if matching a complier token in a multi-group
							// only use 'break' if we have a match for the token
							// otherwise we will not go on and match the other complier
							// tokens in the multi-group
							
							if (complierToken.equals("*6")) {
								if (lineToken.equals(placeHolders.getProperty("*6"))) {
									bTokensMatch = true;
									break;
								}
							}
							if (complierToken.equals("integer")) {
								if (tokenizer.isNumeric(lineToken)) {
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Expected integer (got " + lineToken + ")");
								}
							}
							if (complierToken.equals("airtheng")) {
								String firstPart = "";
								String secondPart = "";
								String PHPCode = "";
								
								String newLine = "";
								for (int i=0;i<lineTokens.size();i++) {newLine = newLine + (String)lineTokens.elementAt(i) + " ";}
								String trimLine = newLine.trim();
								if (trimLine.contains(":=")) {
									// variable assignment
									
									String[] tokens = regMatchGroups(line,"((\\w+)\\s*:=\\s*new\\s*(.*));");
									if (tokens.length > 0) {
										symbolTable.addSymbol(entityName,currentScope(),tokens[1],tokens[2],symType.NEWDATATYPE,symClass.NONE);
										compilerSymbol tmp = symbolTable.findSymbol(entityName,currentScope(),tokens[2],symType.TYPE);
										if (tmp == null) { // built in type
											tokens[2] = "builtInType";
										}
										trimLine = trimLine.replaceAll(tokens[0],"$"+tokens[1]+":=new "+tokens[2]+"()");
									}
									
									int index = trimLine.indexOf(":=");
									firstPart = trimLine.substring(0,index-1);
									secondPart = trimLine.substring(index+2);
									if (symbolTable.findSymbol(entityName,currentScope(),firstPart,symType.VARIABLE) == null) {
										setExErrorMsg("Unrecognized variable (" + firstPart + ")");
										break;
									}
									
									secondPart = secondPart.replace("\"","'");
									
									ehsRegExp pp = new ehsRegExp();
									pp.regExpMatch(firstPart,"\\(.*\\)");
									String[] tokens1 = pp.getFoundStringsArray();
									for (int ii=0;ii<tokens1.length;ii++) {
										firstPart = firstPart.replace(tokens1[ii],"("+processFuncArgs(tokens1[ii].substring(1,tokens1[ii].length()-1))+")");
									}
									
									PHPCode = "processVariable(\"" + entityName + "\",\"" + firstPart + "\",\"" + processFuncArgs(secondPart) + "\");\n";
									if (!getCompileLine()) {compilerPHPFile.appendFile(PHPCode);} else {compiledLine=PHPCode;}								
								} else {
									// signal assignment
									int index = trimLine.indexOf("<=");
									firstPart = trimLine.substring(0,index-1);
									secondPart = trimLine.substring(index+2);
									//if (symbolTable.findSymbol(entityName,currentScope(),firstPart,symType.SIGNAL) == null) {
									//	setExErrorMsg("Unrecognized signal (" + firstPart + ")");
									//	break;
									//}
									
									// if line contains AFTER keyword make delayPart="delaysignal:time value:time unit" and remove from line
									String delayPart = "";
									ehsRegExp p = new ehsRegExp();
									p.regExpMatch(secondPart,"(?i)\\safter\\s(\\d+)(\\s*)(\\w+)\\s");
									String[] tokens,tokens1;
									tokens = p.getFoundGroupsArray();
									tokens1 = p.getFoundStringsArray();
									if (tokens.length > 0) {
										delayPart = "delaysignal:"+(String)tokens[0]+":"+(String)tokens[2];
										secondPart = secondPart.replace((String)tokens1[0]," ");
									}
									//if(delayPart.length() !=0) {displayDialog("Delayed Signal: " + delayPart);}
									
									secondPart = secondPart.replace("\"","'");
									
									ehsRegExp pp = new ehsRegExp();
									pp.regExpMatch(firstPart,"\\(.*\\)");
									tokens1 = pp.getFoundStringsArray();
									for (int ii=0;ii<tokens1.length;ii++) {
										firstPart = firstPart.replace(tokens1[ii],"("+processFuncArgs(tokens1[ii].substring(1,tokens1[ii].length()-1))+")");
									}

									PHPCode = "processSignal(\"" + entityName + "\",\"" + firstPart + "\",\"" + processFuncArgs(secondPart) + "\",\"" + delayPart + "\");\n";
									if (!getCompileLine()) {compilerPHPFile.appendFile(PHPCode);} else {compiledLine=PHPCode;}								
								}
								
								token.setTransText("");
								lineTokenIndex = lineTokens.size(); // because this processes all the line
								bTokensMatch = true;
							}
							if (complierToken.equals("paramspec")) {
								Vector values = supportFunctions.splitIntoTokens("signal,file,variable,constant",",");
								if (values.contains(lineToken)) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Expected signal/file/variable/constant (got " + lineToken + ")");
								}
								break;
							}
							if (complierToken.equals("deallocateptr")) {
								compilerSymbol cs = symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.NEWDATATYPE);
								if (cs != null) {
									symbolTable.deleteSymbol(entityName,currentScope(),lineToken,symType.NEWDATATYPE);
									bTokensMatch = true;
								} else {
									setExErrorMsg("Expected new data pointer (got " + lineToken + ")");
								}
								break;
							}
							if (complierToken.equals("timeunit")) {
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("filename")) {
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("filetype")) {
								if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.FILE) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Undefined file (" + lineToken + ")");								
								}
								break;
							}
							if (complierToken.equals("newfiletype")) {
								if (!isValidIdentifier(lineToken)) {setExErrorMsg(lineToken + " is not a valid filetype identifier");break;}
								if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.FILE,symClass.NONE) != null) {
									if (currentScope().equals(moduleName)) {
										//displayDialog("Added fclose A");
										endOfModuleLines.addElement("fclose($" + lineToken + ");");
									} else {
										//displayDialog("Added fclose b");
										endOfFuncLines.addElement("fclose($" + lineToken + ");");
									}
									bTokensMatch = true;
								} else {
									setExErrorMsg("File (" + lineToken + ") already defined");								
								}
								break;
							}
							if (complierToken.equals("newtypename")) {
								if (!isValidIdentifier(lineToken)) {setExErrorMsg(lineToken + " is not a valid typename identifier");break;}
								if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.TYPE,symClass.NONE) != null) {
									bTokensMatch = true;
									currentType = lineToken;
								} else {
									// will be already defined if an incomplete type
									//setExErrorMsg("Type (" + lineToken + ") already defined");								
								}
								break;
							}
							if (complierToken.equals("typename")) {
								if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.TYPE) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Undefined type (" + lineToken + ")");								
								}
								break;
							}
							if (complierToken.equals("funcdef")) {
								// eat tokens until we have the complete function defination
								String funcDef = lineToken;
								int obcount = 0;
								while (lineTokenIndex++ < lineTokens.size()-1) {
									lineToken = (String)lineTokens.elementAt(lineTokenIndex);
									funcDef = " " + funcDef + lineToken;
									//displayDialog("funcdef:"+funcDef+" ("+lineToken+")");
									if (lineToken.equals("(")) {obcount++;}
									if (lineToken.equals(")")) {
										obcount--;
										if (obcount>0) {continue;}
										// got complete function defination when this token is a ) and obcount=0
										bTokensMatch = true; 
										// need to set linetoken to be complete defination so can be written using *7 in transtext
										lineToken = funcDef;
										break;
									}
								}
								// if we get here we have run out of line tokens - an incomplete function defination
								if (!bTokensMatch) {setExErrorMsg("Incomplete function defination");}
								break;
							}
							if (complierToken.equals("statments")) {
								String stats = lineToken;
								// eat line tokens until we have the complete line
								while (lineTokenIndex++ < lineTokens.size()-1) {
									lineToken = (String)lineTokens.elementAt(lineTokenIndex);
									stats = " " + stats + lineToken;
								}
								//stats = processFuncArgs(stats); // because done in the compileLine(...) below
								displayDialog("statments in: " + stats); // debug line
								String PHPCode = compileLine(stats);
								displayDialog("statments out: " + PHPCode); // debug line
								if (PHPCode.length() == 0) {
									setExErrorMsg("Invalid statments - " + stats);
									return 0; // failure
								}
								compilerPHPFile.appendFile(PHPCode + "\n");
								return -1; // because we have finish processing the complete line
							}
							if (complierToken.equals("justfunctions")) {
								line = processFuncArgs(line);
								// replace any " in the line with \"
								line = line.replaceAll("\"","'");
								compilerPHPFile.appendFile("$hdlCode = composePHPCode(\"" + entityName + "\",\"" + line + "\");\neval(\"$hdlCode\");");
								bTokensMatch = true;
								return -1; // because we have finish processing the complete line
							}
							if (complierToken.equals("paramname")) {
								currentParameterName = lineToken;
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("typedef")) {
								String typeDef = lineToken;
								// eat line tokens until we have the complete type or the end of the line
								while (lineTokenIndex++ < lineTokens.size()-1) {
									lineToken = (String)lineTokens.elementAt(lineTokenIndex);
									if (lineToken.equals(";") || lineToken.equals(":=")) { // got complete type definition when next token is ; or :=
										if (typeDef.indexOf("record") != -1) {if (typeDef.indexOf("endrecord") == -1) {typeDef = typeDef + " " + lineToken;continue;}}
										bTokensMatch = true; 
										// need to set linetoken to be complete definition so can be written using *7 in transtext
										lineToken = processTypeDef(entityName,currentType,typeDef,currentScope());
										lineTokenIndex--;
										break;
									}
									typeDef = typeDef + " " + lineToken;
								}
								// if we get here we have run out of line tokens - an incomplete type definition
								if (!bTokensMatch) {setExErrorMsg("Incomplete type definition");}
								break;
							}
							if (complierToken.equals("vartype")) {
								String typeDef = lineToken;
								// eat line tokens until we have the complete type or the end of the line
								while (lineTokenIndex++ < lineTokens.size()-1) {
									lineToken = (String)lineTokens.elementAt(lineTokenIndex);
									if (lineToken.equals(";") || lineToken.equals(":=")) { // got complete type defination when next token is ; or :=
										bTokensMatch = true; 
										// need to set linetoken to be complete defination so can be written using *7 in transtext
										// 'currentSigVarConstantName' is set to the identifier of the signal, variable 
										// or constant we are defining and that identifier has already been added
										// to the symbol table and 'currentSigVarConstantType' has been set to
										// symType.SIGNAL, symType.VARIABLE or symType.CONSTANT. The previous two 
										// variables are set when processing the 'newsignalname', 'newvarname' 
										// or 'newconstname' compiler tokens.
										//displayDialog("vartype:"+typeDef);
										lineToken = processTypeUse(entityName,currentSigVarConstantName,typeDef,complierToken,currentScope(),currentSigVarConstantType);
										lineTokenIndex--;
										break;
									}
									typeDef = typeDef + " " + lineToken;
								}
								// if we get here we have run out of line tokens - an incomplete type defination
								if (!bTokensMatch) {setExErrorMsg("Incomplete type defination");}
								break;
							}
							if (complierToken.equals("paramtype")) { // need to eat tokens
								String typeDef = lineToken;
								// eat line tokens until we have the complete type or the end of the line
								int obcount = 0;
								while (lineTokenIndex++ < lineTokens.size()-1) {
									lineToken = (String)lineTokens.elementAt(lineTokenIndex);
									if (lineToken.equals("(")) {obcount++;}
									// for a ')' character to be a terminating character it must not be a closing
									// bracket matching any opening bracket in the type defination !!!
									if (lineToken.equals(";") || lineToken.equals(":=") || lineToken.equals(")")) { // got complete type defination when next token is ; or := or )
										if (lineToken.equals(")")) {
											if (obcount != 0) { // closing bracket is part of the type defination
												obcount--; 
												typeDef = typeDef + " " + lineToken;
												continue;
											} 
										}
										// need to set linetoken to be complete defination so can be written using *7 in transtext
										lineToken = processTypeUse(entityName,"",typeDef,complierToken,currentScope(),symType.NONE);
										lineTokenIndex--;
										break;
									}
									typeDef = typeDef + " " + lineToken;
								}
								currentParameterType = lineToken;
								bTokensMatch = true;
								// 
								if (lineToken.equals(":=")) {break;}
								String tmp;
								if (currentProcedureName.length() !=0 ) {tmp=currentProcedureName;} else {tmp=currentFunctionName;}
								signalFuncLines.insertElementAt("	createParameter('"+moduleName+"','"+tmp+"','"+currentParameterName+"','"+currentParameterType+"',"+Integer.toString(currentParameterPos)+",'"+currentParameterMode+"',"+Integer.toString(currentParameterRet)+",0,0,'"+currentParameterDefault+"');",1);
								currentParameterName = "";
								currentParameterType = "";
								currentParameterMode = "in";
								currentParameterDefault = "";
								currentParameterRet = 0;
								currentParameterPos++;
								break;
							}
							if (complierToken.equals("parammode")) {
								if (lineToken.equals("in") || lineToken.equals("out") || lineToken.equals("inout")) {
									currentParameterMode = lineToken;
									bTokensMatch = true;
								} else {
									setExErrorMsg("Invalid parameter mode (" + lineToken + ")");
								}
								break;
							}
							if (complierToken.equals("paramrettype")) {
								currentParameterRet = 1;
								currentParameterName = lineToken; // do not clear parameter data block until you process endfuction							
								signalFuncLines.insertElementAt("	createParameter('"+moduleName+"','"+currentFunctionName+"','"+currentParameterName+"','"+"xxx"+"',"+Integer.toString(0)+",'"+"xxx"+"',"+Integer.toString(currentParameterRet)+",0,0,'"+currentParameterDefault+"');",1);
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("paramdefault")) {
								if (currentParameterType.length()==0) {continue;}
								currentParameterDefault = lineToken;							
								String tmp;
								if (currentProcedureName.length() !=0 ) {tmp=currentProcedureName;} else {tmp=currentFunctionName;}
								signalFuncLines.insertElementAt("	createParameter('"+moduleName+"','"+tmp+"','"+currentParameterName+"','"+currentParameterType+"',"+Integer.toString(currentParameterPos)+",'"+currentParameterMode+"',"+Integer.toString(currentParameterRet)+",0,0,'"+currentParameterDefault+"');",1);
								currentParameterName = "";
								currentParameterType = "";
								currentParameterMode = "in";
								currentParameterDefault = "";
								currentParameterRet = 0;
								currentParameterPos++;
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("parammodifier")) {
								currentParameterModifier = lineToken;							
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("pfstring")) {
								lineToken = processFuncArgs(lineToken);
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("string")) {
								if ((lineToken.charAt(0) == '\"') && lineToken.charAt(lineToken.length()-1) == '\"')  {
									lineToken = lineToken.substring(1,lineToken.length()-1);
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Invalid string (" + lineToken + ")");
								}
							}
							if (complierToken.equals("whilecondstr")) {
								compilerSymbol tmp = symbolTable.findSymbol(entityName,currentScope(),lineToken); // used to be findsymbol2(...)
								if (tmp != null) {
									switch (tmp.getSymbolType()) {
										case SIGNAL:
											lineToken = "getSymbol ( '"+entityName+"' , '"+lineToken+"' )";
										break;
										case VARIABLE:
											lineToken = "getVariable ( '"+entityName+"' , '"+lineToken+"' )";
										break;
										case CONSTANT:
											lineToken = "getConstant ( '"+entityName+"' , '"+lineToken+"' )";
										break;
									}
								}
								lineToken = lineToken.replaceAll("=","==");
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("uqstring")) {
								if (!tokenizer.isReserved(lineToken)) {							
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Invalid uqstring (" + lineToken + ")");
								}
							}
							if (complierToken.equals("character")) {
								if (lineToken.length() == 3 && lineToken.charAt(0) == '\'' && lineToken.charAt(lineToken.length()-1) == '\'')  {
									lineToken = lineToken.substring(1,lineToken.length()-1);
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Invalid character (" + lineToken + ")");
								}
							}
							if (complierToken.equals("dontcare")) {
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("<")) {
								if (lineToken.equals("<")) {
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Expected < (got " + lineToken + ")");
								}
							}
							if (complierToken.equals(">")) {
								if (lineToken.equals(">")) {
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Expected > (got " + lineToken + ")");
								}
							}
							if (complierToken.equals("comma")) {
								if (lineToken.equals(",")) {
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Expected , (got " + lineToken + ")");
								}
							}
							if (complierToken.equals("text")) {
								if (lineToken.equals("text")) {
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Expected text (got " + lineToken + ")");
								}
							}
							if (complierToken.equals("enumtype")) {
								compilerSymbol cs = symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.TYPE);
								if (cs != null) {
									writeDirectToOutput("");
									bTokensMatch = true;
									break;
								} else {
									setExErrorMsg("Expected enumtype (got " + lineToken + ")");
								}
							}
							if (complierToken.equals("intvarname")) {
								if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.VARIABLE) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Undefined integer variable (" + lineToken + ")");								
								}
//								break;
							}
							if (complierToken.equals("stringvarname")) {
								if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.VARIABLE) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Undefined string variable (" + lineToken + ")");								
								}
//								break;
							}
							if (complierToken.equals("newintvarname")) {
								if (!isValidIdentifier(lineToken)) {setExErrorMsg(lineToken + " is not a valid intvarname identifier");break;}
								if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.VARIABLE,symClass.NONE) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Variable (" + lineToken + ") already defined");								
								}
								break;
							}
							if (complierToken.equals("newstringvarname")) {
								if (!isValidIdentifier(lineToken)) {setExErrorMsg(lineToken + " is not a valid stringvarname identifier");break;}
								if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.VARIABLE,symClass.NONE) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Variable (" + lineToken + ") already defined");								
								}
								break;
							}
							if (complierToken.equals("varname")) {
								if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.VARIABLE) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Undefined variable (" + lineToken + ")");								
								}
//								break;
							}
							if (complierToken.equals("newvarname")) {
								if (!isValidIdentifier(lineToken)) {setExErrorMsg(lineToken + " is not a valid varname identifier");break;}
								if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.VARIABLE,symClass.NONE) != null) {
									bTokensMatch = true;
									currentSigVarConstantName = lineToken;
									currentSigVarConstantType = symType.VARIABLE;
								} else {
									setExErrorMsg("Variable (" + lineToken + ") already defined");								
								}
								break;
							}
							if (complierToken.equals("constname")) {
								if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.CONSTANT) != null) {
									bTokensMatch = true;
								} else {
									setExErrorMsg("Undefined constant (" + lineToken + ")");								
								}
//								break;
							}
							if (complierToken.equals("newconstname")) {
								if (!isValidIdentifier(lineToken)) {setExErrorMsg(lineToken + " is not a valid constname identifier");break;}
								if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.CONSTANT,symClass.NONE) != null) {
									bTokensMatch = true;
									currentSigVarConstantName = lineToken;
									currentSigVarConstantType = symType.CONSTANT;
								} else {
									setExErrorMsg("Constant (" + lineToken + ") already defined");								
								}
								break;
							}
							if (complierToken.equals("constval")) {
								compilerSymbol tmp = symbolTable.findSymbol(entityName,currentScope(),currentSigVarConstantName,symType.CONSTANT);
								tmp.setSymbolValue(lineToken);
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("newentityid")) {
								entityName = lineToken;
								if (isValidIdentifier(lineToken)) {
										//displayDialog("Added newentityid " + entityName+","+currentScope()+","+lineToken);
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.ENTITY,symClass.NONE) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Entity (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid entityid identifier");}
							}
							if (complierToken.equals("newpackageid")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.PACKAGE,symClass.NONE) != null) {
										bTokensMatch = true;
										//displayDialog("Added newpackageid " + entityName+","+currentScope()+","+lineToken);
									} else {
										setExErrorMsg("Package (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid package identifier");}
							}
							if (complierToken.equals("newarchname")) {
								archName = lineToken;
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.ARCH,symClass.NONE) != null) {
										//displayDialog("Added newarchname " + entityName+","+currentScope()+","+lineToken);
										endOfModuleLines.removeAllElements();
										bTokensMatch = true;
									} else {
										setExErrorMsg("Architecture (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid archname identifier");}
							}
							if (complierToken.equals("archname")) {
								if (isValidIdentifier(lineToken)) {
									//displayDialog("end archname - " + entityName+","+currentScope()+","+lineToken);
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.ARCH) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined architecture (" + lineToken + ")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid archname identifier");}
							}
							if (complierToken.equals("entityid")) {
								if (isValidIdentifier(lineToken)) {
									//displayDialog("end entityid - " + entityName+","+currentScope()+","+lineToken);
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.ENTITY) != null) {
										//displayDialog("Found entityid");
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined entity (" + lineToken + ")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid entityid identifier");}
							}
							if (complierToken.equals("packageid")) {
								if (isValidIdentifier(lineToken)) {
									//displayDialog("end packageid - " + entityName+","+currentScope()+","+lineToken);
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.PACKAGE) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined package (" + lineToken + ")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid packageid identifier");}
							}
							if (complierToken.equals("endarchname")) {
								if (isValidIdentifier(lineToken)) {
									//displayDialog("end archname - " + entityName+","+currentScope()+","+lineToken);
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.ARCH) != null) {
										bTokensMatch = true;
										for (int jj=0;jj<endOfModuleLines.size();jj++) {
											compilerPHPFile.appendFile((String)endOfModuleLines.elementAt(jj)+"\n");									
										}
										endOfModuleLines.removeAllElements();
									} else {
										setExErrorMsg("Undefined end architecture (" + lineToken + ")");
										continue;
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid archname identifier");}
							}
							if (complierToken.equals("endentityid")) {
								if (isValidIdentifier(lineToken)) {
									//displayDialog("end entityid - " + entityName+","+currentScope()+","+lineToken);
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.ENTITY) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined end entity (" + lineToken + ")");								
										continue;
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid entityid identifier");}
							}
							if (complierToken.equals("endpackageid")) {
								if (isValidIdentifier(lineToken)) {
									//displayDialog("end packageid - " + entityName+","+currentScope()+","+lineToken);
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.PACKAGE) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined end package (" + lineToken + ")");	
										continue;
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid packageid identifier");}
							}
							if (complierToken.equals("newprocessname")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.PROCESS,symClass.NONE) != null) {
										endOfFuncLines.removeAllElements();
										currentProcessName = lineToken;
										bTokensMatch = true;
									} else {
										setExErrorMsg("Process (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid processname identifier");}
							}
							if (complierToken.equals("processname")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.PROCESS) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined process (" + lineToken + ")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid processname identifier");}
							}
							if (complierToken.equals("functionname")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.FUNCTION) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined function (" + lineToken + ")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid functionname identifier");}
							}
							if (complierToken.equals("newfunctionname")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,"",symType.FUNCTION,symClass.NONE) != null) {
										endOfFuncLines.removeAllElements();
										currentFunctionName = lineToken;
										bTokensMatch = true;
									} else {
										setExErrorMsg("Function (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid functionname identifier");}
							}
							if (complierToken.equals("procedurename")) {
								if (isValidIdentifier(lineToken)) {
									//displayDialog("Finding procedure procedure:"+entityName+","+currentScope()+","+lineToken);
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.PROCEDURE) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined procedure (" + lineToken + ")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid procedurename identifier");}
							}
							if (complierToken.equals("newprocedurename")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,"",symType.PROCEDURE,symClass.NONE) != null) {
										//displayDialog("Added procedure:"+entityName+","+currentScope()+","+lineToken);
										endOfFuncLines.removeAllElements();
										currentProcedureName = lineToken;
										bTokensMatch = true;
									} else {
										setExErrorMsg("Procedure (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid procedurename identifier");}
							}
							if (complierToken.equals("newcomponentname")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.COMPONENT,symClass.NONE) != null) {
										componentDefName = lineToken;
										bTokensMatch = true;
									} else {
										setExErrorMsg("Component (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid componentname identifier");}
							}
							if (complierToken.equals("componentname")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.COMPONENT) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined component (" + lineToken + ")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid componentname identifier");}
							}
							if (complierToken.equals("newcomponentid")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.COMPONENTID,symClass.NONE) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Componentid (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid componentid identifier");}
							}
							if (complierToken.equals("componentid")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.COMPONENTID) != null) {
										bTokensMatch = true;
									} else {
										setExErrorMsg("Undefined componentid ("+lineToken+":"+entityName+":"+currentScope()+")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid componentid identifier");}
							}
							if (complierToken.equals("signalname")) {
								if (isValidIdentifier(lineToken)) {
									if(lineToken.equals("others") || lineToken.equals("all")) {bTokensMatch = true;break;}
									if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.SIGNAL) != null) {
										bTokensMatch = true;
										//displayDialog("sig matched");
									} else {
										setExErrorMsg("Undefined signal ("+lineToken+":"+entityName+":"+currentScope()+")");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid signal identifier");}
							}
							if (complierToken.equals("gsignalname")) {
								if (isValidIdentifier(lineToken)) {
									if(lineToken.equals("others") || lineToken.equals("all")) {bTokensMatch = true;break;}
									if (symbolTable.findSymbol(entityName,entityName,lineToken,symType.SIGNAL) != null) {
										bTokensMatch = true;
										//displayDialog("sig matched");
										break;
									} else {
										setExErrorMsg("Undefined signal ("+lineToken+":"+entityName+":"+currentScope()+")");								
									}
									//break;
								} else {setExErrorMsg(lineToken + " is not a valid signal identifier");}
							}
							if (complierToken.equals("signamenocheck")) {
								if (isValidIdentifier(lineToken)) {
									//if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.SIGNAL) != null) {
										bTokensMatch = true;
										//displayDialog("sig matched");
									//} else {
										//setExErrorMsg("Undefined signal ("+lineToken+":"+entityName+":"+currentScope()+")");								
									//}
									//break;
								} else {setExErrorMsg(lineToken + " is not a valid signal identifier");}
							}
							if (complierToken.equals("signamenocheck1")) {
								if (isValidIdentifier(lineToken)) {
									//if (symbolTable.findSymbol(entityName,currentScope(),lineToken,symType.SIGNAL) != null) {
										bTokensMatch = true;
										//displayDialog("sig matched");
									//} else {
										//setExErrorMsg("Undefined signal ("+lineToken+":"+entityName+":"+currentScope()+")");								
									//}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid signal identifier");}
							}
							if (complierToken.equals("newsignalname")) {
								if (isValidIdentifier(lineToken)) {
									if (symbolTable.addSymbol(entityName,currentScope(),lineToken,String.valueOf(0),symType.SIGNAL,symClass.NONE) != null) {
										bTokensMatch = true;
										currentSigVarConstantName = lineToken;
										currentSigVarConstantType = symType.SIGNAL;
									} else {
										setExErrorMsg("Signal (" + lineToken + ") already defined");								
									}
									break;
								} else {setExErrorMsg(lineToken + " is not a valid signalname identifier");}
							}
							if (complierToken.equals("useentity") && lineToken.equals("useentity")) {
								//displayDialog("use entity line - " + line);
								Pattern p = Pattern.compile("(?i)work\\s\\.\\s(.*?)\\s\\("); // GDB 25/10/15 old pattern (?i)work\\.(.*?)\\(
								Matcher m = p.matcher(line);
								if (m.find()) {
									//displayDialog("Add extra compile file " + m.group(1));
									//extraCompileFiles.addElement(""+dataRelativePath+"/hdlworkbench/vhdlfiles/" + m.group(1) + "." + getFileExt());
									extraCompileFiles.addElement("vhdlfiles/" + m.group(1) + "." + getFileExt()); // GDB 090716
								}
								return -1; // because we have finish processing the complete line
							}
							if (complierToken.equals("port") && lineToken.equals("port")) {
								//displayDialog("component port def");
								Pattern p = Pattern.compile("(?i)\\((.*?)\\)");
								Matcher m = p.matcher(line);
								if (m.find()) {
									//displayDialog("store port: " + m.group(1) + " for component: " + componentDefName);
									if (componentDefName.length() != 0) { // port statement for a VHDL 'component'
										componentPorts.setProperty(componentDefName,m.group(1));
									} else { // port statement for an VHDL 'entity'
										Vector v2 = supportFunctions.splitIntoTokens(m.group(1),";");
										for (int i=0;i<v2.size();i++) {
											String signalName = (String)v2.elementAt(i);
											String modetype = signalName.substring(signalName.indexOf(':')+1);
											signalName = signalName.substring(0,signalName.indexOf(':'));
											signalName = signalName.trim(); // GDB 160815
											modetype = modetype.trim();  // GDB 160815
											//displayDialog("port:"+signalName+":"+modetype+":"+currentScope());
											symbolTable.addSymbol(entityName,currentScope(),signalName,String.valueOf(0),symType.SIGNAL,symClass.NONE);
											// Every thing after 1st space is the type
											String mode = modetype.substring(0,modetype.indexOf(' '));
											String type = modetype.substring(modetype.indexOf(' ')+1);
											type = processTypeUse(entityName,"",type,complierToken,currentScope(),symType.NONE);
											signalFuncLines.insertElementAt("	" + "createSignal(\""+entityName+"\",\""+currentScope()+"\",\""+signalName+"\",\""+mode+"\",\""+type+"\",1,\"0\");",1);
											portDefLines.addElement(entityName+","+currentScope()+","+signalName+","+mode+","+type+",1,0");
										}
									}
								}
								return -1; // because we have finish processing the complete line
							}
							if (complierToken.equals("portmap") && lineToken.equals("portmap")) {
								Pattern p = Pattern.compile("(?i)\\:(.*?)port");
								Matcher m = p.matcher(line);
								if (m.find()) {
									//displayDialog("got component name: " + m.group(1).trim());
									Pattern p1 = Pattern.compile("(?i)\\((.*?)\\)");
									Matcher m1 = p1.matcher(line);
									if (m1.find()) {
										String tmp = componentPorts.getProperty(m.group(1).trim());
										//displayDialog("got port: " + tmp);
										signalFuncLines.insertElementAt("	" + "createSSMap(\""+m.group(1).trim()+"\",\""+tmp+"\",\""+entityName+"\",\""+m1.group(1)+"\");",1);
										portmapDefLines.addElement(m.group(1).trim()+","+tmp+","+entityName+","+m1.group(1));
									}
								}
								return -1; // because we have finish processing the complete line
							}
							if (tokenizer.isSyntax(complierToken)) {
								if (complierToken.equals(lineToken)) {
									//displayDialog("CT: " + complierToken + " LT: " + lineToken);
									bTokensMatch = true;
									break;
								}
							}
							if (complierToken.equals("endif") && lineToken.equals("endif")) {
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("endloop") && lineToken.equals("endloop")) {
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("endfunction") && lineToken.equals("endfunction")) {
								if (currentParameterName.length() != 0) {
									compilerPHPFile.appendFile("return $" + currentParameterName + ";\n");
									currentParameterName = "";
									currentParameterType = "";
									currentParameterMode = "in";
									currentParameterDefault = "";
									currentParameterRet = 0;
									currentParameterPos = 0;								
								}
								
								for (int jj=0;jj<endOfFuncLines.size();jj++) {
									compilerPHPFile.appendFile((String)endOfFuncLines.elementAt(jj)+"\n");									
								}
								endOfFuncLines.removeAllElements();
								
								currentFunctionName = "";
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("endprocedure") && lineToken.equals("endprocedure")) {
								//displayDialog("endprocedure");
								for (int jj=0;jj<endOfFuncLines.size();jj++) {
									compilerPHPFile.appendFile((String)endOfFuncLines.elementAt(jj)+"\n");
									//displayDialog("LL: " + (String)endOfFuncLines.elementAt(jj));
								}
								endOfFuncLines.removeAllElements();
								
								currentProcedureName = "";
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("endcomponent") && lineToken.equals("endcomponent")) {
								componentDefName = "";
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("endprocess") && lineToken.equals("endprocess")) {
								for (int jj=0;jj<endOfFuncLines.size();jj++) {
									compilerPHPFile.appendFile((String)endOfFuncLines.elementAt(jj)+"\n");									
								}
								endOfFuncLines.removeAllElements();
								
								currentProcessName = "";
								bTokensMatch = true;
								break;
							}
							if (complierToken.equals("endcase") && lineToken.equals("endcase")) {
								bTokensMatch = true;
								break;
							}
							// must always be last test
							if (tokenizer.isReserved(complierToken)) {
								if (complierToken.equals(lineToken)) {
									bTokensMatch = true;
									break;
								}
							}
						} // end of split '##' loop
					
						if (!bTokensMatch) {
							// first check to see if this is an optional token, yes ignore it
							bNoTransText = false;
							String flags = token.getFlags();
							if (flags.length() != 0) {
								Vector v5 = supportFunctions.splitIntoTokens(flags,"##",false);
								String tmp = (String)v5.elementAt(multiTransTextIndex);
								if (tmp.startsWith("z")) {
									setExErrorMsg(""); // clear any multi token error messages on a successful token match
									lineTokenIndex--;
									bTokensMatch = true;
									bNoTransText = true;
									TRACE("Above complier token optional - not included in input line",4);
								}
							}
							
							if (!bTokensMatch) { // if token is not optional
								if(getExErrorMsg().length() == 0) {setExErrorMsg("Unrecognized Token (line:"+lineToken+" compiler:"+complierToken+")");}
								return lineTokenIndex;
							}
						} else {
							bNoTransText = false;
							setExErrorMsg(""); // clear any multi token error messages on a sucessful token match
						}
						
						placeHolders.setProperty("*7",lineToken);
						String transText = token.getTransText();
//						if (bNoTransText) {transText = "";}
						if (transText.length() != 0) {
							//displayDialog("tt: " + transText);
							Vector v2 = supportFunctions.splitIntoTokens(transText," ");
							Vector v3 = supportFunctions.splitIntoTokens((String)v2.elementAt(j),"##",false);
							transText = (String)v3.elementAt(multiTransTextIndex);
							
							// don't care about trans text marker
							if (transText.equals("x") || transText.equals("*1") || transText.equals("*2") || transText.equals("*3") || transText.equals("*4") || transText.equals("*e") || transText.equals("*f") || transText.equals("*g") || transText.equals("*h")) {bNoTransText=true;}
							
							// place holder logic, remember place holder *9 is the moduleName
							boolean bClearTransText = false;
							ehsRegExp p = new ehsRegExp();
							p.regExpMatch(transText,"\\*[\\dabcdefghi]");
							String[] tokens;
							tokens = p.getFoundStringsArray();
							for (int phs=0;phs<tokens.length;phs++) {
								
								// if you add more place holders update the regexp above
								String tmp = "";
								if (tokens[phs].equals("*a")) {
									tmp = "";
								} else if (tokens[phs].equals("*b")) {
									tmp = currentScope();
								} else if (tokens[phs].equals("*c")) {
									tmp = "";
								} else if (tokens[phs].equals("*d")) {
									tmp = "::";
								} else if (tokens[phs].equals("*i")) {
									bClearTransText = true;
								} else {
									tmp = placeHolders.getProperty(tokens[phs]);
								}
								//displayDialog("t:"+tokens[phs]+" tmp:"+tmp);
								// tmp wil be null if say there is currently no property set for
								// say *1, so set it to the current linetoken
								if (tmp == null) {
									placeHolders.setProperty(tokens[phs],lineToken);
									tmp = lineToken;
								}
								// the *5 place holder (lineex) is only to add to an internal list
								if (tmp.equals("lineex")) {
									if (lineEX1.length() != 0) {lineEX1=lineEX1+",";}
									lineEX1 = lineEX1 + lineToken;
									//tmp = lineToken;
									tmp = "";
								}
								// and then the line token is added back into the trans string
								transText = transText.replace(tokens[phs],tmp);
							}
							
							// update special place holder *0 if needed
							if (transText.equals("<") || transText.equals("<=")) {
								placeHolders.setProperty("*0","++");
								transText = transText.replace("*0","++");
							}
							if (transText.equals(">") || transText.equals(">=")) {
								placeHolders.setProperty("*0","--");
								transText = transText.replace("*0","--");
							}

							if (bNoTransText) {transText = "";}
							
							if (transText.contains("{")) {indentionCount++;}
							if (transText.contains("}")) {indentionCount--;}
							
							// this if statement is on its own because we also have to append to compiler file !!!
							if (keyword.equals("process")) {
								if (lineEX1.length() != 0) {
									lineEX1 = lineEX1.replaceAll(",{2,}",",");
								}
								lineEX = "addProcessName(\""+moduleName+"\",\""+currentProcessName+"\",\""+lineEX1+"\");";
							}
							
							if (keyword.equals("force") || keyword.equals("forceperiod") || keyword.equals("port")) {
								lineEX = lineEX + transText;
							} else {
								if (!getCompileLine()) {
									//displayDialog("tt:"+transText);
									if (bClearTransText) {compilerPHPFile.removeLastFileLine();} else {compilerPHPFile.appendFile(transText);}
								} else {
									compiledLine=transText;
								}
								
								debugLine = debugLine + transText;

							}
						} else {
							//displayDialog("No Trans Text");
						}

						if (j != v.size()-1) {
							try {
								lineToken = (String)lineTokens.elementAt(++lineTokenIndex);
							} catch (Exception e) {displayDialog("Caught B");}
							//displayDialog("Line Token2:" + lineToken);
						}
					} // end of split ' ' loop
					
					String flags = token.getFlags();
					if (flags.length() != 0) {
						//displayDialog("Flags:"+flags);
						Vector v4 = supportFunctions.splitIntoTokens(flags,"##",false);
						String tmp = "";
						try {
							tmp = (String)v4.elementAt(multiTransTextIndex);
						} catch (Exception e) {	displayDialog("Token flag mismatch");}
						if (tmp.startsWith("y")) {
							break; // finish processing line
						}
						if (tmp.startsWith("z")) {
							//if (!bTokensMatch) {lineTokenIndex--;} // ignore optional token only on a non token match
						}
						if (tmp.startsWith("r")) {
							try {
								int adjust = Integer.parseInt(tmp.substring(1));
								compilerTokenIndex = compilerTokenIndex + adjust;
							} catch (Exception e) {}
						} else {
							compilerTokenIndex++;
						}	
					} else {
						compilerTokenIndex++;
					}
					
					lineTokenIndex++;

				} while( (lineTokenIndex < lineTokens.size()) && (compilerTokenIndex < expComplierTokens.size()) ); // end of lineTokens for loop
				
				if (keyword.equals("force") || keyword.equals("forceperiod") || keyword.equals("port")) {
						signalFuncLines.insertElementAt("	"+lineEX,1);
				} else if (keyword.equals("process")) {
						forcesFuncLines.insertElementAt("	"+lineEX,1);
						Vector vv = supportFunctions.splitIntoTokens(lineEX1,",");
						for (int m=0;m<vv.size();m++) {
							forcesFuncLines.insertElementAt("	"+"createSPMap(\""+moduleName+"\",\""+currentProcessName+"\",\""+(String)vv.elementAt(m)+"\");",1);
						}
				} 
			} // end of passNumber if statement
			compilerPHPFile.appendFile(entry.getpostEntryString());
			return -1; // for success
		}
		public String currentScope() {
			if (currentFunctionName.length()==0) {
				if (currentProcedureName.length()==0) {
					if (currentProcessName.length()==0) {
						return moduleName;
					} else {return currentProcessName;}
				} else {return currentProcedureName;}
			} 
		
			return currentFunctionName;
		}
	}
	
 	public class VerilogCompiler extends HDLCompiler {
		private	pseduoFile	compilerPHPFile;
		private	String		currentParameterName;
		private	String		currentParameterModifier;
		private	String		currentParameterType;
		private	String		currentParameterMode;
		private	String		currentParameterDefault;
		private	int		currentParameterRet;
		private	int		currentParameterPos;
		protected VerilogcompilerTokens tokenizer;
		protected String	compiledLine = "";

		public VerilogCompiler() {
			super(VerilogTransTableName);
			tokenizer = new VerilogcompilerTokens();
			tokenizer.setReservedWords(VerilogReservedWords);
			tokenizer.setTypes(VerilogTypes);
			setVarPreDefined(true);
			setCommentString("////");
			setStartMultiLineCommentString("//*");
			setEndMultiLineCommentString("*//");
			
			currentParameterName = "";
			currentParameterModifier = "";
			currentParameterType = "";
			currentParameterMode = "in";
			currentParameterDefault = "";
			currentParameterRet = 0;
			currentParameterPos = 1;
		}
		public String compileLine(String line) {
			String PHPCode = "";
			setCompileLine(true);
			Vector lines = supportFunctions.splitIntoTokens(line,";");
			for (int lineNumber=0;lineNumber<lines.size();lineNumber++) {
				compiledLine = "";
				if(!syntaxCheck((String)lines.elementAt(lineNumber))) {return "";}
				PHPCode = PHPCode + compiledLine;
			}
			setCompileLine(false);
			return PHPCode;
		}
		//public String getEntityName() {return entityName;}
		public boolean isValidIdentifier(String ident) {
			if (tokenizer.isReserved(ident)) {return false;}
			return isValidID(ident);
		}
		public boolean syntaxCheck(String line) {
			Vector v = tokenizer.tokenizeLine(line);
			syntaxError = "";
			return syntaxCheckInternal(line,v);
		}
		public String getKeywordFromLine(Vector tokens) {
			if (tokens.size() == 0) {return "";}
			// default case first token on line unless first token is a line label
			String tmp = (String)tokens.elementAt(0);
			String tmp1 = (String)tokens.elementAt(1);
			if (tmp1.equals(":")) {
				tokens.setElementAt((String)tokens.elementAt(0)+":",0);
				tokens.setElementAt("",1);
				if (tokens.size() > 2) {
					tmp =  (String)tokens.elementAt(2);
				} else {
					return "linelabel";
				}
			}

			return tmp;
		}
		public boolean syntaxCheckInternal(String line,Vector tokens) {
//			displayDialog("Verilog Syntax Check Internal Line : " + line);

			// delete the NYS keywords
			for (int i=0;i<VerilogNYSWords.length;i++) {
				tokens.removeElement(VerilogNYSWords[i]);
			}
	
			// get the Verilog keyword from the line
			String keyword = getKeywordFromLine(tokens);
			
			// process the line using the translation table entry defined by the above keyword
			int status = processLine(line,keyword,tokens);
			if (status != -1) {
				setErrorString("Line:" + String.valueOf(getLineNumber()+1)+" " + line,(String)tokens.elementAt(status));
				return false;
			}
			return true;
		}
		public String getName() {return "Verilog";}
		public String getFileExt() {return "vlog";}
		public String currentScope() {return "";}
		public boolean preCompile(String filename,boolean bHeaders) {
			indentionCount = 0;
			
			if (bHeaders) {
			
			symbolTable.removeAllSymbols();
			transTable = new translationTable();
			transTable.loadTranslationTable(transTableName);
//			compilerPHPFile = new ehsFile("../hdlworkbench/output",supportFunctions.getFilenameNoExt(filename) + ".php");
			compilerPHPFile = new pseduoFile(""+dataRelativePath+"/"+appDirectory+"/output",supportFunctions.getFilenameNoExt(filename) + ".php");
			compilerPHPFile.saveFile("<html>\n<head>"); // saveFile used to remove any existing file
			if(systemUserReg.getAppRemotedHosted()) {
				compilerPHPFile.appendFile("\n<script src=\""+appBaseURL+"/website/scripts/common.js\" type=\"text/javascript\"></script>");
				compilerPHPFile.appendFile("\n<script src=\""+appBaseURL+"/website/scripts/jquery-1.9.0.js\" type=\"text/javascript\"></script>");
				compilerPHPFile.appendFile("\n<link rel=\"stylesheet\" href=\""+appBaseURL+"/website/css/ehs_default.css\" type=\"text/css\" media=\"screen\">");
			} else {
				compilerPHPFile.appendFile("\n<script src=\"../../../../../development/website/scripts/common.js\" type=\"text/javascript\"></script>");
				compilerPHPFile.appendFile("\n<script src=\"../../../../../development/website/scripts/jquery-1.9.0.js\" type=\"text/javascript\"></script>");
				compilerPHPFile.appendFile("\n<link rel=\"stylesheet\" href=\"../../../../../development/website/css/ehs_default.css\" type=\"text/css\" media=\"screen\">");
			}
			compilerPHPFile.appendFile("\n</head>\n<body>");
			compilerPHPFile.appendFile("\n<?");
			if(!systemUserReg.getAppRemotedHosted()) {
				compilerPHPFile.appendFile("\ninclude(\"../../../../../development/website/scripts/common.php\");");
			} else {
				compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/website/scripts/common.php\");");
			}
			// has to be before the line that includes simlib.php as this files will set it to a default of "" if not already set
			compilerPHPFile.appendFile("\n$langkeywords = \""+VerilogReservedWords+"\";\n");
			if(!systemUserReg.getAppRemotedHosted()) {
				compilerPHPFile.appendFile("\ninclude(\"../support/simlib.php\");");
				compilerPHPFile.appendFile("\ninclude(\"../support/verilogstandardfuncs.php\");");
			} else {
				compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/website/hdlworkbench/support/simlib.php\");");
				compilerPHPFile.appendFile("\ninclude(\""+appBaseURL+"/website/hdlworkbench/support/verilogstandardfuncs.php\");");
			}
			compilerPHPFile.appendFile("\n$link = mysqlConnect();");
			}

			// clear compile place holder list
			placeHolders.remove("*e");
			placeHolders.remove("*f");
			placeHolders.remove("*g");
			placeHolders.remove("*h");

			return true;
		}
		public boolean postCompile(String filename,boolean bHeaders) {
			if (bHeaders) {
			compilerPHPFile.appendFile("\nsimulate($_GET[\"entity\"]);\nmysql_close($link);\n?>");
			compilerPHPFile.appendFile("\n</body>\n</html>\n");
			compilerPHPFile.flush();
			}
			return true;
		}
		public boolean betweenPassProcesses() {
			if (bProcessHeaders) {
				compilerPHPFile.appendFile("\nfunction internalSimulate($module) {" + moduleName + "();}\n");
			}
			return true;
		}
		public boolean completeLine(String line) {return true;}
		public int processTokens(String line,String keyword,Vector lineTokens,translationTableEntry entry) {
			Vector compilerTokens = entry.getTokens();
			boolean bNoTransText = false;
			
//			displayDialog("Verilog Process tokens for keyword : " + keyword);

			//placeHolders = new Properties();
			// clear line only place holder list
			placeHolders.remove("*1");
			placeHolders.remove("*2");
			placeHolders.remove("*3");
			placeHolders.remove("*4");
			
			Vector expComplierTokens = transTable.expandTokens(compilerTokens);

			currentParameterName = "";
			currentParameterModifier = "";
			currentParameterType = "";
			currentParameterMode = "in";
			currentParameterDefault = "";
			currentParameterRet = 0;
			currentParameterPos = 1;
			
			int compilerTokenIndex,lineTokenIndex;
			
			if (strCount(line,'(') != strCount(line,')')) {
				setExErrorMsg("Missing ( or ) characters");
				return 0;
			}
			
			if (getPassNumber() == 1) {
				compilerTokenIndex = 0;
				lineTokenIndex = 0;
				placeHolders.setProperty("*9",moduleName);
			} else {
				compilerTokenIndex = 0;
				lineTokenIndex = 0;
				
				setExErrorMsg("");
				String lineToken = "";
				String prevLineToken = "";
				String nextLineToken = "";
				String complierToken = "";
				compilerPHPFile.appendFile("\n");
				for (int i=0;i<indentionCount;i++) {
					compilerPHPFile.appendFile("\t");
				}
				compilerPHPFile.appendFile(entry.getpreEntryString());
				do {
					lineToken = (String)lineTokens.elementAt(lineTokenIndex);
					if (lineTokenIndex>0) {prevLineToken = (String)lineTokens.elementAt(lineTokenIndex-1);} else {prevLineToken = lineToken;}
					if (lineTokenIndex<lineTokens.size()-1) {nextLineToken = (String)lineTokens.elementAt(lineTokenIndex+1);} else {nextLineToken = lineToken;}
					if (lineToken.length() == 0) {lineTokenIndex++;continue;}
					// check for line labels
					if (lineTokenIndex == 0 && lineToken.endsWith(":")) {
						symbolTable.addSymbol(moduleName,currentScope(),lineToken,String.valueOf(getLineNumber()),symType.LABEL,symClass.NONE);
						compilerPHPFile.appendFile("");
						lineTokenIndex++;
						if (lineTokenIndex < lineTokens.size()) {break;} else {continue;}
					}
					boolean bTokensMatch = false;
					int multiTransTextIndex = 0;
					
					if (expComplierTokens.size() < compilerTokenIndex) {
						setExErrorMsg("Incomplete translation table entry");
						return lineTokenIndex;
					}
					translationTableToken token = null;
					try {
						token = (translationTableToken)expComplierTokens.elementAt(compilerTokenIndex);
					} catch (Exception e) {displayDialog("Caught A");}
					//displayDialog("Compiler Token:"+token.getText());
					Vector v = supportFunctions.splitIntoTokens(token.getText()," ");
					for (int j=0;j<v.size();j++) {
						Vector v1 = supportFunctions.splitIntoTokens((String)v.elementAt(j),"##",false);
						for (int k=0;k<v1.size();k++) {
							multiTransTextIndex = k;
							complierToken = (String)v1.elementAt(k);
							//displayDialog("Complier Token:" + complierToken);
							
							// if matching a complier token in a multi-group
							// only use 'break' if we have a match for the token
							// otherwise we will not go on and match the other complier
							// tokens in the multi-group
							if (complierToken.equals("integer")) {
								if (tokenizer.isNumeric(lineToken)) {
									bTokensMatch = true;
									break;
								}
							}
							
						} // end of split '##' loop
					
						if (!bTokensMatch) {
							// first check to see if this is an optional token, yes ignore it
							bNoTransText = false;
							String flags = token.getFlags();
							if (flags.length() != 0) {
								Vector v5 = supportFunctions.splitIntoTokens(flags,"##",false);
								String tmp = (String)v5.elementAt(multiTransTextIndex);
								if (tmp.startsWith("z")) {
									setExErrorMsg(""); // clear any multi token error messages on a sucessful token match
									lineTokenIndex--;
									bTokensMatch = true;
									bNoTransText = true;
									TRACE("Above complier token optional - not included in input line",4);
								}
							}
							
							if (!bTokensMatch) { // if token is not optional
								if(getExErrorMsg().length() == 0) {setExErrorMsg("Unrecognized Token (line:"+lineToken+" compiler:"+complierToken+")");}
								return lineTokenIndex;
							}
						} else {
							bNoTransText = false;
							setExErrorMsg(""); // clear any multi token error messages on a sucessful token match
						}
						
						String transText = token.getTransText();
						if (bNoTransText) {transText = "";}
						if (transText.length() != 0) {
							//displayDialog("tt: " + transText);
							Vector v2 = supportFunctions.splitIntoTokens(transText," ");
							Vector v3 = supportFunctions.splitIntoTokens((String)v2.elementAt(j),"##",false);
							transText = (String)v3.elementAt(multiTransTextIndex);
							
							// don't care about trans text marker
							if (transText.equals("x")) {transText="";}
							
							if (transText.contains("{")) {indentionCount++;}
							if (transText.contains("}")) {indentionCount--;}
						} else {
							//displayDialog("No Trans Text");
						}

						if (j != v.size()-1) {
							try {
								lineToken = (String)lineTokens.elementAt(++lineTokenIndex);
							} catch (Exception e) {displayDialog("Caught B");}
							//displayDialog("Line Token2:" + lineToken);
						}
					} // end of split ' ' loop
					
					String flags = token.getFlags();
					if (flags.length() != 0) {
						//displayDialog("Flags:"+flags);
						Vector v4 = supportFunctions.splitIntoTokens(flags,"##",false);
						String tmp = "";
						try {
							tmp = (String)v4.elementAt(multiTransTextIndex);
						} catch (Exception e) {	displayDialog("Token flag mismatch");}
						if (tmp.startsWith("y")) {
							break; // finish processing line
						}
						if (tmp.startsWith("z")) {
							//if (!bTokensMatch) {lineTokenIndex--;} // ignore optional token only on a non token match
						}
						if (tmp.startsWith("r")) {
							try {
								int adjust = Integer.parseInt(tmp.substring(1));
								compilerTokenIndex = compilerTokenIndex + adjust;
							} catch (Exception e) {}
						} else {
							compilerTokenIndex++;
						}	
					} else {
						compilerTokenIndex++;
					}
					
					lineTokenIndex++;

				} while( (lineTokenIndex < lineTokens.size()) && (compilerTokenIndex < expComplierTokens.size()) ); // end of lineTokens for loop
				compilerPHPFile.appendFile(entry.getpostEntryString());
			}
			return -1; // for success
		}
	}
	
 	public class templateCompilerTokens extends compilerTokens {
		public String preProcessLine(String line,boolean bKeywords) {
			TRACE("preProcessLine:templateCompilerTokens",4);
			line = basePreProcessLine(line,bKeywords);
			return line;
		}
	}
	public class templateCompiler extends compiler {
		private		pseduoFile	compilerFile;
		protected 	templateCompilerTokens tokenizer;
		protected 	String	compiledLine = "";

		public templateCompiler(String transTableName,String templateReservedWords) {
			super(transTableName);
			tokenizer = new templateCompilerTokens();
			tokenizer.setReservedWords(templateReservedWords);
			//tokenizer.setTypes(templateTypes);
			setVarPreDefined(true);
			setCommentString("////");
		}
		public String compileLine(String line) {
			String code = "";
			setCompileLine(true);
			Vector lines = supportFunctions.splitIntoTokens(line,";");
			for (int lineNumber=0;lineNumber<lines.size();lineNumber++) {
				compiledLine = "";
				if(!syntaxCheck((String)lines.elementAt(lineNumber))) {return "";}
				code = code + compiledLine;
			}
			setCompileLine(false);
			return code;
		}
		public boolean isValidIdentifier(String ident) {
			if (tokenizer.isReserved(ident)) {return false;}
			return isValidID(ident);
		}
		public boolean syntaxCheck(String line) {
			Vector v = tokenizer.tokenizeLine(line);
			syntaxError = "";
			return syntaxCheckInternal(line,v);
		}
		public String getKeywordFromLine(Vector tokens) {
			if (tokens.size() == 0) {return "";}
			// default case first token on line unless first token is a line label
			String tmp = (String)tokens.elementAt(0);
			String tmp1 = (String)tokens.elementAt(1);
			if (tmp1.equals(":")) {
				tokens.setElementAt((String)tokens.elementAt(0)+":",0);
				tokens.setElementAt("",1);
				if (tokens.size() > 2) {
					tmp =  (String)tokens.elementAt(2);
				} else {
					return "linelabel";
				}
			}
			return tmp;
		}
		public boolean syntaxCheckInternal(String line,Vector tokens) {
			String keyword = getKeywordFromLine(tokens);
			
			// process the line using the translation table entry defined by the above keyword
			int status = processLine(line,keyword,tokens);
			if (status != -1) {
				setErrorString("Line:" + String.valueOf(getLineNumber()+1)+" " + line,(String)tokens.elementAt(status));
				return false;
			}
			return true;
		}
		public String getName() {return "Template";}
		public String getFileExt() {return "tem";}
		
		public boolean preCompile(String filename,boolean bHeaders) {
			indentionCount = 0;
						
			if (bHeaders) {		
				symbolTable.removeAllSymbols();
				transTable = new translationTable();
				transTable.loadTranslationTable(transTableName);
			
				compilerFile = new pseduoFile(""+dataRelativePath+"/"+appDirectory,supportFunctions.getFilenameNoExt(filename) + ".out");
				compilerFile.saveFile("<html>\n<head>"); // saveFile used to remove any existing file
				compilerFile.appendFile("\n</head>\n<body>");
			}
			
			// clear compile place holder list
			placeHolders.remove("*e");
			placeHolders.remove("*f");
			placeHolders.remove("*g");
			placeHolders.remove("*h");

			return true;
		}
		public boolean postCompile(String filename,boolean bHeaders) {
			if (bHeaders) {
				compilerFile.flush();
			}
			return true;
		}
		public boolean betweenPassProcesses() {
			if (bProcessHeaders) {
				compilerFile.appendFile("");
			}
			return true;
		}
		public String currentScope() {return "";}
		public boolean completeLine(String line) {return true;}
		public int processTokens(String line,String keyword,Vector compilerTokens,Vector lineTokens,translationTableEntry entry) {
			//placeHolders = new Properties();
			// clear line only place holder list
			placeHolders.remove("*1");
			placeHolders.remove("*2");
			placeHolders.remove("*3");
			placeHolders.remove("*4");

			Vector expComplierTokens = transTable.expandTokens(compilerTokens);			
			int compilerTokenIndex,lineTokenIndex;
			boolean bNoTransText = false;
			
			if (strCount(line,'(') != strCount(line,')')) {
				setExErrorMsg("Missing ( or ) characters");
				return 0;
			}
			
			if (getPassNumber() == 1) {
				compilerTokenIndex = 0;
				lineTokenIndex = 0;
			} else {
				compilerTokenIndex = 0;
				lineTokenIndex = 0;
				
				setExErrorMsg("");
				String lineToken = "";
				String prevLineToken = "";
				String nextLineToken = "";
				String complierToken = "";
				compilerFile.appendFile("\n");
				for (int i=0;i<indentionCount;i++) {
					compilerFile.appendFile("\t");
				}
				String s = entry.getpreEntryString();
				//s = s.replaceAll("\\*a",completeScope());
				compilerFile.appendFile(s);
				do {
					lineToken = (String)lineTokens.elementAt(lineTokenIndex);
					if (lineTokenIndex>0) {prevLineToken = (String)lineTokens.elementAt(lineTokenIndex-1);} else {prevLineToken = lineToken;}
					if (lineTokenIndex<lineTokens.size()-1) {nextLineToken = (String)lineTokens.elementAt(lineTokenIndex+1);} else {nextLineToken = lineToken;}
					if (lineToken.length() == 0) {lineTokenIndex++;continue;}
					// check for line labels
					if (lineTokenIndex == 0 && lineToken.endsWith(":")) {
						symbolTable.addSymbol(moduleName,currentScope(),lineToken,String.valueOf(getLineNumber()),symType.LABEL,symClass.NONE);
						compilerFile.appendFile("");
						lineTokenIndex++;
						if (lineTokenIndex < lineTokens.size()) {break;} else {continue;}
					}
					boolean bTokensMatch = false;
					int multiTransTextIndex = 0;
					
					if (expComplierTokens.size() < compilerTokenIndex) {
						setExErrorMsg("Incomplete translation table entry");
						return lineTokenIndex;
					}
					translationTableToken token = null;
					try {
						token = (translationTableToken)expComplierTokens.elementAt(compilerTokenIndex);
					} catch (Exception e) {displayDialog("Caught A");}
					//displayDialog("Compiler Token:"+token.getText());
					Vector v = supportFunctions.splitIntoTokens(token.getText()," ");
					for (int j=0;j<v.size();j++) {
						Vector v1 = supportFunctions.splitIntoTokens((String)v.elementAt(j),"##",false);
						for (int k=0;k<v1.size();k++) {
							multiTransTextIndex = k;
							complierToken = (String)v1.elementAt(k);
							//displayDialog("Complier Token:" + complierToken);
							
							// if matching a complier token in a multi-group
							// only use 'break' if we have a match for the token
							// otherwise we will not go on and match the other complier
							// tokens in the multi-group
							if (complierToken.equals("integer")) {
								if (tokenizer.isNumeric(lineToken)) {
									bTokensMatch = true;
									break;
								}
							}
							
						} // end of split '##' loop
					
						if (!bTokensMatch) {
							// first check to see if this is an optional token, yes ignore it
							bNoTransText = false;
							String flags = token.getFlags();
							if (flags.length() != 0) {
								Vector v5 = supportFunctions.splitIntoTokens(flags,"##",false);
								String tmp = (String)v5.elementAt(multiTransTextIndex);
								if (tmp.startsWith("z")) {
									setExErrorMsg(""); // clear any multi token error messages on a sucessful token match
									lineTokenIndex--;
									bTokensMatch = true;
									bNoTransText = true;
									TRACE("Above complier token optional - not included in input line",4);
								}
							}
							
							if (!bTokensMatch) { // if token is not optional
								if(getExErrorMsg().length() == 0) {setExErrorMsg("Unrecognized Token (line:"+lineToken+" compiler:"+complierToken+")");}
								return lineTokenIndex;
							}
						} else {
							bNoTransText = false;
							setExErrorMsg(""); // clear any multi token error messages on a sucessful token match
						}
						
						String transText = token.getTransText();
						if (bNoTransText) {transText = "";}
						if (transText.length() != 0) {
							//displayDialog("tt: " + transText);
							Vector v2 = supportFunctions.splitIntoTokens(transText," ");
							Vector v3 = supportFunctions.splitIntoTokens((String)v2.elementAt(j),"##",false);
							transText = (String)v3.elementAt(multiTransTextIndex);
							
							// don't care about trans text marker
							if (transText.equals("x")) {transText="";}
							
							if (transText.contains("{")) {indentionCount++;}
							if (transText.contains("}")) {indentionCount--;}
							
							compilerFile.appendFile(transText);
						} else {
							//displayDialog("No Trans Text");
						}

						if (j != v.size()-1) {
							try {
								lineToken = (String)lineTokens.elementAt(++lineTokenIndex);
							} catch (Exception e) {displayDialog("Caught B");}
							//displayDialog("Line Token2:" + lineToken);
						}
					} // end of split ' ' loop
					
					String flags = token.getFlags();
					if (flags.length() != 0) {
						//displayDialog("Flags:"+flags);
						Vector v4 = supportFunctions.splitIntoTokens(flags,"##",false);
						String tmp = "";
						try {
							tmp = (String)v4.elementAt(multiTransTextIndex);
						} catch (Exception e) {	displayDialog("Token flag mismatch");}
						if (tmp.startsWith("y")) {
							break; // finish processing line
						}
						if (tmp.startsWith("z")) {
							//if (!bTokensMatch) {lineTokenIndex--;} // ignore optional token only on a non token match
						}
						if (tmp.startsWith("r")) {
							try {
								int adjust = Integer.parseInt(tmp.substring(1));
								compilerTokenIndex = compilerTokenIndex + adjust;
							} catch (Exception e) {}
						} else {
							compilerTokenIndex++;
						}	
					} else {
						compilerTokenIndex++;
					}
					
					lineTokenIndex++;

				} while( (lineTokenIndex < lineTokens.size()) && (compilerTokenIndex < expComplierTokens.size()) ); // end of lineTokens for loop
				s = entry.getpostEntryString();
				//s = s.replaceAll("\\*a",completeScope());
				compilerFile.appendFile(s);
			}
			return -1; // for success
		}
	}
	
/**
 * Represents a Tree of Objects of generic type T. The Tree is represented as
 * a single rootElement which points to a List<Node<T>> of children. There is
 * no restriction on the number of children that a particular node may have.
 * This Tree provides a method to serialize the Tree into a List by doing a
 * pre-order traversal. It has several methods to allow easy updation of Nodes
 * in the Tree.
 */
public class Tree<T> {
 
    private Node<T> rootElement;
     
    /**
     * Default ctor.
     */
    public Tree() {
        super();
    }
 
    /**
     * Return the root Node of the tree.
     * @return the root element.
     */
    public Node<T> getRootElement() {
        return this.rootElement;
    }
 
    /**
     * Set the root Element for the tree.
     * @param rootElement the root element to set.
     */
    public void setRootElement(Node<T> rootElement) {
        this.rootElement = rootElement;
    }
     
    /**
     * Returns the Tree<T> as a List of Node<T> objects. The elements of the
     * List are generated from a pre-order traversal of the tree.
     * @return a List<Node<T>>.
     */
    public java.util.List<Node<T>> toList() {
        java.util.List<Node<T>> list = new ArrayList<Node<T>>();
        walk(rootElement, list);
        return list;
    }
     
    /**
     * Returns a String representation of the Tree. The elements are generated
     * from a pre-order traversal of the Tree.
     * @return the String representation of the Tree.
     */
    public String toString() {
        return toList().toString();
    }
     
    /**
     * Walks the Tree in pre-order style. This is a recursive method, and is
     * called from the toList() method with the root element as the first
     * argument. It appends to the second argument, which is passed by reference     * as it recurses down the tree.
     * @param element the starting element.
     * @param list the output of the walk.
     */
    private void walk(Node<T> element, java.util.List<Node<T>> list) {
        list.add(element);
        for (Node<T> data : element.getChildren()) {
            walk(data, list);
        }
    }
}

/**
 * Represents a node of the Tree<T> class. The Node<T> is also a container, and
 * can be thought of as instrumentation to determine the location of the type T
 * in the Tree<T>.
 */
public class Node<T> {
 
    public T data;
    public java.util.List<Node<T>> children;
 
    /**
     * Default ctor.
     */
    public Node() {
        super();
    }
 
    /**
     * Convenience ctor to create a Node<T> with an instance of T.
     * @param data an instance of T.
     */
    public Node(T data) {
        this();
        setData(data);
    }
     
    /**
     * Return a list of the children of Node<T>. The Tree<T> is represented by a single
     * root Node<T> whose children are represented by a List<Node<T>>. Each of
     * these Node<T> elements in the List can have children. The getChildren()
     * method will return a list of the children of a Node<T>.
     * @return a list of the children of Node<T>
     */
    public java.util.List<Node<T>> getChildren() {
        if (this.children == null) {
            return new ArrayList<Node<T>>();
        }
        return this.children;
    }
 
    /**
     * Sets the children of a Node<T> object. See docs for getChildren() for
     * more information.
     * @param children the List<Node<T>> to set.
     */
    public void setChildren(java.util.List<Node<T>> children) {
        this.children = children;
    }
 
    /**
     * Returns the number of immediate children of this Node<T>.
     * @return the number of immediate children.
     */
    public int getNumberOfChildren() {
        if (children == null) {
            return 0;
        }
        return children.size();
    }
     
    /**
     * Adds a child to the list of children for this Node<T>. The addition of
     * the first child will create a new List<Node<T>>.
     * @param child a Node<T> object to set.
     */
    public void addChild(Node<T> child) {
        if (children == null) {
            children = new ArrayList<Node<T>>();
        }
        children.add(child);
    }
     
    /**
     * Inserts a Node<T> at the specified position in the child list. Will     * throw an ArrayIndexOutOfBoundsException if the index does not exist.
     * @param index the position to insert at.
     * @param child the Node<T> object to insert.
     * @throws IndexOutOfBoundsException if thrown.
     */
    public void insertChildAt(int index, Node<T> child) throws IndexOutOfBoundsException {
        if (index == getNumberOfChildren()) {
            // this is really an append
            addChild(child);
            return;
        } else {
            children.get(index); //just to throw the exception, and stop here
            children.add(index, child);
        }
    }
     
    /**
     * Remove the Node<T> element at index index of the List<Node<T>>.
     * @param index the index of the element to delete.
     * @throws IndexOutOfBoundsException if thrown.
     */
    public void removeChildAt(int index) throws IndexOutOfBoundsException {
        children.remove(index);
    }
 
    public T getData() {
        return this.data;
    }
 
    public void setData(T data) {
        this.data = data;
    }
     
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("{").append(getData().toString()).append(",[");
		int i = 0;
		for (Node<T> e : getChildren()) {
			if (i > 0) {
				sb.append(",");
			}
			sb.append(e.toString());
			i++;
		}
		sb.append("]").append("}");
		return sb.toString();
	}
}


public class callingTree implements TreeSelectionListener,ActionListener,xmlBaseUtils {
	private JTree					callingTree = null;
	private	JButton					editDefsButton = null;
	private	JButton					saveAsXMLButton = null;
	private	DefaultMutableTreeNode	root = null;
	private	DefaultMutableTreeNode	currentNode = null;
	private	xmlDataFile				callingTreeXMLData = new xmlDataFile();
	private	String					currentLanguageBlock = "";
	private	String					entryPoints = "";
	private String					eventHandlers = "";
	private	String					treeName = "";
	private boolean					bValid = true;
		
	callingTree(String treeName) {
		this.treeName = treeName;
		root = new DefaultMutableTreeNode(treeName);
		callingTree = new JTree(root);
		callingTree.addTreeSelectionListener(this);
		TreeSelectionModel m = callingTree.getSelectionModel();
		m.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		callingTree.setSelectionModel(m);
		currentNode = root;
		if (!callingTreeXMLData.openXMLDataFile(dataRelativePath+"/"+appDirectory+"/callingtree","callingtree",false)) {
			displayDialog("callingtree.xml not found.");
			bValid = false;
			return;
		}
		callingTreeXMLData.getXmlBase().addXmlUtilsListener(this);
		callingTreeInit();
	}
	public boolean isValid() {return bValid;}
		public void callingTreeInit() {
			currentLanguageBlock = getAttributeWithXPath("/callingtree/currentblock","lang");
			entryPoints = getAttributeWithXPath("/callingtree/languageblock[@lang='" + currentLanguageBlock + "']/entrypoints","data");
			eventHandlers = getAttributeWithXPath("/callingtree/languageblock[@lang='" + currentLanguageBlock + "']/eventhandlers","data");
			reset();
		}
		public String[] getLangBlockList() {
		    ArrayList<String> 				data = new ArrayList<String>();

			NodeList n = executeXPathExpr(getXmlDataFile().getXMLDocument(),"/callingtree/currentblock");
			for(int i=0;i<n.getLength();i++) {
				org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(i);
				data.add(e.getAttribute("lang"));
			}
			
		    return (String[])data.toArray();
		}
		public xmlDataFile getXmlDataFile() {return callingTreeXMLData;}
		public void setAttributeWithXPath(String xPathExpr,String attrib,String value) {
			NodeList n = executeXPathExpr(getXmlDataFile().getXMLDocument(),xPathExpr);
			if (n.getLength() > 0) {
				org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(0);
				e.setAttribute(attrib,value);
				getXmlDataFile().saveXMLDataFile();
			}
		}
		public String getAttributeWithXPath(String xPathExpr,String attrib) {
			String data = "";
			
			NodeList n = executeXPathExpr(getXmlDataFile().getXMLDocument(),xPathExpr);
			if (n.getLength() > 0) {
				org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(0);
				data = e.getAttribute(attrib);
			}
			return data;
		}
		public String[] getFunctionCalls(String line) {
			ehsRegExp r = new ehsRegExp();

			String regExp = getAttributeWithXPath("/callingtree/languageblock[@lang='" + currentLanguageBlock + "']/funccalls","data");
			TRACE("getFunctionCalls:"+regExp,4);
			if (r.regExpMatch(line,regExp)) {
				return r.getFoundGroupsArray();
			}		
			
			return (String[])null;			
		}
		public String getVarDefRegExp() {
			return getAttributeWithXPath("/callingtree/languageblock[@lang='" + currentLanguageBlock + "']/vardef","data");
		}
		public String getVarAssignRegExp() {
			return getAttributeWithXPath("/callingtree/languageblock[@lang='" + currentLanguageBlock + "']/varassign","data");
		}
		public String getLoopingRegExp() {
			return getAttributeWithXPath("/callingtree/languageblock[@lang='" + currentLanguageBlock + "']/looping","data");
		}
		public String getBranchingRegExp() {
			return getAttributeWithXPath("/callingtree/languageblock[@lang='" + currentLanguageBlock + "']/branching","data");
		}
		public org.w3c.dom.Element createNodePerformed(org.w3c.dom.Element e) {
			return e;
		}
		public String getNodePerformed(String data) {
			return data;
		}
		public org.w3c.dom.Element addNodePerformed(org.w3c.dom.Element e) {
			return e;
		}
		public org.w3c.dom.Element updateNodePerformed(org.w3c.dom.Element e) {			
			return e;
		}
		public org.w3c.dom.Element deleteNodePerformed(org.w3c.dom.Element e) {
			return e;
		}
		public DefaultMutableTreeNode addCallingTreeNode(String key,String entry,String data) {
			if (entry.length() == 0) {return (DefaultMutableTreeNode)null;}
			if (data.length() == 0) {data = "-";}
			DefaultMutableTreeNode node = new DefaultMutableTreeNode(key + ":" + entry + ":" + data);
			currentNode.add(node);	
			return node;
		}
		public void startDefine(String type,String name) {
			DefaultMutableTreeNode node = null;
			if (type.equals("pushscopeclass")) {node = addCallingTreeNode("class",name,"");}			
			if (type.equals("pushscopeclasstemplate")) {node = addCallingTreeNode("classtemplate",name,"");}			
			if (type.equals("pushscopeinterface")) {node = addCallingTreeNode("interface",name,"");}			
			if (type.equals("pushscopefunc")) {node = addCallingTreeNode("function",name,"");}			
			if (type.equals("pushscopefuncps")) {node = addCallingTreeNode("function",name,"");}
			if (!type.equals("pushscopefuncps")) {currentNode = node;}
		}
		public void endDefine(String type) {
			currentNode = (DefaultMutableTreeNode) currentNode.getParent();
		}
		
		public void reset() {
			callingTree.removeAll();
			currentNode = root;
		}
		public DefaultMutableTreeNode getCurrentNode() {return currentNode;}
		public DefaultMutableTreeNode getRoot() {return root;}
		public JTree getCallingTree() {return callingTree;}
		public void actionPerformed(ActionEvent evt) {
			if (evt.getSource() == editDefsButton) {
				callingTreeXMLData.miniXMLEditor();
			}
			if (evt.getSource() == saveAsXMLButton) {
				Stack nodeTags = new Stack();
				pseduoFile dataFile = new pseduoFile(dataRelativePath+"/"+appDirectory+"/output",supportFunctions.getFilenameNoExt(treeName) + "_callingtreedata.xml");
				dataFile.saveFile("<?xml version=\"1.0\"?>"); // saveFile used to remove any existing file
				dataFile.appendFile("\n<callingtreedata>");

				dataFile.appendFile("\n\t<module data=\"" + supportFunctions.getFilenameNoExt(treeName) + "\">");
				dataFile.appendFile("\n\t<lang=\"" + currentLanguageBlock + "\">");
				dataFile.appendFile("\n\t<date data=\"" + currentShortDate() + "\">");
				dataFile.appendFile("\n\t<time data=\"" +currentShortTime() + "\">");
				
				
				// other enumerations: preorderEnumeration, postorderEnumeration, depthFirstEnumeration and breadthFirstEnumeration
				for (Enumeration e = root.preorderEnumeration(); e.hasMoreElements();) {
				    DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.nextElement();
				    String indent = stringRepeat("\t",nodeTags.size() + 2);
				    if (node.isLeaf()) {
				    	Vector tokens = supportFunctions.splitIntoTokens(node.toString(),":");
				    	dataFile.appendFile("\n" + indent + "<" + (String)tokens.elementAt(0) + " entry=\"" + 
				    			(String)tokens.elementAt(1) + "\" data=\"" + (String)tokens.elementAt(2) + "\"/>");	
				    	if (!nodeTags.isEmpty() && node.getNextSibling()==null) {dataFile.appendFile((String)nodeTags.pop());}
				    } else {
				    	if(node == root) {
					    	dataFile.appendFile("\n" + indent + "<" + node.toString() + ">");
					    	nodeTags.push("\n" + indent + "</" + node.toString() + ">");				    		
				    	} else {				    		
					    	Vector tokens = supportFunctions.splitIntoTokens(node.toString(),":");
					    	dataFile.appendFile("\n" + indent + "<" + (String)tokens.elementAt(0) + " entry=\"" + 
					    			(String)tokens.elementAt(1) + "\" data=\"" + (String)tokens.elementAt(2) + "\">");
					    	nodeTags.push("\n" + indent + "</" + (String)tokens.elementAt(0) + ">");
				    	}
				    }
				}
				
		    	if (!nodeTags.isEmpty()) {dataFile.appendFile((String)nodeTags.pop());}
				dataFile.appendFile("\n</callingtreedata>");
				dataFile.flush();
				
				displayDialog("Calling tree saved as XML.");
			}
		}
		public void displayCallingTree() {
			JPanel pBut = new JPanel();
			pBut.setLayout(new BoxLayout(pBut,BoxLayout.X_AXIS));
			editDefsButton = new JButton("Edit Lang Definations...");
			editDefsButton.addActionListener(this);
			pBut.add(editDefsButton);
			saveAsXMLButton = new JButton("Save As XML");
			saveAsXMLButton.addActionListener(this);
			pBut.add(saveAsXMLButton);
			
			JPanel p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
			callingTree.expandRow(0);
			JScrollPane sp = new JScrollPane(callingTree);
			p.add(sp);
			p.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			p.add(pBut);
			displayPanelDialog(p,"Calling Tree");
		}
		public void valueChanged(TreeSelectionEvent evt) {
			Object selection = callingTree.getLastSelectedPathComponent();
			if (selection != null) {
				DefaultMutableTreeNode node = (DefaultMutableTreeNode)selection;
				callTreeNodeClicked(callingTree,node);
			}
		}
		public void callTreeNodeClicked(JTree tree,DefaultMutableTreeNode node) {
			if (node.isLeaf()) {
				DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode)node.getParent();
				if (node.getRoot() != parentNode) {
					// node text is in the form key:entry
					Vector v1 = supportFunctions.splitIntoTokens(node.toString(),":");
					String key = (String)v1.elementAt(0);
					String entry = (String)v1.elementAt(1);
				} else {
					TRACE("callTreeNodeClicked:Symbol type got no entries",4);
				}
			} else {
				TRACE("callTreeNodeClicked:Not clicked on a leaf node",4);
			}
		}
		public String[] getCallingSequence(DefaultMutableTreeNode startNode,String text) {
		    ArrayList<String> 				data = new ArrayList<String>();
		    DefaultMutableTreeNode			foundNode = null;

			// other enumerations: preorderEnumeration, postorderEnumeration, depthFirstEnumeration and breadthFirstEnumeration
			for (Enumeration e = root.preorderEnumeration(); e.hasMoreElements();) {
			    DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.nextElement();
			    if (text.equals(node.toString())) {
			    	foundNode = node;
			    }
			}
			
			if (foundNode != null) {
				for (Enumeration e = foundNode.preorderEnumeration(); e.hasMoreElements();) {
				    DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.nextElement();
					if (!node.isLeaf()) { // inner class or interface or function defined
						data.add("+" + node.toString());
					} else {
						// node text is in the form key:entry
						//Vector v1 = supportFunctions.splitIntoTokens(node.toString(),":");
						//String key = (String)v1.elementAt(0);
						//String entry = (String)v1.elementAt(1);	
						data.add(node.toString());
					}			    	
			    }
			}
			
			return (String[])data.toArray();
		}
		public String[] getCallingReferences(DefaultMutableTreeNode startNode,String text) {
		    ArrayList<String> 				data = new ArrayList<String>();
 			
			// other enumerations: preorderEnumeration, postorderEnumeration, depthFirstEnumeration and breadthFirstEnumeration
			for (Enumeration e = root.preorderEnumeration(); e.hasMoreElements();) {
			    DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.nextElement();
			    if (text.equals(node.toString())) {
			    	DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode)node.getParent();
					// node text is in the form key:entry
					//Vector v1 = supportFunctions.splitIntoTokens(parentNode.toString(),":");
					//String key = (String)v1.elementAt(0);
					//String entry = (String)v1.elementAt(1);	
					if (parentNode != null) {data.add(parentNode.toString());}
			    }
			}
			
			return (String[])data.toArray();
		}
	}

	public class registrationinfo {
		private boolean appUseDatabase;
		private	boolean	appRemoteHosted;
		private	String 	userID;
		private	String	userName;
		private	String	userSerialNumber;
		private	String	userRawSerialNumber;
		private	String	appName;
		private String  appDescription;
		private String  appSerialBase;
		private	String	appVersion;
		private	String	appDate;
		private	String	appCopyright;
		private String 	statusMsg;
		private String  lastLogonDetails;
		private	boolean	appPreRelease;
		private Vector 	depts = new Vector();
		private Vector 	rptTypes = new Vector();
		private Vector	rptStatus = new Vector();
		private int	numAttemptsLeft,userCredit,features;
		private	configurationSettings configSettings;
		private	userManager userMan;
		
	public class userManager {
		public String[] getUserListByTag(String tag) {
			String data = systemMysql.executeSQLQuery("SELECT sysEHSRegID,sysEHSRegName,sysEHSRegEmail,sysEHSRegProduct FROM sysehsregistrations WHERE sysEHSRegTag='"+tag+"' GROUP BY sysEHSRegEmail","");
			
			Vector v = supportFunctions.splitIntoTokens(data,",");
		    String[] tokens = new String[v.size() / 4];
			
			int j = 0;
			for (int i=0;i<v.size();i=i+4) {
				tokens[j++] = (String)v.elementAt(i) + "," + (String)v.elementAt(i+1) + "," + (String)v.elementAt(i+2) + "," + (String)v.elementAt(i+3) + "," + (String)v.elementAt(i+4);
			}
			
			return tokens;
		}
		public String[] getUserListByProduct(String product) {
			String data = systemMysql.executeSQLQuery("SELECT sysEHSRegID,sysEHSRegName,sysEHSRegEmail,sysEHSRegTag FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' GROUP BY sysEHSRegEmail","");
			
			Vector v = supportFunctions.splitIntoTokens(data,",");
		    String[] tokens = new String[v.size() / 4];
			
			int j = 0;
			for (int i=0;i<v.size();i=i+4) {
				tokens[j++] = (String)v.elementAt(i) + "," + (String)v.elementAt(i+1) + "," + (String)v.elementAt(i+2) + "," + (String)v.elementAt(i+3) + "," + (String)v.elementAt(i+4);
			}
			
			return tokens;
		}
	}
		registrationinfo(String name,String description,String serialbase,String version,String date,String cr,boolean internet) {
			numAttemptsLeft = -1;
			appUseDatabase = true;
			appRemoteHosted = internet;
			appName = name;
			appDescription = description;
			appSerialBase = serialbase;
			appVersion = version;
			appDate = date;
			appCopyright = cr;
			appPreRelease = false;
			features = 0;
			userCredit = 0;
			statusMsg = "";
			rptTypes = supportFunctions.splitIntoTokens("Action Item,Defect,Contact Us,Documentation,Enhancement,Feature,Comment,Help File,Knowledge Base,Manual,Order,Quote,Sales,Purchase Order,Equipment Order,Supplies Order,Tech Support,Trainning,Website Design");
			rptStatus = supportFunctions.splitIntoTokens("Unassigned,Open,On Order,In Process,Coding,Documentation,Testing,QA,Closed");
			patchBuildNumber();
			clearRegistrationData();
			configSettings = new configurationSettings();
			configSettings.openConfigurationSettings(""+dataRelativePath+"/"+appDirectory+"/"+name+"_settings");
			userMan = new userManager();
}
		public void setUserTag(String s) {
			if (getUserRegistered()) {
				String data = systemMysql.executeSQLQuery("SELECT sysEHSRegTag FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+userName+"'","");
				Vector v = supportFunctions.splitIntoTokens(data,",");
				String[] tokens = new String[v.size()];
				v.copyInto(tokens);
				
				String newTag = "";
				boolean bTagFound = false;
				for (int i=0;i<tokens.length;i=i+2) {
					if (i != 0) {newTag = newTag + ",";}
					newTag = newTag + tokens[i] + ",";
					if (tokens[i].equals(getAppName())) {newTag = newTag + s;bTagFound = true;} else {newTag = newTag + tokens[i+1];}
				}
				
				if (!bTagFound) {
					if (newTag.length() != 0) {newTag = newTag + ",";}
					newTag = newTag + getAppName() + "," + s;
				}
				
				systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegTag='" + newTag + "' WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+userName+"'","");
			}	
		}
		public String getUserTag() {
			if (getUserRegistered()) {
				String data = systemMysql.executeSQLQuery("SELECT sysEHSRegTag FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+userName+"'","");
				Vector v = supportFunctions.splitIntoTokens(data,",");
				String[] tokens = new String[v.size()];
				v.copyInto(tokens);
				
				for (int i=0;i<tokens.length;i=i+2) {
					if (tokens[i].equals(getAppName())) {return tokens[i+1];}
				}
			}
			
			return "";
		}
		public void setAllowEmails(boolean b) {
			if (getUserRegistered()) {
				systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegReceiveEmailUpdates=" + String.valueOf(b) + " WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+userName+"'","");
			}
		}
		public boolean getAllowEmails() {
			if (getUserRegistered()) {
				String data = systemMysql.executeSQLQuery("SELECT sysEHSRegReceiveEmailUpdates FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+userName+"'","");
				return valueOf(data);
			}
			
			return false;
		}
		protected void finalize() throws Throwable {
			super.finalize();
		}
		public userManager getUserManager() {return userMan;}
		public configurationSettings getConfigurationSettings() {return configSettings;}
		public String getLastLogonDetails() {return lastLogonDetails;}
		public String getAppSerialBase() {return appSerialBase;}
		public String getSerialNumber() {return userSerialNumber;}
		public int isTrial() {return numAttemptsLeft;}
		public String getInfoText() {
			String extra = "";
			if (getPreRelease()) {extra="(prerelease)";}
			if(getUserRegistered()) {
				return appName + "\n" + appVersion + " (" + appDate + ") " + extra + "\n" + appCopyright + "\n" + userName + "\n" + userSerialNumber + "\n" + getBuildString() + "\n" + getframeworkBuildString();
			} else {
				return appName + "\n" + appVersion + " (" + appDate + ") " + extra + "\n" + appCopyright + "\n" + "Unregistered Version" + "\n" + getBuildString() + "\n" + getframeworkBuildString();
			}
		}
		public String getHTMLInfoText() {
			String extra = "";
			if (getPreRelease()) {extra="(prerelease)";}
			if(getUserRegistered()) {
				return "<html><center><font color='red'><font size='+3'><i>" + appName + "</i></font></font><br><font color='blue'><font size='+2'>" + appVersion + " (" + appDate + ")" + " " + extra + "</font></font><br><br><b>" + appCopyright + "<br>" + userName + " " + userSerialNumber + "</b><br>" + getBuildString() + "<br><font size='-1'>" + getframeworkBuildString() + "</font></center></html>";
			} else {
				return "<html><center><font color='red'><font size='+3'><i>" + appName + "</i></font></font><br><font color='blue'><font size='+2'>" + appVersion + " (" + appDate + ")" + " " + extra + "</font></font><br><br><b>" + appCopyright + "<br>" + "Unregistered Version</b><br>" + getBuildString() + "<br><font size='-1'>" + getframeworkBuildString() + "</font></center></html>";
			}
		}
		public String getApplicationInfoText() {
			return appName + " " + appVersion + " " + appCopyright;
		}
		public String getSingleLineInfoText() {
			String extra = "";
			if (getPreRelease()) {extra="(prerelease) ";}
			if(getUserRegistered()) {
				return appName + " " + appVersion + " (" + appDate + ")" + " " + extra + appCopyright + " " + userName + " " + userSerialNumber + " " + getBuildString() + " " + getframeworkBuildString();
			} else {
				return appName + " " + appVersion + " (" + appDate + ")" + " " + extra + appCopyright + " " + "Unregistered Version" + " " + getBuildString() + " " + getframeworkBuildString();
			}
		}
		public String getMultiLineInfoText() {
			String extra = "";
			if (getPreRelease()) {extra="(prerelease) ";}
			if(getUserRegistered()) {
				return appName + " " + appVersion + " (" + appDate + ")" + " " + extra + appCopyright + "\n" + userName + " " + userSerialNumber + "\n" + getBuildString() + " " + getframeworkBuildString();
			} else {
				return appName + " " + appVersion + " (" + appDate + ")" + " " + extra + appCopyright + "\n" + "Unregistered Version" + "\n" + getBuildString() + " " + getframeworkBuildString();
			}
		}
		public String getStatusMsg() {return statusMsg;}
		public void setStatusMsg(String msg) {statusMsg = msg;}
		public int getFeatures() {return features;}
		public void setFeatures(int f) {features = f;}
		public Vector getDepts() {return depts;}
		public Vector getRptTypes() {return rptTypes;}
		public void setDepts(Vector v) {depts = v;}
		public void setRptTypes(Vector v) {rptTypes = v;}
		public boolean getPreRelease() {return appPreRelease;}
		public void setPreRelease(boolean b) {appPreRelease=b;}
		public boolean getUseDatabase() {return appUseDatabase;}
		public void setUseDatabase(boolean b) {appUseDatabase=b;}
		public boolean isOffline() {return !appRemoteHosted;}
		public String getUserName() {return userName;}
		public String getUserID() {return userID;}
		public void setUserID(String s) {userID = s;}
		public void clearRegistrationData() {
			   userName = "unregistered";
			   userID = "";
			   userRawSerialNumber = "";
			   userSerialNumber = "";
			   lastLogonDetails = "";
			   userCredit = 0;
		}
		public void initUserCredit() {
			if (getUserRegistered()) {
				String data = systemMysql.executeSQLQuery("SELECT sysEHSRegCredit FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+ userName+"'","0");
				try {
					userCredit = Integer.parseInt(data);
				} catch (Exception e) {userCredit = 0;}
			} else {userCredit = 0;}
		}
		public int getUserCredit() {return userCredit;}
		public void setUserCredit(int val) {
			if (getUserRegistered()) {
				systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegCredit="+String.valueOf(val)+" WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+userName+"'","");
				userCredit = val;
			}
			else {
				displayDialog("User is not registered");
			}
		}
		public void deleteProductEntry(String productCode) {
			systemMysql.executeSQLQuery("DELETE FROM sysehsproducts WHERE sysEHSProdCode='"+productCode+"'","");
		}
		public void createProductEntry(String productName,String productDescription,String productSerialBase,int productPrice,int productBeta,int productTries,String productVersion,String productUpdateURL,String productPaymentURL,int productClient,String productClientEmail,String productClientName,String productCode,String productAdminUser,String productAdminPassword,int features) {
			systemMysql.executeSQLQuery("INSERT INTO sysehsproducts (sysEHSProdID,sysEHSProdName,sysEHSProdDescription,sysEHSProdSerialBase,sysEHSProdPrice,sysEHSProdBeta,sysEHSProdTries,sysEHSProdVersion,sysEHSProdUpdateURL,sysEHSProdPaymentURL,sysEHSProdClient,sysEHSProdClientEmail,sysEHSProdClientName,sysEHSProdCode,sysEHSProdAdminUser,sysEHSProdAdminPassword,sysEHSProdFeatures) VALUES (NULL,'"+productName+"','"+productDescription+"','"+productSerialBase+"',"+String.valueOf(productPrice)+","+String.valueOf(productBeta)+","+String.valueOf(productTries)+",'"+productVersion+"','"+productUpdateURL+"','"+productPaymentURL+"',"+String.valueOf(productClient)+",'"+productClientEmail+"','"+productClientName+"','"+productCode+"','"+productAdminUser+"','"+productAdminPassword+"',"+String.valueOf(features)+")","");
		}
		public boolean productEntryExists(String productCode) {
			String data = systemMysql.executeSQLQuery("SELECT sysEHSProdDescription FROM sysehsproducts WHERE sysEHSProdCode='"+productCode+"'","");
			if(data.length()==0) return false; else return true;
		}
		public String getAppCopyright() {
			return appCopyright;
		}
		public boolean getAppRemotedHosted() {
			return appRemoteHosted;
		}
		public String getAppName() {
			   return appName;
		}
		public String getAppNameVersion() {
			   return appName + " " + appVersion;
		}
		public String getAppVersion() {
				return appVersion;
		}
		public int getMinorVersionNumber() {
			return getMinorVersionNumber(appVersion);
		}
		public int getMajorVersionNumber() {
			return getMajorVersionNumber(appVersion);
		}
		public int getMinorVersionNumber(String version) {
			int val = 0;
			try {
				val = Integer.parseInt(version.substring(3,5));
			} catch(Exception e) {e.printStackTrace();}
			return val;
		}
		public int getMajorVersionNumber(String version) {
			int val = 0;
			try {
				val = Integer.parseInt(version.substring(0,2));
			} catch(Exception e) {e.printStackTrace();}
			return val;
		}
		public String isUserRegistered(String user,String product) {
			   return systemMysql.executeSQLQuery("SELECT sysEHSRegEmail FROM sysehsregistrations WHERE sysEHSRegName='"+user+"' AND sysEHSRegProduct='"+product+"'","");
		}
		public void saveRegistrationData() {
//		   if (getUseDatabase()) {
//		   } else {
//			   	 char[] buf = new char[4096];
//			   	 try {
//				 	 File f = new File(appName+userName+".lic");
//				 	 FileWriter out = new FileWriter(f);
//					 if (out != null) {
//					 	String s = userRawSerialNumber + "," + userName;
//					 	StringBuffer sb = new StringBuffer(s);
//						int len = s.length();
//						for(int i=0;i<len;i++) {buf[i]=sb.charAt(i);}
//						out.write(buf,0,len);
//					 	out.close();
//					}
//				 } catch (Exception e) {e.printStackTrace();}
//		   }
		}
		public String getRawSerialNumber() {return userRawSerialNumber;}
		public boolean loadRegistrationData(String username,String password) {
			String data = "";
//			if (getUseDatabase()) {
				data = systemMysql.executeSQLQuery("SELECT sysEHSRegSerial,sysEHSRegName,sysEHSRegPassword,sysEHSRegLogonDate,sysEHSRegLogonTime,sysEHSRegUserName FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegUserName='"+username+"' AND sysEHSRegActive=1","");
				// assume at the moment passwords match, but need to check that !!!
				systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegLogonDate='"+currentShortDate()+"' WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegUserName='"+username+"'","");
				systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegLogonTime='"+currentShortTime()+"' WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegUserName='"+username+"'","");
				TRACE("LRD:"+data,4);
				if (data.length() == 0) { // user not yet registered
					TRACE("LRD:User not yet registered",4);
					return false;
				} 
//			}
				
			return loadRegistrationDataInternal(data);
		}		
		public boolean loadRegistrationData(String uniqueID) {
			if (uniqueID.equals("1")) {return loadRegistrationDataInternal("EHS-ES1000-P00-00ZZ,End House Software,endhousesoftware,05/06/16,21:26,endhousesoftware");} // running on the real internet
			
			String data = "";
//			if (getUseDatabase()) {
				data = systemMysql.executeSQLQuery("SELECT sysEHSRegSerial,sysEHSRegName,sysEHSRegPassword,sysEHSRegLogonDate,sysEHSRegLogonTime,sysEHSRegUserName FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegUnique='"+uniqueID+"' AND sysEHSRegActive=1","");
				systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegLogonDate='"+currentShortDate()+"' WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegUnique='"+uniqueID+"'","");
				systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegLogonTime='"+currentShortTime()+"' WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegUnique='"+uniqueID+"'","");
				TRACE("LRD:"+data,4);
				if (data.length() == 0) { // user not yet registered
					TRACE("LRD:User not yet registered",4);
					return false;
				} 
//			}
				
			return loadRegistrationDataInternal(data);
		}
		public boolean loadRegistrationDataInternal(String data) {
//				 if (getUseDatabase()) {
				  Vector v = supportFunctions.splitIntoTokens(data);
				  if (v.size() > 0) {
					  lastLogonDetails = (String)v.elementAt(3) + " - " + (String)v.elementAt(4);
				  } else {
					  lastLogonDetails = currentDate() + " - " + currentTime();
				  }
				  setUserID((String)v.elementAt(5));
				  if (data.startsWith("EHS")) {
				  	setRegistrationData((String)v.elementAt(1),(String)v.elementAt(0));
					userLogOn(getUserID());
					return true;
				  }
//			   } else {
//			   	 char[] buf = new char[4096];
//			   	 try {
//				 	 String name = ""; // set to username at some point !!!
//					 int num = 0;
//					 File f = new File(appName+name+".lic");
//				 	 if (!f.exists()) {return false;}
//				 	 FileReader in = new FileReader(f);
//					 if (in != null) {
//					 	num = in.read(buf);
//					 	in.close();
//					}
//					String s = new String(buf,0,num);
//					Vector v = supportFunctions.splitIntoTokens(s);
//					if (v.size() != 2) {return false;}
//					setRegistrationData((String)v.elementAt(1),(String)v.elementAt(0));
//					return true;
//				 } catch (Exception e) {e.printStackTrace();}
//			   }
			   
			   clearRegistrationData();
			   return false;
		}
		public void logOff() {
			userLogOff(getUserID());
			clearRegistrationData();
		}
		public void userLogOn(String userid) {;}
		public void userLogOff(String userid) {;}
		msg3Dialog helpDlg = null;
		public void sendReport(String email) {
			final		Choice		deptCh,typeCh;
			JButton		FAQBut,submitBut,updateHelpBut,OKBut;
			final 		JTextArea	ta;
			JLabel		statusLab;
			final 		JTextField	titleTF,emailTF;
			JPanel		repPanel;
			
			repPanel = new JPanel();
			repPanel.setLayout(new BoxLayout(repPanel,BoxLayout.Y_AXIS));			
			JPanel p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
			p.add(new JLabel("Title:"));
			titleTF = new JTextField("",20);
			titleTF.setBackground(lightyellow);
			p.add(titleTF);
			repPanel.add(p);
			repPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
			deptCh = new Choice();
			typeCh = new Choice();
			p.add(new JLabel("Dept:"));
			p.add(deptCh);
			p.add(new JLabel("Type:"));
			p.add(typeCh);
			deptCh.setBackground(lightyellow);
			typeCh.setBackground(lightyellow);
			repPanel.add(p);
			repPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
			emailTF = new JTextField("",20);
			emailTF.setBackground(lightyellow);
			p.add(new JLabel("Email:"));
			p.add(emailTF);
			repPanel.add(p);
			repPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			p = new JPanel();
			p.setLayout(new FlowLayout(FlowLayout.LEFT));
			JLabel descLab = new JLabel("Description:");
			p.add(descLab);
			repPanel.add(p);
			ta = new JTextArea("",5,20);
			ta.setBackground(lightyellow);
			ta.setWrapStyleWord(true);
			repPanel.add(ta);
			repPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
			statusLab = new JLabel(systemUserReg.getHTMLInfoText());
			p.add(statusLab);
			repPanel.add(p);
			repPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
			FAQBut = new JButton("FAQ");
			submitBut = new JButton("Submit");
			updateHelpBut = new JButton("Update Help");
			OKBut = new JButton("Ok");
			p.add(FAQBut);
			p.add(submitBut);
			//p.add(updateHelpBut);
			p.add(OKBut);
			repPanel.add(p);
			emailTF.setText(email);
			populateChoice(deptCh,systemUserReg.getDepts());
			populateChoice(typeCh,systemUserReg.getRptTypes());
			deptCh.select(0);
			typeCh.select(0);
			ActionListener OKTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					helpDlg.dispose();
			   }
			};
			OKBut.addActionListener(OKTask);
			ActionListener FAQTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					displayFAQ(getAppName());
			   }
			};
			FAQBut.addActionListener(FAQTask);
			ActionListener submitTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					String tmp = "EHS-" + String.valueOf(rand(100,999)) + "-" + currentShortDate();
					String ticket = tmp.replace('/','-');
					msg2Dialog msgD = displayModelessStatusDialog("Submit Report");
					msgD.setText("Submitting Report ...");
					String tmp1 = "INSERT INTO sysehsreports (sysEHSRepID,sysEHSRepOwnerID,sysEHSRepProduct,sysEHSRepVersion,sysEHSRepDesc,sysEHSRepName,sysEHSRepEmail,sysEHSRepType,sysEHSRepDept,sysEHSRepDate,sysEHSRepTicket,sysEHSRepUser) VALUES (null,LAST_INSERT_ID()+1,'"+appName+"','"+appVersion+"','"+ta.getText()+"','"+titleTF.getText()+"','"+emailTF.getText()+"','"+typeCh.getSelectedItem()+"','"+deptCh.getSelectedItem()+"','"+currentDate()+"','"+ticket+"','"+userName+"')";
					//displayDialog(tmp1);
					systemMysql.executeSQLQuery(tmp1,"");
					supportFunctions.mail(emailTF.getText(),"EHS Report Submitted","Thank you for submitting a report. It has been given ticket ID " + ticket + ". You do not need to reply to this email. Report data sent is " + ta.getText());
					supportFunctions.mail(registrationEmail,"New EHS Report Created","Ticket: " + ticket + " Product:" + appName + " Description:" + ta.getText());
					msgD.destory();
					msgD.dispose();
					displayDialog("Thank you for the report, it has been assigined ticket ID " + ticket + ". Please use this reference in any further communication.");
					titleTF.setText("");
					emailTF.setText("");
					ta.setText("");
				}
			};
			submitBut.addActionListener(submitTask);
			ActionListener updateHelpTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					updateHelpTopics(systemUserReg.getAppName(),exHelpFile,true);
				}
			};
			updateHelpBut.addActionListener(updateHelpTask);
			boolean bEnable = false;
			TRACE("sendReport:userid:"+systemUserReg.getUserID(),4);
			if (systemUserReg.getUserID().equals("gavin") || systemUserReg.getUserID().equals("admin")) {bEnable = true;}
			updateHelpBut.setEnabled(bEnable);
			helpDlg = displayPanelDialog(repPanel,"Help Center");
			helpDlg.setLocationRelativeTo(null);
		}
		public void registerUser() {
			if (getUserRegistered()) {return;}
			
			int id = getMachineUniqueID();
			boolean bRegistered = loadRegistrationData(String.valueOf(id));
			if (!bRegistered) {
				Vector v = supportFunctions.splitIntoTokens(displayLogonDialog(),",");
				if (v.size() == 2) {
					String data = systemMysql.executeSQLQuery("SELECT sysEHSRegID FROM sysehsregistrations WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegUserName='"+(String)v.elementAt(0)+"' AND sysEHSRegPassword='"+(String)v.elementAt(1)+"' AND sysEHSRegActive=1","");
					if (data.length() != 0) {
						systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegUnique="+id+" WHERE sysEHSRegID="+data,"");
						registerUser();
						return;
					} else {
						displayDialog("Logon failure, will continue as unregistered.");
					}
				}
			}
			
			if (!bRunAppWithGUI) {return;}
			
			if (splashJPG.equals("") && !bRegistered) {
				JOptionPane.showMessageDialog(null,"This copy of "+ systemUserReg.getAppName() + " is unregistered. Please see website to obtain a serial number.",systemUserReg.getAppName(),JOptionPane.INFORMATION_MESSAGE);
			} else {
				if (splashJPG.equals("")) {
					JOptionPane.showMessageDialog(null,systemUserReg.getSingleLineInfoText(),systemUserReg.getAppName(),JOptionPane.INFORMATION_MESSAGE);
				} else {
					int major = systemUserReg.getMajorVersionNumber();
					int minor = systemUserReg.getMinorVersionNumber();
					displaySplashScreen(systemUserReg.getAppName(),splashJPG,"Version "+String.valueOf(major)+"."+String.valueOf(minor),15);
				}
			}
		}
		public void setRegistrationData(String name,String serial) {
			userName = name;
		  	userRawSerialNumber = serial;
			userSerialNumber = serial.substring(0,12) + "xx-xxxx";
			if (serial.charAt(11) == 'T') {
				numAttemptsLeft = Integer.parseInt(serial.substring(12,14));
				if (numAttemptsLeft == 0) {
					displayDialog("Sorry your trail licence has expired.");
					supportFunctions.mail(registrationEmail,"Licence Expiry","A trail licence for "+name+" has expired.");
					clearRegistrationData();
					return;
				} else {
					numAttemptsLeft--;
					String tmp = String.valueOf(numAttemptsLeft);
					if (tmp.length() == 1) {tmp = "0" + tmp;}
					String newValCode = serial.substring(0,12) + tmp + serial.substring(14);
					displayDialog("You have " + String.valueOf(numAttemptsLeft) + " runs left on your trail licence.");
					//if (getUseDatabase()) 
						{systemMysql.executeSQLQuery("UPDATE sysehsregistrations SET sysEHSRegSerial='" + newValCode +"' WHERE sysEHSRegProduct='"+appName+"' AND sysEHSRegName='"+name+"'","");}
				}
			}
			saveRegistrationData();
			initUserCredit();
		}
		public boolean getUserRegistered() {
			if(userName.equals("unregistered")) {
				return false; 
			} else {
				return true;
			}
		}
		public void doAppUpdate() {
			   try {
			   	   URL u = new URL(getCodeBase(),remoteHostRelativePath+"/webcommon/appupdater.php?appproduct="+appName+"&curbuildnum="+getBuildNumber()+"&serialbase="+appSerialBase+"&directory="+dataRelativePath+"/umldiag/umldiagbuild.number");
			   	   ac.showDocument(u,"_blank");
			   } catch (Exception e) {e.printStackTrace();}
		}
		public String getGitVersionInfoString() {return gitVersionInfo.substring(3,gitVersionInfo.length()-3);}
		public String getBuildString() {return buildDate.substring(3,buildDate.length()-3);}
		public String getframeworkBuildString() {return frameworkBuildDate.substring(3,frameworkBuildDate.length()-3);}
		public String getBuildNumber() {return getBuildString().substring(getBuildString().lastIndexOf(" ")+1);}
		public void patchBuildNumber() {
			appVersion = appVersion.substring(0,6) + String.format("%04d",Integer.parseInt(getBuildNumber())) + appVersion.substring(10);
		}
    		public void displayInfoText() {
			displayDialog(getSingleLineInfoText());
		}
		public void displayAboutBox() {
			ActionListener regTask = new ActionListener() {
      		   public void actionPerformed(ActionEvent evt) {
			   		  registerUser();
			   }
			};
  			JButton regBut = new JButton("Register");
			regBut.addActionListener(regTask);
			ActionListener updateTask = new ActionListener() {
      		   public void actionPerformed(ActionEvent evt) {
			   		  doAppUpdate();
			   }
			};
			JButton updateBut = new JButton("Updates");
  			updateBut.addActionListener(updateTask);
			   Object[] sels = {"Ok",regBut,updateBut};
			   int ret = JOptionPane.showOptionDialog(null,getSingleLineInfoText(),getAppName(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,sels,sels[0]);
		}
	}

	public class positionDialog extends JDialog {
		public positionDialog(Frame parent,String s,boolean b) {
			super(parent,s,b);
			setLocationRelativeTo(lastPositionWindow);
			lastPositionWindow = this;
		}
		public positionDialog(Frame parent,String s,boolean b,String id) {
			super(parent,s,b);
			id = id.replaceAll(" ","");
			String tmp = getSystemVar(id,"0,0");
			Vector v = supportFunctions.splitIntoTokens(tmp);
			setLocation(Integer.parseInt((String)v.elementAt(0)),Integer.parseInt((String)v.elementAt(1)));
			lastPositionWindow = this;
		}
		public positionDialog(Frame parent) {
			super(parent);
			setLocationRelativeTo(lastPositionWindow);
			lastPositionWindow = this;
		}
		public positionDialog(Frame parent,String id) {
			super(parent);
			id = id.replaceAll(" ","");
			String tmp = getSystemVar(id,"0,0");
			Vector v = supportFunctions.splitIntoTokens(tmp);
			setLocation(Integer.parseInt((String)v.elementAt(0)),Integer.parseInt((String)v.elementAt(1)));
			lastPositionWindow = this;
		}
		public void savePosition(String id) {
			Point p = getPosition();
			id = id.replaceAll(" ","");
			String tmp = String.valueOf(p.x) + "," + String.valueOf(p.y);
			setSystemVar(id,tmp);
		}
		
		public void loadPosition(String id) {
			id = id.replaceAll(" ","");
			String tmp = getSystemVar(id,"0,0");
			Vector v = supportFunctions.splitIntoTokens(tmp);
			setLocation(Integer.parseInt((String)v.elementAt(0)),Integer.parseInt((String)v.elementAt(1)));
		}

		public void loadPosition(String id,String defaultPos) {
			id = id.replaceAll(" ","");
			String tmp = getSystemVar(id,defaultPos);
			Vector v = supportFunctions.splitIntoTokens(tmp);
			setLocation(Integer.parseInt((String)v.elementAt(0)),Integer.parseInt((String)v.elementAt(1)));
		}
		
		public Point getPosition() {return getLocationOnScreen();}
	}
		
	public class CustomTableModel extends DefaultTableModel {
		   CustomTableModel(String[][] data,String[] colNames) {
		      super(data,colNames);
		   }
		   public boolean isCellEditable(int row,int column) {return false;}
	}
	
	public class mysqlJDBC {
		private	java.sql.Connection 	conn = null;
		private	Vector		logLines = new Vector();
		private boolean		bLogging = false;

		public JTableExtra getDatabaseTableAsTable(String tableName) {
			JTableExtra jtable = null;
			
			try {
				if (conn == null) {return (JTableExtra)null;}
				JDBCTableModel mod = new JDBCTableModel(conn, tableName);
				jtable = new JTableExtra(mod);
		//		JScrollPane scroller =
		//			new JScrollPane (jtable, 
		//				ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED, 
		//				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
			} catch(Exception e) {;}
		
			return jtable;
		}
		public void setLogging(boolean b) {bLogging = b;}
		public void logLine(String s) {logLines.addElement(s);}
		public void clearLog() {logLines.removeAllElements();}
		public void writeLog() {
			pseduoFile logFile = new pseduoFile("sqlquery.log");
			for (int i=0;i<logLines.size();i++) {
				logFile.appendFile((String)logLines.elementAt(i));
			}
			logFile.flush();
		}

		public boolean connect() {
			conn = null;
			try {
				Class.forName("com.mysql.jdbc.Driver").newInstance();
				TRACE("Mysql JDBC driver loaded",4);
				conn = DriverManager.getConnection("jdbc:mysql://" + dbHost 
						+ "/" + dbName,dbUser,dbPassword);
			} 
			catch(ClassNotFoundException e) {e.printStackTrace();
				TRACE("Class not found",4);
			} 
			catch(IllegalAccessException e) {e.printStackTrace();
				TRACE("Illegal access exception",4);
			}
			catch(InstantiationException e) {e.printStackTrace();
				TRACE("InstantiationException exception",4);
			}
			catch(SQLException e) {e.printStackTrace();
				TRACE("SQLException exception",4);
				TRACE(e.getMessage() + ":" + e.getSQLState(),4);
			}
			if(conn == null) {
					TRACE("JDBC did not connect",4);
					return false;
			}
			TRACE("JDBC connect sucess",4);
			TRACE("Product:"+getDatabaseProduct(),4);
			TRACE("Version:"+getDatabaseVersion(),4);
			return true;
		}
		public void disconnect() {
			if (conn != null) {
				try {
					conn.close();
					TRACE("JDBC Connection Closed",4);
				} catch (SQLException e) {
					TRACE(e.getMessage() + ":" + e.getSQLState(),4);
				}
			}
			conn = null;
			clearLog();
			setLogging(false);
		}
		public String getDatabaseProduct() {
			if (conn == null) {return "";}
			try {
				DatabaseMetaData dbMD = conn.getMetaData();
				return dbMD.getDatabaseProductName();
			} catch (SQLException e) {;}
			return "";
		}
		public String getDatabaseVersion() {
			if (conn == null) {return "";}
			try {
				DatabaseMetaData dbMD = conn.getMetaData();
				return dbMD.getDatabaseProductVersion();
			} catch (SQLException e) {;}
			return "";
		}
		public java.sql.Connection getConnection() {return conn;}
		public Vector getTableNames() {
			   Vector tableNames = new Vector();
			   if (conn != null) {
				   try {
					   DatabaseMetaData md = conn.getMetaData();
					   ResultSet mrs = md.getTables(null,null,null,new String[] {"TABLE"});
					   while (mrs.next()) {
						   tableNames.addElement(mrs.getString(3));
					   }
					   mrs.close();
				   }
				   catch (SQLException e) {
					   TRACE(e.getMessage() + ":" + e.getSQLState(),4);
				   }
			   }
			   return tableNames;
		}
		public Vector getColumnNames(String tableName) {
			   java.sql.Statement	stat = null;
			   String data = "";
			   ResultSet results = null;
			   Vector columnNames = new Vector();
			   if (conn != null) {
				   try {
					   stat = conn.createStatement();
					   results = stat.executeQuery("SELECT * FROM " + tableName + " LIMIT 1");
					   if (results != null) {
						   ResultSetMetaData mData = results.getMetaData();
						   int numCols = mData.getColumnCount();
						   for (int j=0;j<numCols;j++) 
						   	{columnNames.addElement(mData.getColumnName(j));}
						   results.close();
					   }
				   }
				   catch (SQLException e) {
					   TRACE(e.getMessage() + ":" + e.getSQLState(),4);
				   }
			   }
			   return columnNames;
		}
		public String executeSQLQuery(String query,String testData) {
			java.sql.Statement	stat = null;
			String data = "";
			ResultSet results = null;
			if (conn == null) {return testData;}
			if (bLogging) {logLine(query);}
			try {
				stat = conn.createStatement();
				if ( query.startsWith("SELECT") || query.startsWith("select")) {
					results = stat.executeQuery(query);
				} else {
					stat.executeUpdate(query);
				}
				if (results != null) {
					ResultSetMetaData mData = results.getMetaData();
					int numCols = mData.getColumnCount();
					while (results.next()) {
						for (int i=0;i<numCols;i++) {
							if (data.length() != 0) {data = data + ",";}
							// The first column in a ResultSet row has index 1, not 0
							data = data + results.getString(i+1);
						}
					}
				} else {
					data = testData;
				}

				SQLWarning w;
				for (w=conn.getWarnings();w != null;w=w.getNextWarning()) {
					TRACE("SQLWarning : " + w.getMessage() + " : " + w.getSQLState(),4);
				}

			} catch (SQLException e) {
				data = testData;
				TRACE(e.getMessage() + ":" + e.getSQLState(),4);
			}
					
			TRACE("JDBC query data:"+data,4);
			if (bLogging) {logLine(data);}
			return data;
		}
	}

	public class sounds {
	
		public class soundDesc {
			protected	String		soundURL;
			protected	AudioClip	soundAudioClip;
			protected	boolean		soundPlaying;
		
			soundDesc(AudioClip a,String b,boolean c) {
				soundURL = b;
				soundAudioClip = a;
				soundPlaying = c;
			}
			public void setAudioClip(AudioClip a) {soundAudioClip = a;}
			public void setPlaying(boolean b) {soundPlaying = b;}
			public void setSoundURL(String s) {soundURL = s;}
		}	
		private	Vector	acSounds = new Vector();
		private soundDesc sd; 
	

		public void createNumberSounds(int num) {
			// fudge the vector to contain num elements
			for(int i=0;i<num;i++) {
				sd = new soundDesc((AudioClip)null,"",false);
				acSounds.add(sd);
			}
		}

		public boolean loadAndPlaySound(final String soundURL, final int index) {
		   return loadSound(soundURL,index,false,true);
		}
		public boolean loadAndPlaySoundDirect(final String soundURL) {
		   return loadSound(soundURL,-1,false,true);
		}
		public boolean loadAndPlaySoundDirect(final String soundURL,boolean block) {
		   return loadSound(soundURL,-1,block,true);
		}
		public boolean loadAndPlaySound(final String soundURL, final int index,boolean block) {
		   return loadSound(soundURL,index,block,true);
		}
		
		public boolean loadSound(String soundURL,int index) {
			return loadSound(soundURL,index,false,false);
		}
		public boolean loadSound(String soundURL,int index,boolean block) {
			return loadSound(soundURL,index,block,false);
		}
		public boolean loadSound(final String soundURL, final int index, boolean block, final boolean play) {
			if(!block) {
				Thread t = new Thread(new Runnable() {
					public void run() {
						TRACE("Starting loading sound " + soundURL,3);
						AudioClip ac = getAudioClip(getCodeBase(),soundURL);
						if (index != -1) {
						   sd = new soundDesc(ac,soundURL,play);
						   acSounds.setElementAt(sd,index);
						}
						TRACE("Finished loading sound " + soundURL,3);
						if (play) {
						   TRACE("Playing loaded sound " + soundURL,3);
						   ac.play();
						}
					}
				});
				t.setPriority(systemSoundThreadPrioity);
				t.setName("System load sound thread");
				t.start();
			} else {
				AudioClip ac = getAudioClip(getCodeBase(),soundURL);
				soundDesc sd = new soundDesc(ac,soundURL,false);
				acSounds.setElementAt(sd,index);
			}
			return true;
		}
		public void unloadSound(int index) {
			if (index < 0 || index > acSounds.size()-1) {return;}
			acSounds.setElementAt((soundDesc)null,index);
		}
		public AudioClip getSoundClip(int index) {
			if (index < 0 || index > acSounds.size()-1) {return (AudioClip)null;}
			soundDesc sd = (soundDesc)acSounds.elementAt(index);
			return sd.soundAudioClip;
		}
		public boolean getSoundPlaying(int index) {
			if (index < 0 || index > acSounds.size()-1) {return false;}
			soundDesc sd = (soundDesc)acSounds.elementAt(index);
			return sd.soundPlaying;
		}
		public String getSoundURL(int index) {
			if (index < 0 || index > acSounds.size()-1) {return "";}
			soundDesc sd = (soundDesc)acSounds.elementAt(index);
			return sd.soundURL;
		}
		public int getSoundIndex(String soundURL) {
			for(int i=0;i<acSounds.size();i++) {
				soundDesc sd = (soundDesc)acSounds.elementAt(i);
				if (soundURL.equals(sd.soundURL)) {return i;}
			}
			return -1;
		}
		public void unloadAllSounds() {
			for(int i=0;i<acSounds.size();i++) {
				stopSound(i);
			}
			acSounds.removeAllElements();
		}
		public void playSound(int index) {
			if (index < 0 || index > acSounds.size()-1) {return;}
			soundDesc sd = (soundDesc)acSounds.elementAt(index);
			if(!sd.soundPlaying) {
				sd.soundPlaying = true;
				sd.soundAudioClip.play();
			}
		}
		public void stopSound(int index) {
			if (index < 0 || index > acSounds.size()-1) {return;}
			soundDesc sd = (soundDesc)acSounds.elementAt(index);
			if(sd.soundPlaying) {
				sd.soundPlaying = false;
				sd.soundAudioClip.stop();
			}
		}
		public void loopSound(int index) {
			if (index < 0 || index > acSounds.size()-1) {return;}
			soundDesc sd = (soundDesc)acSounds.elementAt(index);
			if(!sd.soundPlaying) {
				sd.soundPlaying = true;
				sd.soundAudioClip.loop();
			}
		}

	}
		
	public JToolBar setupToolBar(boolean floatable) {
		   JToolBar tBar = new JToolBar("");
		   tBar.setFloatable(floatable);
		   tBar.add(help);
		   return tBar;
	}
	public class aboutAction extends AbstractAction {
		   public aboutAction() {super("About");putValue(SHORT_DESCRIPTION,"Display About Box");}
		   public void actionPerformed(ActionEvent evt) {
		   		  TRACE("Pressed the display about box toolbar button",3);
				  systemUserReg.displayAboutBox();
		   }
	}
	public class helpAction extends AbstractAction {
		   public helpAction() {super("Toggle Help");putValue(SHORT_DESCRIPTION,"Toggle Help");}
		   public void actionPerformed(ActionEvent evt) {
		   		  TRACE("Pressed the help toolbar button",3);
//				  chatTab.toggleHelp();
		   }
	}
	
	public class customIconData {
		private Color	ciColor;
		private	boolean	ciFilled;
		private	int[]	ciX;
		private	int[]	ciY;
		
		public customIconData(int[] x,int[] y,Color c) {
			ciColor = c;
			ciFilled = true;
			ciX = x;
			ciY = y;
		}
	}
	public class customIcon implements Icon {
		   private Vector ciData = new Vector();
		   
		   public int getIconHeight() {return 16;}
		   public int getIconWidth() {return 16;}
		   public void paintIcon(Component c,Graphics g,int x,int y) {
			   for (int i=0;i<ciData.size();i++) {
				   customIconData ciDataItem = (customIconData)ciData.elementAt(i);
				   int[] x1 = new int[ciDataItem.ciX.length];
				   int[] y1 = new int[ciDataItem.ciY.length];
				   for (int j=0;j<ciDataItem.ciX.length;j++) {
					   x1[j] = ciDataItem.ciX[j] + x;
					   y1[j] = ciDataItem.ciY[j] + y;
				   }
				   g.setColor(ciDataItem.ciColor);
				   g.fillPolygon(x1,y1,ciDataItem.ciX.length);
			   }
		   }
		   public void clearData() {
			   ciData.removeAllElements();
		   }
		   public void addData(customIconData cid) {
			   ciData.addElement(cid);
		   }
	}
	public class customAction extends AbstractAction {
		   public customAction (String desc,customIcon ci) {
		   		  super(desc);
		   		  putValue(javax.swing.Action.SMALL_ICON,ci);
		   		  putValue(javax.swing.Action.SHORT_DESCRIPTION,desc);
		   }
		   public void actionPerformed(ActionEvent evt) {
		   }
	}
		
	public String listSupportedTargetTypes()
	{
		String	strMessage = "";
		AudioFileFormat.Type[]	aTypes = AudioSystem.getAudioFileTypes();
		for (int i = 0; i < aTypes.length; i++)
		{
			if (i>0) {strMessage += ",";}
			strMessage += aTypes[i].getExtension();
		}
		return strMessage;
	}

	public AudioFileFormat.Type findTargetType(String strExtension)
	{
		AudioFileFormat.Type[]	aTypes = AudioSystem.getAudioFileTypes();
		for (int i = 0; i < aTypes.length; i++)
		{
			if (aTypes[i].getExtension().equals(strExtension))
			{
				return aTypes[i];
			}
		}
		return null;
	}

	public boolean isPcm(AudioFormat.Encoding encoding)
	{
		return encoding.equals(AudioFormat.Encoding.PCM_SIGNED)
			|| encoding.equals(AudioFormat.Encoding.PCM_UNSIGNED);
	}

	public Mixer.Info getMixerInfo(String strMixerName)
	{
		Mixer.Info[]	aInfos = AudioSystem.getMixerInfo();
		for (int i = 0; i < aInfos.length; i++)
		{
			if (aInfos[i].getName().equals(strMixerName))
			{
				return aInfos[i];
			}
		}
		return null;
	}

	public SourceDataLine getSourceDataLine(String strMixerName,AudioFormat audioFormat,int nBufferSize) {
		   SourceDataLine line = null;
		   DataLine.Info  info = new DataLine.Info(SourceDataLine.class,audioFormat,nBufferSize);
		   try {
		   	   if (strMixerName != null) {
			   	  Mixer.Info mixerInfo = getMixerInfo(strMixerName);
				  if (mixerInfo == null) {
				  	 return null;
				  }
				  Mixer mixer = AudioSystem.getMixer(mixerInfo);
				  line = (SourceDataLine)mixer.getLine(info);
			   } else {
			   	 line = (SourceDataLine)AudioSystem.getLine(info);
			   }
			   line.open(audioFormat,nBufferSize);
		   }
		   catch (LineUnavailableException e) {e.printStackTrace();}
		   catch (Exception e) {e.printStackTrace();}
		   return line;
	}
	
	public TargetDataLine getTargetDataLine(String strMixerName,
							AudioFormat audioFormat,
							int nBufferSize)
	{
		TargetDataLine	targetDataLine = null;
		DataLine.Info	info = new DataLine.Info(TargetDataLine.class,
							 audioFormat, nBufferSize);
		try
		{
			if (strMixerName != null)
			{
				Mixer.Info	mixerInfo = getMixerInfo(strMixerName);
				if (mixerInfo == null)
				{
					return null;
				}
				Mixer	mixer = AudioSystem.getMixer(mixerInfo);
				targetDataLine = (TargetDataLine) mixer.getLine(info);
			}
			else
			{
				targetDataLine = (TargetDataLine) AudioSystem.getLine(info);
			}

			targetDataLine.open(audioFormat, nBufferSize);
		}
		catch (LineUnavailableException e) {e.printStackTrace();}
		catch (Exception e) { e.printStackTrace(); }
		return targetDataLine;
	}
	
	public void playSoundToEnd(String soundFile) {
		   int nInternalBufferSize = AudioSystem.NOT_SPECIFIED;
		   try {
		   	   URL u = new URL(soundFile);
		   	   AudioInputStream ais = AudioSystem.getAudioInputStream(u);
		   	   AudioFormat af = ais.getFormat();
		   	   DataLine.Info info = new DataLine.Info(SourceDataLine.class,af,nInternalBufferSize);
		  	   boolean isSupported = AudioSystem.isLineSupported(info);
		   	   if (!isSupported) {
		   	  	   int nSampleSizeInBits = 16;
			  	   boolean bBigEndian = false;
		   	  	   AudioFormat source = af;
			  	   AudioFormat	target = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,source.getSampleRate(),
					nSampleSizeInBits,source.getChannels(),source.getChannels() * (nSampleSizeInBits / 8),source.getSampleRate(),bBigEndian);
			  	   ais = AudioSystem.getAudioInputStream(target, ais);
			       af = ais.getFormat();
		   	   }	  
		  	   SourceDataLine line = getSourceDataLine(null,af,AudioSystem.NOT_SPECIFIED);
		   	   if (line == null) {return;}
		   	   line.start();
		   	   int nBytesRead = 0;
		   	   byte[] abData = new byte[128000];
		   	   while (nBytesRead != -1) {
				 nBytesRead = ais.read(abData,0,abData.length);
		   		 if (nBytesRead >=0) {
				 	int nBytesWritten = line.write(abData,0,nBytesRead);
				 }
			   }
		   	   line.drain();
		   	   line.close();
		} catch (Exception e) {e.printStackTrace();}
	}

	class colorIcon extends customIcon {
		  
		  public Color color;
		  
		  public colorIcon(Color color) {this.color = color;}
		  public void paintIcon(Component c,Graphics g,int x,int y) {
		  		 g.setColor(color);
				 g.fillRect(x,y,16,16);
		  } 
	}
	
	public interface colorActionUtils {
		public void colorSelected(Color c);
	}
	public class colorAction extends AbstractAction {
		   private	Color	 		color;
		   private	colorActionUtils	target;
		   
		   public colorAction(Color color) {
			   target = null;
		   	   this.color = color;
			   putValue(javax.swing.Action.SMALL_ICON,new colorIcon(color));
		   }
		   public void actionPerformed(ActionEvent evt) {
			   if (target != null) {target.colorSelected(color);}
		   }
		   public Color getColor() {return color;}
		   public void removeColorActionListener() {target = null;}
		   public void addColorActionListener(colorActionUtils cau) {target = cau;}
	}
	
public class XMLDocumentWriter {
    pseduoFile out;

    public XMLDocumentWriter(String filename) {	
		out = new pseduoFile(""+dataRelativePath+"/"+appDirectory,supportFunctions.getPathFilenameNoExt(filename) + ".xml");
		//out.saveFile("\n");
	}

    public void close() { out.flush(); }

    public void write(org.w3c.dom.Node node) { write(node, ""); }

    public void write(org.w3c.dom.Node node, String indent) {
	// The output depends on the type of the node
	switch(node.getNodeType()) {
	case org.w3c.dom.Node.DOCUMENT_NODE: {       // If its a Document node
	    org.w3c.dom.Document doc = (org.w3c.dom.Document)node;
	    out.saveFile(indent + "<?xml version='1.0'?>\n");  // Output header
	    org.w3c.dom.Node child = doc.getFirstChild();   // Get the first node
	    while(child != null) {              // Loop 'till no more nodes
		write(child, indent);           // Output node
		child = child.getNextSibling(); // Get next node
	    }
	    break;
	} 
	case org.w3c.dom.Node.DOCUMENT_TYPE_NODE: {  // It is a <!DOCTYPE> tag
	    DocumentType doctype = (DocumentType) node;
	    // Note that the DOM Level 1 does not give us information about
	    // the the public or system ids of the doctype, so we can't output
	    // a complete <!DOCTYPE> tag here.  We can do better with Level 2.
	    out.appendFile("<!DOCTYPE " + doctype.getName() + ">\n");
	    break;
	}
	case org.w3c.dom.Node.ELEMENT_NODE: {        // Most nodes are Elements
	    org.w3c.dom.Element elt = (org.w3c.dom.Element) node;
	    out.appendFile(indent + "<" + elt.getTagName());   // Begin start tag
	    NamedNodeMap attrs = elt.getAttributes();     // Get attributes
	    for(int i = 0; i < attrs.getLength(); i++) {  // Loop through them
		org.w3c.dom.Node a = attrs.item(i);
		out.appendFile(" " + a.getNodeName() + "='" +  // Print attr. name
			  fixup(a.getNodeValue()) + "'"); // Print attr. value
	    }
	    out.appendFile(">\n");                             // Finish start tag

	    String newindent = indent + "    ";           // Increase indent
	    org.w3c.dom.Node child = elt.getFirstChild();             // Get child
	    while(child != null) {                        // Loop 
		write(child, newindent);                  // Output child
		child = child.getNextSibling();           // Get next child
	    }

	    out.appendFile(indent + "</" +                   // Output end tag
			elt.getTagName() + ">\n");
	    break;
	}
	case org.w3c.dom.Node.TEXT_NODE: {                   // Plain text node
	    org.w3c.dom.Text textNode = (org.w3c.dom.Text)node;
	    String text = textNode.getData().trim();   // Strip off space
	    if ((text != null) && text.length() > 0)   // If non-empty
		out.appendFile(indent + fixup(text) + "\n");     // print text
	    break;
	}
	case org.w3c.dom.Node.PROCESSING_INSTRUCTION_NODE: {  // Handle PI nodes
	    ProcessingInstruction pi = (ProcessingInstruction)node;
	    out.appendFile(indent + "<?" + pi.getTarget() +
			       " " + pi.getData() + "?>\n");
	    break;
	}
	case org.w3c.dom.Node.ENTITY_REFERENCE_NODE: {        // Handle entities
	    out.appendFile(indent + "&" + node.getNodeName() + ";\n");
	    break;
	}
	case org.w3c.dom.Node.CDATA_SECTION_NODE: {           // Output CDATA sections
	    CDATASection cdata = (CDATASection)node;
	    // Careful! Don't put a CDATA section in the program itself!
	    out.appendFile(indent + "<" + "![CDATA[" + cdata.getData() +
			"]]" + ">\n");
	    break;
	}
	case org.w3c.dom.Node.COMMENT_NODE: {                 // Comments
	    Comment c = (Comment)node;
	    out.appendFile(indent + "<!--" + c.getData() + "-->\n");
	    break;
	}
	default:   // Hopefully, this won't happen too much!
	    System.err.println("Ignoring node: " + node.getClass().getName());
	    break;
	}
    }

    // This method replaces reserved characters with entities.
    String fixup(String s) {
	StringBuffer sb = new StringBuffer();
	int len = s.length();
	for(int i = 0; i < len; i++) {
	    char c = s.charAt(i);
	    switch(c) {
	    default: sb.append(c); break;
	    case '<': sb.append("&lt;"); break;
	    case '>': sb.append("&gt;"); break;
	    case '&': sb.append("&amp;"); break;
	    case '"': sb.append("&quot;"); break;
	    case '\'': sb.append("&apos;"); break;
	    }
	}
	return sb.toString();
    }
}

interface xslTransformerUtils {
	// e.g. void transformer.setParameter("name","value");
	// void transformer.clearParameters();
	//
	// String transformer.getOutputProperty(String name);
	// void transformer.setOutputProperty(String name,String value);
	// to clear a single property set value=null
	//
	public void preTransform(Transformer transformer);
}

/** Creates an XSLT transformer for processing an XML document.
 *  A new transformer, along with an style template are created 
 *  for each document transformation. The XSLT, DOM, and 
 *  SAX processors are based on system default parameters.
 */ 

public class XslTransformer {
  private TransformerFactory factory;
  private xslTransformerUtils target;

  public void addxslUtilsListener(xslTransformerUtils xtu) {target = xtu;}
  public void removexslUtilsListener() {target = null;}
  public XslTransformer() {
    factory =  TransformerFactory.newInstance();
    target = null;
  }

  /** Transform an XML and XSL document as <code>Reader</code>s,
   *  placing the resulting transformed document in a 
   *  <code>Writer</code>. Convenient for handling an XML 
   *  documents as a String (<code>StringReader</code>) residing
   *  in memory, not on disk. The output document could easily be
   *  handled as a String (<code>StringWriter</code>) or as a
   *  <code>JSPWriter</code> in a JavaServer page.
   */

  public void process(Reader xmlFile, Reader xslFile,
                      Writer output)
                throws TransformerException {
    process(new StreamSource(xmlFile),
            new StreamSource(xslFile),
            new StreamResult(output));
  }

  /** Transform an XML and XSL document as <code>File</code>s,
   *  placing the resulting transformed document in a 
   *  <code>Writer</code>. The output document could easily 
   *  be handled as a String (<code>StringWriter</code)> or as 
   *  a <code>JSPWriter</code> in a JavaServer page.
   */

  public void process(File xmlFile, File xslFile,
                      Writer output)
                throws TransformerException {
    process(new StreamSource(xmlFile),
            new StreamSource(xslFile),
            new StreamResult(output));
  }

  /** Transform an XML <code>File</code> based on an XSL 
   *  <code>File</code>, placing the resulting transformed 
   *  document in an <code>OutputStream</code>. Convenient for 
   *  handling the result as a <code>FileOutputStream</code> or 
   *  <code>ByteArrayOutputStream</code>.
   */

  public void process(File xmlFile, File xslFile,
                      OutputStream out)
                 throws TransformerException {
    process(new StreamSource(xmlFile),
            new StreamSource(xslFile),
            new StreamResult(out));
  }

  /** Transform an XML source using XSLT based on a new template
   *  for the source XSL document. The resulting transformed 
   *  document is placed in the passed in <code>Result</code> 
   *  object.
   */

  public void process(Source xml, Source xsl, Result result)
                throws TransformerException {
    try {
      Templates template = factory.newTemplates(xsl);
      Transformer transformer = template.newTransformer();
      if (target != null) {
	      target.preTransform(transformer);
      }
      transformer.transform(xml, result);
    } catch(TransformerConfigurationException tce) {
        throw new TransformerException(
                    tce.getMessageAndLocation());
    } catch (TransformerException te) {
      throw new TransformerException(
                  te.getMessageAndLocation());
    }
  }
}

public String doStringTransform(String xmlText,String xsltText) {
	return doTransform(new StreamSource(new StringReader(xmlText)),
			new StreamSource(new StringReader(xsltText)));
}
public String doFileTransform(String xmlFilename,String xsltFilename) {
	try {
		 return doTransform(
				 new StreamSource(new File(xmlFilename)),
				 new StreamSource(new File(xsltFilename)));
	} catch (Exception e) {e.printStackTrace();return "";}	
}
	public String doTransform(Source xml,Source xslt) {
		StringWriter writer = new StringWriter();
		Result out = new StreamResult(writer);
		try {
			XslTransformer trans = new XslTransformer();
			trans.process(xml,xslt,out);
		} catch(Exception e) {displayDialog(e.toString());}
		return writer.toString();
	}

// to make a memory XML data file persist call setFilename("...")
	public class memoryXmlDataFile extends xmlDataFile {
		private	String filename;
		
		memoryXmlDataFile() {
			filename = supportFunctions.getTmpFilename();
			openXMLDataFile(filename,"tmp");
		}
		protected void finalize() throws Throwable {
			closeXMLDataFile();
			if (getFilename().equals(filename)) {
				deleteFilename(""+dataRelativePath+"/"+appDirectory+"/"+filename+".xml");
			}
		}
	}
	public class configurationSettings extends xmlDataFile {
		public void newConfigurationSettings(String name) {
			createXMLDataFile(name,"ConfigurationSettings");
		}
		public void openConfigurationSettings(String name) {
			openXMLDataFile(name,"ConfigurationSettings");
		}
		public void openConfigurationSettings(String name,String rootElement) {
			openXMLDataFile(name,rootElement);
		}
		public String getConfigurationSetting(String name,String defaultValue) {
			if (!isOpen()) {return defaultValue;}
			NodeList nList = getXMLDocument().getElementsByTagName(name.trim());
			org.w3c.dom.Element first = (org.w3c.dom.Element)nList.item(0);
			// assumes all configuration names are unique
			String value = defaultValue;
			if (first != null) {value = first.getAttribute("value");}
			
			return value;
		}
		public void setConfigurationSetting(String name,String value) {
			if (!isOpen()) {return;}
			NodeList nList = getXMLDocument().getElementsByTagName(name.trim());
			org.w3c.dom.Element e = (org.w3c.dom.Element)nList.item(0);
			org.w3c.dom.Element setting = getXMLDocument().createElement(name);
			setting.setAttribute("value",value);
			if (e == null) {
				getRootElement().appendChild(setting);
			} else {
				getRootElement().replaceChild(setting,e);
			}
			saveXMLDataFile(); // GDB 21/05/2014
		}
		public void updateConfigurationSetting(String name,String value) {
			deleteConfigurationSetting(name);
			setConfigurationSetting(name,value);
		}
		public void deleteConfigurationSetting(String name) {
			if (!isOpen()) {return;}
			NodeList nList = getXMLDocument().getElementsByTagName(name.trim());
			org.w3c.dom.Element e = (org.w3c.dom.Element)nList.item(0);
			if (e != null) {getRootElement().removeChild(e);}
			saveXMLDataFile();
		}
		public void closeConfigurationSettings() {
			closeXMLDataFile();
		}
	}
	public class miniXMLEditor {
		private miniXMLEditor() {;}
		miniXMLEditor(String pathfilename,String rootElement) {
			xmlDataFile f = new xmlDataFile();
			if (f.openXMLDataFile(pathfilename,rootElement,false)) {
				f.miniXMLEditor();
			} else {
				displayDialog(pathfilename + ".xml not found.");
			}
		}
	} 
	// Element elementa = getXMLDocument().createElement("name");
	// elementb.appendChild(elementa);
	// elementa.setAttribute("name","value");
	// The first Element you appendChild to will be getRootElement()
	public class xmlDataFile {
		private	String 		csName,csRootElement;
		private	xmlBase 	csFile;
		private org.w3c.dom.Document	xmlDoc;
		private	org.w3c.dom.Element		root;
		
		xmlDataFile() {
			csName = "";
			csRootElement = "";
			csFile = null;
			xmlDoc = null;
			root = null;
		}
		public xmlBase getXmlBase() {return csFile;}
		public void miniXMLEditor() {csFile.miniXMLEditor();}
		public String getRootElementAsString() {return csRootElement;}
		public String getFilename() {return csName;}
		public void setFilename(String s) {	
			if (csFile != null) {
				csName = s;
				csFile.setXmlFilename(s + ".xml");
			}
		}
		public void createXMLDataFile(String name,String rootElement) {
			csFile = new xmlBase();
			csFile.setXmlFilename(name + ".xml");
			xmlDoc = csFile.getXmlDocument();
			root = xmlDoc.createElement(rootElement);
			xmlDoc.appendChild(root);
			csFile.saveXmlFile(true);
		}
		public boolean openXMLDataFile(String name,String rootElement) {
			return openXMLDataFile(name,rootElement,true);
		}
		public boolean openXMLDataFile(String name,String rootElement,boolean bForceCreate) {
			csName = name;
			csRootElement = rootElement;
			if (!supportFunctions.urlExists(name + ".xml")) {
				if (bForceCreate) {createXMLDataFile(name,rootElement);} else {return false;}
			} else {
				if (bForceCreate) {createXMLDataFile(name,rootElement);return true;}
				csFile = new xmlBase(name + ".xml");
				xmlDoc = csFile.getXmlDocument();
				if (xmlDoc == null) {
					return false;
				}
				root = xmlDoc.getDocumentElement();
			}
			
			return true;
		}
		public NodeList buildNodeList(String nodeName) {
			NodeList nl = xmlDoc.getElementsByTagName(nodeName);
			int num = nl.getLength();
			for (int i=0;i<num;i++) {
				processNode(nl.item(i));
			}
			return nl;
		}
		public void processNode(org.w3c.dom.Node n) {
			String name = n.getNodeName();
			short type = n.getNodeType();
			String value = n.getNodeValue(); // needs to child node value !!!
			NamedNodeMap attribs = n.getAttributes();
			String nodeAttribs = "";
			if (attribs != null && attribs.getLength() < 0) {
				for (int index=0;index<attribs.getLength();index++) {
					if (index != 0) {nodeAttribs = nodeAttribs + ",";}
					org.w3c.dom.Node n2 = attribs.item(index);
					nodeAttribs = nodeAttribs + n2.getNodeName() + "," + n2.getNodeValue();
				}
			}

			nodeFound(n,name,value,nodeAttribs);
		}
		public void nodeFound(org.w3c.dom.Node n,String name,String value,String attribs) {}
		public org.w3c.dom.Element getRootElement() {return root;}
		public org.w3c.dom.Document getXMLDocument() {return xmlDoc;}
		public boolean isOpen() {if (csFile == null) {return false;} else {return true;}}
		protected void finalize() throws Throwable {
			   //closeXMLDataFile();
			   super.finalize();
		}
		public void saveXMLDataFile() {
			if (csFile != null) {
				csFile.saveXmlFile(true);
			}
		}
		public void closeXMLDataFile() {
			if (csFile != null) {
				csFile.saveXmlFile(true);
				csFile = null;
				xmlDoc = null;
				root = null;
			}
		}
	}
	public class xmlNodeDialog extends JDialog implements ActionListener,TextListener {
		private JButton	butOK;
		private JButton butCancel;
		private	String nodeName,nodeValue,nodeAttrib;
	    private TextField nTFName,nTFValue,nTFAttrib; 
	    private boolean bOK = false;
	   
		public xmlNodeDialog(Frame parent,String name,String value,String attrib) {
		   super(parent,"New XML Node",true);
		   
		   nodeName = name;
		   nodeValue = value;
		   nodeAttrib = attrib;
		   
		   JPanel butPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		   butOK = new JButton("Ok");
		   butCancel = new JButton("Cancel");
		   butOK.addActionListener(this);
		   butCancel.addActionListener(this);
		   butOK.setMinimumSize(new Dimension(10*charWidth,charHeight));
		   butCancel.setMinimumSize(new Dimension(10*charWidth,charHeight));
		   butPanel.add(butOK);
		   butPanel.add(butCancel);
		   
			JPanel propSheetPanel = new JPanel();
			propSheetPanel.setLayout(new BoxLayout(propSheetPanel,BoxLayout.Y_AXIS));
			propSheetPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			propSheetPanel.add(new JLabel("Node Name",JLabel.LEFT));
			nTFName = new TextField("",30);
			nTFName.addTextListener(this);
			nTFName.setText(nodeName);
			propSheetPanel.add(nTFName);			
			propSheetPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			propSheetPanel.add(new JLabel("Node Value (for a text node)",JLabel.LEFT));
			nTFValue = new TextField("",30);
			nTFValue.addTextListener(this);
			nTFValue.setText(nodeValue);
			propSheetPanel.add(nTFValue);			
			propSheetPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
			propSheetPanel.add(new JLabel("Node Attributes (key1=value1,key2=value2,...)",JLabel.LEFT));
			nTFAttrib = new TextField("",30);
			nTFAttrib.addTextListener(this);
			nTFAttrib.setText(nodeAttrib);
			propSheetPanel.add(nTFAttrib);			
			add(propSheetPanel,"Center");
			add(butPanel,"South");
		   
		   addWindowListener(new WindowAdapter() {
   		     public void windowClosing(WindowEvent evt) {
			     dispose();
		     }
		   });
		   pack();
		   setVisible(true);
	   }
	  	   
	   public void destroy() {
	   	dispose();
	   }
	   public String getNodeName() {return nodeName;}
	   public String getNodeValue() {return nodeValue;}
	   public String getNodeAttrib() {return nodeAttrib;}
	   public void textValueChanged(TextEvent evt) {
		   if (evt.getSource() == nTFName) {nodeName = nTFName.getText();}
		   if (evt.getSource() == nTFValue) {nodeValue = nTFValue.getText();}
		   if (evt.getSource() == nTFAttrib) {nodeAttrib = nTFAttrib.getText();}
	   }
	   public boolean isOK() {return bOK;}
	   public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == butOK) {
			   bOK = true;
			   dispose();
		   }
		   if (evt.getSource() == butCancel) {
			   bOK = false;
			   dispose();
		   }
	   }
	}
	interface xmlBaseUtils {
		public org.w3c.dom.Element createNodePerformed(org.w3c.dom.Element e);
		public String getNodePerformed(String data);
		public org.w3c.dom.Element addNodePerformed(org.w3c.dom.Element e);
		public org.w3c.dom.Element updateNodePerformed(org.w3c.dom.Element e);
		public org.w3c.dom.Element deleteNodePerformed(org.w3c.dom.Element e);
	}
  public class xmlBase implements ActionListener, ErrorListener {
	private	xmlBaseUtils	target;
	private	JPanel	xmlPanel;
	private	boolean	xmlModified;
	private boolean	xmlDisplay;
	private	org.w3c.dom.Document	xmlDoc;
	private	msg3Dialog	xmlDialog;
	private	JTree	xmlTree;
	private	DocumentBuilder	builder;
	private	JButton	xmlNewEntryButton,xmlCloseButton,xmlDeleteButton,xmlSaveButton,xmlChangeButton,xmlNewChildButton;
	private String	xmlFilename;
		
	public xmlBase() {
		initxmlBase("");
	}
	public xmlBase(String filename) {
		initxmlBase(filename);
	}
	public xmlBase(URL url) {
		initxmlBase(url.toString());
	}
	public void initxmlBase(String filename) {
		initXmlFile(false);
		xmlFilename = filename;
		
		if (xmlFilename.length() == 0) {
			newXmlFile();
		} else {
			try {
				xmlDoc = builder.parse(new FileInputStream(filename));
			} catch(Exception e) {
				xmlDoc = null;
				if (e != null) {displayDialog("XML Parse Error In " + filename + ", " + e);}
			}		
		}
	}
	public org.w3c.dom.Element getElementSelected() {
		// to fix this only returns the first element of the selected name,
		// there could be more then one
		Object sel = xmlTree.getLastSelectedPathComponent();
		if (sel == null) {return (org.w3c.dom.Element)null;}
		String s = sel.toString();
		if (s.startsWith("#text")) {return (org.w3c.dom.Element)null;} // do not insert after text nodes
		Vector v = supportFunctions.splitIntoTokens(s,"(");
		s = (String)v.elementAt(0);
		NodeList nList = xmlDoc.getElementsByTagName(s.trim());
		org.w3c.dom.Element first = (org.w3c.dom.Element)nList.item(0);
		return first;
	}
	public org.w3c.dom.Element createNewElement(String ename,String evalue,String eattrib) {
		return createNewElement(ename,evalue,eattrib,true);
	}
	public org.w3c.dom.Element createNewElement(String ename,String evalue,String eattrib,boolean bDialog) {
		String name,value,attribs;
		if (bDialog) {
			xmlNodeDialog dlg = new xmlNodeDialog(parentFrame,ename,evalue,eattrib);
			if (!dlg.isOK()) {return null;}
			name = dlg.getNodeName();
			if (name.length() == 0) {return (org.w3c.dom.Element)null;}			
			value = dlg.getNodeValue();
			attribs = dlg.getNodeAttrib();
		} else {
			name = ename;
			value = evalue;
			attribs = eattrib;
		}

		Vector v = supportFunctions.splitIntoTokens(attribs,",");
	        
		//displayDialog("name:"+name+":value:"+value+":attribs:"+attribs);
		org.w3c.dom.Element node = xmlDoc.createElement(name);
		if (value.length() !=0) {node.appendChild(xmlDoc.createTextNode(value));}
		for (int i=0;i<v.size();i++) {
			Vector v1 = supportFunctions.splitIntoTokens((String)v.elementAt(i),"=");
			if(v1.size() == 2) {node.setAttribute((String)v1.elementAt(0),(String)v1.elementAt(1));}
		}

		if (target != null ) {
			node = target.createNodePerformed(node);
		}
		
		return node;
	}
	public void actionPerformed(ActionEvent evt) {
		if (evt.getSource() == xmlDeleteButton) {
			org.w3c.dom.Element first = getElementSelected();
			if (target != null ) {
				first = target.deleteNodePerformed(first);
				if (first == null) {return;} // GDB 170118
			}	
			
			xmlDoc.getDocumentElement().removeChild(first); // xmlDoc.getDocumentElement() is the root element
		}
		if (evt.getSource() == xmlSaveButton) {
			saveXmlFile();
		}
		if (evt.getSource() == xmlCloseButton) {
			hidexmlBase();
		}
		if (evt.getSource() == xmlNewEntryButton || evt.getSource() == xmlNewChildButton) {
			org.w3c.dom.Element node = createNewElement("","","");
			if (node == null) {return;} // GDB 170118
	
			org.w3c.dom.Element first = getElementSelected();
			if (target != null ) {
				node = target.addNodePerformed(node);
				if (node == null) {return;} // GDB 170118
			}		
						
			try {
				if (evt.getSource() == xmlNewEntryButton) {
					first.getParentNode().appendChild(node);
				} else {
					first.appendChild(node);
				}
			} catch (Exception e) {displayDialog("Node Insertion Error");}

			updateXmlTree();			
		}
		if (evt.getSource() == xmlChangeButton) {
			org.w3c.dom.Element first = getElementSelected();
			String nodeValue = "";
			switch(first.getNodeType()) {
				case org.w3c.dom.Node.TEXT_NODE:                    
					org.w3c.dom.Text textNode = (org.w3c.dom.Text)first;
					nodeValue = textNode.getData().trim(); 
					if (nodeValue == null) {nodeValue = "";}
					break;
			}
			String nodeAttrib  = "";
			NamedNodeMap elementAttributes = first.getAttributes();
			if (elementAttributes != null && elementAttributes.getLength() > 0) {
				int numAttributes = elementAttributes.getLength();
				for(int i=0; i<numAttributes; i++) {
					org.w3c.dom.Node attribute = elementAttributes.item(i);
					if (i > 0) {nodeAttrib = nodeAttrib + ", ";}
					nodeAttrib = nodeAttrib + attribute.getNodeName() + "=" + attribute.getNodeValue();
				}
			}
			org.w3c.dom.Element node = createNewElement(first.getNodeName(),nodeValue,nodeAttrib);
			if (node == null) {return;} // GDB 170118

			if (target != null ) {
				node = target.updateNodePerformed(node);
				if (node == null) {return;} // GDB 170118
			}

			first.replaceChild(node,first);				
			updateXmlTree();			
		}
	}
	public void updateXmlTree() {
		boolean bDisplayed=xmlBaseDisplayed();
		hidexmlBase();
		treeXmlDocument();		
		if (bDisplayed) {showxmlBase();} 
		xmlModified=true;
		setXmlTitle();
	}
	public void addXmlUtilsListener(xmlBaseUtils xeu) {target = xeu;}
	public void removeXmlUtilsListener() {target = null;}
	public String setXmlTitle() {
		if (xmlDialog!= null) {
			String file = "";
			String modified = "";
			
			if (xmlFilename.length() == 0) {
				file = "Untitled";
			} else {
				file = xmlFilename;
			}
			
			if (xmlModified) {
				modified = " (Modified)";
			}
			
			xmlDialog.setTitleString("XML Editor - " + file + modified);
			return file + modified;
		}
		return "";
	}
			
	public void initXmlFile(boolean bValidate) {
		xmlDoc = null;
		xmlDialog = null;
		xmlModified = false;
		xmlDisplay = false;
		xmlTree = null;
		xmlPanel = null;
		builder = null;
		target = null;
		xmlFilename = "";

		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			dbf.setValidating(bValidate);
			dbf.setNamespaceAware(true);
			builder = dbf.newDocumentBuilder();
			builder.setErrorHandler(new org.xml.sax.ErrorHandler() {
				public void warning(SAXParseException e) {}
				public void error(SAXParseException e) {}
				public void fatalError(SAXParseException e) throws SAXException {throw e;}
			});
		} catch (Exception e) {e.printStackTrace();}
	}
	public void newXmlFile() {
		xmlDoc = builder.newDocument();
	}
	public JPanel getXmlPanel() {return xmlPanel;}
	public boolean xmlBaseDisplayed() {return xmlDisplay;}
	public void miniXMLEditor() {showxmlBase();}
	public void showxmlBase() {
		treeXmlDocument();		
		xmlDialog = displayPanelDialog(xmlPanel,"XML Editor");
		setXmlTitle();
		xmlDisplay = true;
	}
	public void hidexmlBase() {
		if (xmlDialog != null) {
			xmlDialog.destory();
			xmlDialog.dispose();
		}
		xmlDisplay = false;
	}
	public void closexmlBase() {
		if (xmlModified) {
			saveXmlFile();
		}
		hidexmlBase();
	}
	public void setXmlFilename(String s) {xmlFilename = s;}
	public String getXmlFilename() {return xmlFilename;}
	public void saveXmlFile() {
		saveXmlFile(false);
	}
	public void saveXmlFile(boolean bForce) {
		int response;
		
		if (xmlDoc == null) {TRACE("saveXmlFile:not saving:"+xmlFilename,4);return;}
		
		if (!bForce) {
			response = JOptionPane.showConfirmDialog(null,"Save current changes","XML Editor",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE);
		} else {
			response = JOptionPane.YES_OPTION;
		}
		if (response == JOptionPane.YES_OPTION) {
			if (xmlFilename.length() == 0) {
				xmlFilename = JOptionPane.showInputDialog(null,"XML Editor","Enter filename to save as",JOptionPane.QUESTION_MESSAGE);
			}
			if (xmlFilename != null) {
				TRACE("saveXmlFile:"+xmlFilename,4);
				XMLDocumentWriter docWriter = new XMLDocumentWriter(xmlFilename);
				docWriter.write(xmlDoc);
				docWriter.close();
				xmlModified = false;
				setXmlTitle();
				try {Thread.sleep(1000);} catch (Exception e) {;}
			}
		}
	}
	
	public void treeXmlDocument() {
		if (xmlDoc == null) return;
		org.w3c.dom.Element rootElement = xmlDoc.getDocumentElement();
		DefaultMutableTreeNode root = buildXmlTree(rootElement);
		
		xmlTree = new JTree(root);
		JScrollPane sp = new JScrollPane(xmlTree);
		xmlNewEntryButton = new JButton("New Entry");
		xmlSaveButton = new JButton("Save");
		xmlCloseButton = new JButton("Close");
		xmlChangeButton = new JButton("Edit");
		xmlDeleteButton = new JButton("Delete");
		xmlNewChildButton = new JButton("New Child");
		xmlNewEntryButton.addActionListener(this);
		xmlSaveButton.addActionListener(this);
		xmlCloseButton.addActionListener(this);
		xmlDeleteButton.addActionListener(this);
		xmlChangeButton.addActionListener(this);
		xmlNewChildButton.addActionListener(this);
		
		xmlPanel = new JPanel();
		xmlPanel.setLayout(new BoxLayout(xmlPanel,BoxLayout.Y_AXIS));
		xmlPanel.add(sp);
		xmlPanel.add(Box.createRigidArea(new Dimension(charWidth,charHeight)));
		JPanel p = new JPanel();
		p.setLayout(new GridLayout(2,3));
		p.add(xmlNewEntryButton);
		p.add(xmlNewChildButton);
		p.add(xmlChangeButton);
		p.add(xmlDeleteButton);
		p.add(xmlSaveButton);
		p.add(xmlCloseButton);
		xmlPanel.add(p);
	}
	public JTree getXmlTree() {return xmlTree;}
	public org.w3c.dom.Document getXmlDocument() {return xmlDoc;}
	
	public DefaultMutableTreeNode buildXmlTree(org.w3c.dom.Element rootElement) {
		DefaultMutableTreeNode rootTreeNode = new DefaultMutableTreeNode(treeNodeLabel(rootElement));
		addChildren(rootTreeNode, rootElement);
		return(rootTreeNode);
	}
	public void addChildren
                       (DefaultMutableTreeNode parentTreeNode,
                        org.w3c.dom.Node parentXMLElement) {
    
		NodeList childElements = parentXMLElement.getChildNodes();
		for(int i=0; i<childElements.getLength(); i++) {
			org.w3c.dom.Node childElement = childElements.item(i);
			if (!(childElement instanceof org.w3c.dom.Text || childElement instanceof Comment)) {
				DefaultMutableTreeNode childTreeNode = new DefaultMutableTreeNode(treeNodeLabel(childElement));
				parentTreeNode.add(childTreeNode);
				addChildren(childTreeNode, childElement);
			}
		}
	}
  	public String treeNodeLabel(org.w3c.dom.Node childElement) {
		NamedNodeMap elementAttributes = childElement.getAttributes();
		String treeNodeLabel = childElement.getNodeName();
		
		String nodeValue = null;
		switch(childElement.getNodeType()) {
			case org.w3c.dom.Node.TEXT_NODE:                    
				org.w3c.dom.Text textNode = (org.w3c.dom.Text)childElement;
				nodeValue = textNode.getData().trim();  
				if (nodeValue != null && nodeValue.length()>0) {
					treeNodeLabel = treeNodeLabel + "=" + nodeValue;
				}
				break;
		}
		
		if (elementAttributes != null && elementAttributes.getLength() > 0) {
			treeNodeLabel = treeNodeLabel + " (";
			int numAttributes = elementAttributes.getLength();
			for(int i=0; i<numAttributes; i++) {
				org.w3c.dom.Node attribute = elementAttributes.item(i);
				if (i > 0) {treeNodeLabel = treeNodeLabel + ", ";}
				treeNodeLabel = treeNodeLabel + attribute.getNodeName() + "=" + attribute.getNodeValue();
			}
			treeNodeLabel = treeNodeLabel + ")";
		}
		return(treeNodeLabel);
	}
	
	// Transformers are required to continue processing after warning, unless the
	// application throws TransformerException
	public void warning(TransformerException te) throws TransformerException {
		xmlError(te);
	}
	public void error(TransformerException te) throws TransformerException {
		xmlError(te);
	}
	public void fatalError(TransformerException te) throws TransformerException {
		xmlError(te);
	}
	public String xmlError(TransformerException te) {
		SourceLocator loc = te.getLocator(); // may be null
		
		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		
		pw.println(te.getClass().getName());
		if (loc != null) {
			pw.println("Line Number  : " + loc.getLineNumber());
			pw.println("Column Number: " + loc.getColumnNumber());
			pw.println("Public ID    : " + loc.getPublicId());
			pw.println("System ID    : " + loc.getSystemId());
		}
		
		pw.println("Message & Location: " + te.getMessageAndLocation());
		pw.println("Location          : " + te.getLocationAsString());
		//te.getException();
		//te.getCause();
		
		return sw.toString();
	}
}

public class pseduoFile extends ehsFile {
	private boolean bModified = false;
	private boolean bStripBlankLines = true;
	private Vector fileLines = new Vector();

	public pseduoFile(String dir,String file) {
		super(dir,file);
	}
	public pseduoFile(String pathfilename) {
		super(supportFunctions.getPath(pathfilename),supportFunctions.getFilename(pathfilename));
	}
	public void setStripBlankLines(boolean b) {
		bStripBlankLines = b;
	}
	public void saveFile(String data) {
		fileLines.removeAllElements();
		fileLines.addElement(data);
		bModified = true;
	}
	public void removeLastFileLine() {
		String fileData = "";
		for (int i=0;i<fileLines.size();i++) {
			fileData = fileData + (String)fileLines.elementAt(i);
		}
		fileLines.removeAllElements();
		Vector v = supportFunctions.splitIntoTokens(fileData,"\n");
		for (int i=0;i<v.size()-1;i++) { // -1 because we don't want the last line
			fileLines.addElement((String)v.elementAt(i) + "\n");
		}
		bModified = true;
	}
	public void appendFile(String data) {
		fileLines.addElement(data);
		bModified = true;
	}	
	protected void finalize() throws Throwable {
		flush();
		super.finalize();
	}
	public void flush() {
		if (!bModified) {return;}
		
		if (isApplication()) {
			String filename = ehsDir + "\\" + ehsFile1;
			TRACE("Flushing file:"+filename,4);
			try {
				FileWriter out = new FileWriter(filename);
				for (int i=0;i<fileLines.size();i++) {out.write((String)fileLines.elementAt(i));}
				out.flush();
				out.close();
			}  catch (IOException e) {e.printStackTrace();}
			return;
		}
		
		String fileData = "";
		for (int i=0;i<fileLines.size();i++) {
			fileData = fileData + (String)fileLines.elementAt(i);
		}
		if (bStripBlankLines) {
			fileData = fileData.replaceAll("\\n{2,}","\n");
			fileData = fileData.replaceAll("\\t+\\n","");
		}
		String[] params = {"data",fileData,"file",ehsFile1,"dir",ehsDir};
		String result = supportFunctions.executePostURL(remoteHostRelativePath+"/webcommon/files.php",params,"test data");
	}
}
 public class ehsFile {
	protected String ehsDir,ehsFile1;
	int nextFileLine = 0;
	boolean fileRead = false;
	Vector fileLines = new Vector();
	Vector files = new Vector();
	Vector filetypes = new Vector();
	
	public ehsFile() {
		this("","");
	}
	public void setPathFilename (String pathfilename) {
		ehsDir = supportFunctions.getPath(pathfilename);
		ehsFile1 = supportFunctions.getFilename(pathfilename);
	}
	public ehsFile(String pathfilename) {
		this(supportFunctions.getPath(pathfilename),supportFunctions.getFilename(pathfilename));
	}
	public ehsFile(String dir,String file) {
		ehsFile1 = file;
		ehsDir = dir;
		resetReadFlag();
	}
	public int maxLineLengthInChars() {
		int maxlen = 0;
		for (int i=0;i<fileLines.size();i++) {
			String tmp = (String)fileLines.elementAt(i);
			if (tmp.length() > maxlen) {maxlen = tmp.length();}
		}
		return maxlen;
	}
	public int find(String findString,int startLine) {
		if (startLine >= 0 && startLine < fileLines.size()) {
			for (int i=startLine;i<fileLines.size();i++) {
				String tmp = (String)fileLines.elementAt(i);
				if (tmp.indexOf(findString) != -1) {return i;}
			}
		}
		
		return -1;
	}
	public int replace(String findString,String replaceString,int startLine) {
		if (startLine > 0 && startLine < fileLines.size()) {
			int foundLine = find(findString,startLine);
			if (foundLine == -1) {return -1;}
			String tmp = (String)fileLines.elementAt(foundLine);
			tmp = tmp.replaceAll(findString,replaceString);
			fileLines.setElementAt(tmp,foundLine);
			return foundLine;
		}
		
		return -1;
	}
	public void resetReadFlag() {
		fileRead = false;
		nextFileLine = 0;
		fileLines.removeAllElements();
	}
	public String readFileLine(int line) {
		if (!fileRead) {
			resetReadFlag();
			String tmp = loadFile();
			fileLines = supportFunctions.splitIntoTokens(tmp,"\n");
			fileRead =  true;
		}
		if (line < fileLines.size()) {
			nextFileLine = line + 1;	// so readFileLine() will read from the next file line
			return (String)fileLines.elementAt(line);
		} 
		
		return (String)null;
	}
	public String readFileLine() {
		String tmp = readFileLine(nextFileLine);
		TRACE("RFL: ("+String.valueOf(nextFileLine-1)+") " + tmp,4);
		//nextFileLine++; // done in  readFileLine(...)
		return tmp;
	}
	public void setCurrentLineNum(int lineNum) {
		if (!fileRead) {return;}
		if (lineNum < 0 || lineNum >= fileLines.size()) {return;}
		nextFileLine = lineNum;
	}
	public int getCurrentLineNum() {
		return nextFileLine - 1; // as points to next file line to be read
	}
	public String getFileLine(int lineNum) {
		if (!fileRead) {return (String)null;}
		if (lineNum < 0 || lineNum >= fileLines.size()) {return (String)null;}
		
		return (String)fileLines.elementAt(lineNum);
	}
	public void setFileLine(int lineNum,String line) {
		if (!fileRead) {return;}
		if (lineNum < 0 || lineNum >= fileLines.size()) {return;}
		
		fileLines.setElementAt(line,lineNum);
	}
	public String[] readFileLines(int startLine,int endLine) {
		if (startLine < 0 || endLine >= fileLines.size()) {return (String[])null;}
		String[] lines = new String[(endLine - startLine)];
		Vector v = new Vector();
		for (int i=startLine;i<=endLine;i++) {
			v.addElement((String)fileLines.elementAt(i));
		}
		v.copyInto(lines);
		return lines;
	}
	public int numberFileLines() {
		return fileLines.size();
	}
	public void setdirectory(String tmp) {
		ehsDir = tmp;
	}
	public void deleteFile() {
		if (isApplication()) {(new File(ehsDir+"/"+ehsFile1)).delete();return;}
		TRACE("Deleting file " + ehsDir + " " + ehsFile1,4);
		execute("delete","");
	}
	public void chmod(String data) {
		if (isApplication()) {return;}
		execute("chmod",data);
	}
	public void mkdir(String newdir) {
		if (isApplication()) {(new File(newdir)).mkdir();return;}
		execute("mkdir",newdir);
	}
	public String getcwd() {
		if (isApplication()) {return "";}
		String tmp = execute("getcwd","");
		return tmp;
	}
	public Vector getFiles() {return files;}
	public Vector getFileTypes() {return filetypes;}
	public String listFiles() {
		files.removeAllElements();
		filetypes.removeAllElements();
		if (isApplication()) {
			String tmp = "";
			File dir = new File(ehsDir);
			String[] files1 = dir.list();
			for (int i=0;i<files1.length;i++) {
				File f = new File(dir,files1[i]);
				files.addElement(files1[i]);
				tmp = tmp + "," + files1[i];
				if (f.isDirectory()) {
					filetypes.addElement("dir");
					tmp = tmp + ",dir";
				} else {
					filetypes.addElement("file");
					tmp = tmp + ",file";
				}
			}
			return tmp;
		}
		String tmp = execute("dir","");
		tmp = tmp.trim();
		//displayDialog(tmp);
		Vector v = supportFunctions.splitIntoTokens(tmp,",");
		for (int i=0;i<v.size();i=i+2) {
			files.addElement((String)v.elementAt(i));
			filetypes.addElement((String)v.elementAt(i+1));
		}
		return tmp;
	}
	public String loadFile() {
		// to read the correct file (applet) the directory supplied in
		// 'ehsDir' is relative to the directory the PHP script is run from (e.g. webcommon)
		if (isApplication()) {
			return supportFunctions.readTextFile(ehsDir + "/" + ehsFile1,true);
		} else {
			return supportFunctions.readTextFile(remoteHostRelativePath+"/webcommon/" + ehsDir + "/" + ehsFile1,true);
		}
	}
	public void saveFile(String data) {
		execute("write",data);
	}
	public void appendFile(String data) {
		execute("append",data);
	}
	public String execute(String opCode,String data) {
		String[] params = {"file",ehsFile1,"dir",ehsDir,"data",data,"op",opCode};
		return supportFunctions.executeGetURL(remoteHostRelativePath+"/webcommon/files.php",params,"");
	}
}

	public class classDetails {
		private Vector constructorStrings = new Vector();
		private Vector methodStrings = new Vector();
		private Vector fieldStrings = new Vector();
		private String classHeader = "";
		
		public classDetails(Class c) {
			if (c.isInterface()) {
				classHeader = Modifier.toString(c.getModifiers()) + " " + typename(c);
			}
			else if (c.getSuperclass() != null) {
				classHeader = Modifier.toString(c.getModifiers()) + " class " +
			     typename(c) + " extends " + typename(c.getSuperclass());
			}
			else {
				classHeader = Modifier.toString(c.getModifiers()) + " class " + typename(c);
			}
	
			Class[] interfaces = c.getInterfaces();
			if ((interfaces != null)&& (interfaces.length > 0)) {
				if (c.isInterface()) classHeader = classHeader + " extends ";
				else classHeader = classHeader + " implements ";
				for(int i = 0; i < interfaces.length; i++) {
					if (i > 0) classHeader = classHeader + ", ";
					classHeader = classHeader + typename(interfaces[i]);
				}
			}
	
//			System.out.println(" {");            // Begin class member listing.
	
			Constructor[] constructors = c.getDeclaredConstructors();
			for(int i = 0; i < constructors.length; i++)   // Display constructors.
				constructorStrings.add(getMethodOrConstructor(constructors[i]));
			Field[] fields = c.getDeclaredFields();           // Look up fields.
			for(int i = 0; i < fields.length; i++)            // Display them.
				fieldStrings.add(getField(fields[i]));
			Method[] methods = c.getDeclaredMethods();        // Look up methods.
			for(int i = 0; i < methods.length; i++)           // Display them.
				methodStrings.add(getMethodOrConstructor(methods[i]));
	
//			System.out.println("}");             // End class member listing.
			
		}
		
		public String getClassHeader() {return classHeader;}
		public Vector getMethodStrings() {return methodStrings;}
		public Vector getFieldStrings() {return fieldStrings;}
		public Vector getConstructorStrings() {return constructorStrings;}
		
		public String typename(Class t) {
			String brackets = "";
			while(t.isArray()) {
				brackets += "[]";
				t = t.getComponentType();
			}
			String name = t.getName();
			int pos = name.lastIndexOf('.');
			if (pos != -1) name = name.substring(pos+1);
			return name + brackets;
		}
    
		public String modifiers(int m) {
			if (m == 0) return "";
			else return Modifier.toString(m) + " ";
		}
    
		public String getField(Field f) {
			return "  " + modifiers(f.getModifiers()) +
			   typename(f.getType()) + " " + f.getName() + ";";
		}
    
		public String getMethodOrConstructor(Member member) {
			String ret = "";
			Class returntype=null, parameters[], exceptions[];
			if (member instanceof Method) {
				Method m = (Method) member;
				returntype = m.getReturnType();
				parameters = m.getParameterTypes();
				exceptions = m.getExceptionTypes();
				ret = "  " + modifiers(member.getModifiers()) +
					typename(returntype) + " " + member.getName() + "(";
			} else {
				Constructor c = (Constructor) member;
				parameters = c.getParameterTypes();
				exceptions = c.getExceptionTypes();
				ret = "  " + modifiers(member.getModifiers()) +
					typename(c.getDeclaringClass()) + "(";
			}
	
			for(int i = 0; i < parameters.length; i++) {
				if (i > 0) System.out.print(", ");
				ret = ret + typename(parameters[i]);
			}
			ret = ret + ")";
			if (exceptions.length > 0) System.out.print(" throws ");
			for(int i = 0; i < exceptions.length; i++) {
				if (i > 0) System.out.print(", ");
				ret = ret + typename(exceptions[i]);
			}
			ret = ret + ";";
			
			return ret;
		}
	}

	public class propertyValue {
		private	String label;
		private String value;
		private JTextField field;
		
		propertyValue(String label,String value) {
			this.label = label;
			this.value = value;
			this.field = null;
		}
		public String getLabel() {return label;}
		public String getValue() {return value;}
		public void setValue(String s) {value = s;}
		public JTextField getField() {return field;}
		public void setField(JTextField tmp) {field = tmp;}
	}
	public interface propSheetCanvasUtils {
		public void propSheetUpdate(String propSheetName);
	}
	public class propSheetCanvas  extends printableCanvas implements ActionListener {
		private JPanel propSheetPanel;
		private String propSheetCanvasName;
		private msg3Dialog propSheetCanvasPanel;
		private Vector properties = new Vector();
		private	propSheetCanvasUtils target;
		private JCustomButton butOK,butReset;

		public propSheetCanvas() {
			this("");
		}
		public propSheetCanvas(String name) {
			propSheetCanvasPanel = null;
			propSheetCanvasName = name;
			butOK = new JCustomButton("OK","Apply Changes",null);
			butReset = new JCustomButton("Reset","Reset Changes",null);
			butOK.addActionListener(this);
			butReset.addActionListener(this);
		}
		public void removeAllProps() {
			properties.removeAllElements();
		}
		public void addProp(String label,String value) {
			properties.addElement(new propertyValue(label,value));
		}
		public String getPropAsString(int index) {
			if (index >= properties.size()) return "";
			propertyValue pV = (propertyValue)properties.elementAt(index);
			return pV.getValue();
		}
		public int getPropAsInt(int index) {
			if (index >= properties.size()) return 0;
			propertyValue pV = (propertyValue)properties.elementAt(index);
			return Integer.parseInt(pV.getValue());
		}
		public Vector getProps() {return properties;}
		public void propSheetCanvasCreate() {
			propSheetPanel = new JPanel();
			propSheetPanel.setLayout(new GridLayout(0,2));
			for (int i=0;i<properties.size();i++) {
				propertyValue pV = (propertyValue)properties.elementAt(i);
				propSheetPanel.add(new JLabel(pV.getLabel()));
				JTextField tmp = new JTextField(pV.getValue(),10);
				pV.setField(tmp);
				propSheetPanel.add(tmp);
			}
			propSheetPanel.add(butOK);
			propSheetPanel.add(butReset);
		}
		public void propSheetCanvasShow() {
			if (propSheetCanvasPanel == null) {propSheetCanvasPanel = displayPanelDialog(propSheetPanel,propSheetCanvasName);}
		}
		public void propSheetCanvasHide() {
			if (propSheetCanvasPanel != null) {
				propSheetCanvasPanel.destory();
				propSheetCanvasPanel.dispose();
				propSheetCanvasPanel = null;
			}
		}
		public String propSheetCanvasName() {return propSheetCanvasName;}
		public void propSheetCanvasSize(int width,int hieght) {
			propSheetPanel.setSize(width,hieght);
		}
		public void actionPerformed(ActionEvent evt) {
			if (evt.getSource() == butOK) {
				for (int i=0;i<properties.size();i++) {
					propertyValue pV = (propertyValue)properties.elementAt(i);
					pV.setValue(pV.getField().getText());
				}
				if (target != null) {target.propSheetUpdate(propSheetCanvasName);}
			} else {
				for (int i=0;i<properties.size();i++) {
					propertyValue pV = (propertyValue)properties.elementAt(i);
					pV.getField().setText(pV.getValue());
				}
			}
		}
		public void addPropSheetCanvasListener(propSheetCanvasUtils bcu) {target = bcu;}
		public void removePropSheetCanvasListener() {target = null;}
	}
	public interface buttonCanvasUtils {
		public void buttonPressed(ActionEvent evt);
		public void buttonRightClicked(MouseEvent evt);
		public void buttonLeftClicked(MouseEvent evt);
		public void buttonDoubleClicked(MouseEvent evt);
	}
	public class buttonCanvas  extends printableCanvas implements ActionListener,MouseListener {
		private JPanel buttonPanel;
		private	int buttonCols;
		private Vector buttons = new Vector();
		private String buttonCanvasName;
		private	buttonCanvasUtils target;
		private msg3Dialog buttonCanvasPanel;
		
		public buttonCanvas(String name) {
			this(name,2);
		}
		public buttonCanvas(String name,int cols) {
			target = null;
			buttonCanvasPanel = null;
			buttonCanvasName = name;
			buttonCols = cols;
		}
		public void buttonCanvasClear() {
			buttons.removeAllElements();
		}
		public msg3Dialog buttonCanvasPanel() {
			return buttonCanvasPanel;
		}
		public void buttonCanvasAdd(JCustomButton b) {
			buttons.add(b);
		}
		public void buttonCanvasShow() {
			if (buttonCanvasPanel == null) {buttonCanvasPanel = displayPanelDialog(buttonPanel,buttonCanvasName);}
		}
		public void buttonCanvasHide() {
			if (buttonCanvasPanel != null) {
				buttonCanvasPanel.destory();
				buttonCanvasPanel.dispose();
				buttonCanvasPanel = null;
			}
		}
		public void buttonCanvasCreate() {
			buttonPanel = new JPanel();
			buttonPanel.setLayout(new GridLayout(0,buttonCols));
			for(int i=0;i<buttons.size();i++) {
				JCustomButton b = (JCustomButton)buttons.elementAt(i);
				b.addActionListener(this);
				b.addMouseListener(this);
				buttonPanel.add(b);
			}
		}
		public int buttonCanvasNumButtons() {return buttons.size();}
		public JCustomButton buttonCanvasButton(int index) {return (JCustomButton)buttons.elementAt(index);}
		public void actionPerformed(ActionEvent evt) {
			if (target != null) {target.buttonPressed(evt);}
		}
		public void addButtonCanvasListener(buttonCanvasUtils bcu) {target = bcu;}
		public void removeButtonCanvasListener() {target = null;}
		public String buttonCanvasName() {return buttonCanvasName;}
		public void buttonCanvasSize(int width,int hieght) {
			buttonPanel.setSize(width,hieght);
		}
		public void mouseEntered(MouseEvent evt) {}
		public void mouseExited(MouseEvent evt) {}
		public void mouseClicked(MouseEvent evt) {
				if (evt.getClickCount() == 2) {if (target != null) {target.buttonDoubleClicked(evt);}}
		}
		public void mousePressed(MouseEvent evt) {
			  int button = evt.getModifiers();
			  if ((button & MouseEvent.BUTTON3_MASK) != 0) {if (target != null) {target.buttonRightClicked(evt);}} else {if (target != null) {target.buttonLeftClicked(evt);}}
		}
		public void mouseReleased(MouseEvent evt) {}
	}

	public class colorButtonCanvas implements msg3DialogUtils {
		private buttonCanvas canvas;
		
		public colorButtonCanvas() {
			String c1 = systemUserReg.getConfigurationSettings().getConfigurationSetting("customcolor1", "0,0,0");
			String c2 = systemUserReg.getConfigurationSettings().getConfigurationSetting("customcolor2", "0,0,0");
			Vector customColor1 = supportFunctions.splitIntoTokens(c1,",");
			Vector customColor2 = supportFunctions.splitIntoTokens(c2,",");
			colorCodes[colorCodes.length-1] = new Color(Integer.parseInt((String)customColor1.elementAt(0)),
					Integer.parseInt((String)customColor1.elementAt(1)),
					Integer.parseInt((String)customColor1.elementAt(2)));
			colorCodes[colorCodes.length-2] = new Color(Integer.parseInt((String)customColor2.elementAt(0)),
					Integer.parseInt((String)customColor2.elementAt(1)),
					Integer.parseInt((String)customColor2.elementAt(2)));

			canvas = new buttonCanvas("Colors",2);
			Insets m = new Insets(0,0,0,0);
			for(int i=0;i<colorCodes.length;i++) {
				JCustomButton b = new JCustomButton("",colors[i],new colorIcon(colorCodes[i]));
				b.setMargin(m);
				canvas.buttonCanvasAdd(b);
			}
			canvas.buttonCanvasCreate();
		}
		public void dialogClose() {colorButtonCanvasHide();}
		public void dialogMoved() {colorButtonCanvasSave();} 
		public buttonCanvas colorButtonCanvas() {return canvas;}
		public void colorButtonCanvasShow() {
			canvas.buttonCanvasShow();
			canvas.buttonCanvasPanel().loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "cbc");
			canvas.buttonCanvasPanel().addMsgDialogListener(this);
		}
		public void colorButtonCanvasSave() {
			if (canvas.buttonCanvasPanel() != null) {
				canvas.buttonCanvasPanel().savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "cbc");
			}
		}
		public void colorButtonCanvasHide() {
			if (canvas.buttonCanvasPanel() != null) {
				canvas.buttonCanvasHide();
			}
		}
		protected void finalize() throws Throwable {
			colorButtonCanvasHide();
			super.finalize();
		}
	}
	
	public class diControlCanvas implements msg3DialogUtils {
		private buttonCanvas canvas;
		private Vector names = new Vector();
		private Vector icons = new Vector();
		
		public diControlCanvas() {
			createCustomIcons();
			canvas = new buttonCanvas("Controls",2);
			Insets m = new Insets(0,0,0,0);
			for(int i=0;i<names.size();i++) {
				String name = (String)names.elementAt(i);
				customIcon icon = (customIcon)icons.elementAt(i);
				JCustomButton b = new JCustomButton("",name,icon);
				b.setMargin(m);
				canvas.buttonCanvasAdd(b);
			}
			canvas.buttonCanvasCreate();
		}
		public void createCustomIcons() {
			customIcon icon1 = new customIcon();
			int[] x1 = {5,8,1,3,10,13,15,5};
			int[] y1 = {3,6,13,15,8,11,1,3};
			customIconData ciD = new customIconData(x1,y1,Color.black);
			icon1.addData(ciD);
			names.addElement("Select");
			icons.addElement(icon1);
			customIcon icon2 = new customIcon();
			int[] x2 = {1,12,15,5,1};
			int[] y2 = {12,1,4,15,12};
			ciD = new customIconData(x2,y2,Color.black);
			icon2.addData(ciD);
			names.addElement("Line");
			icons.addElement(icon2);
			customIcon icon3 = new customIcon();
			int[] x3 = {2,14,14,2,2};
			int[] y3 = {2,2,14,14,2};
			ciD = new customIconData(x3,y3,Color.black);
			icon3.addData(ciD);
			int[] x13 = {4,12,12,4,4};
			int[] y13 = {4,4,12,12,4};
			ciD = new customIconData(x13,y13,Color.white);
			icon3.addData(ciD);
			names.addElement("Rectangle");
			icons.addElement(icon3);
			customIcon icon4 = new customIcon();
			int[] x4 = {5,10,10,12,12,13,13,14,14,13,13,12,12,10,10,5,5,3,3,2,2,1,1,2,2,3,3,5};
			int[] y4 = {2,2,3,3,4,4,5,5,10,10,11,11,12,12,13,13,12,12,11,11,10,10,5,5,4,4,3,3};
			ciD = new customIconData(x4,y4,Color.black);
			icon4.addData(ciD);
			int[] x20 = {6,9,9,11,11,13,13,11,11,9,9,6,6,4,4,2,2,4,4,6};
			int[] y20 = {3,3,4,4,5,5,10,10,11,11,12,12,11,11,10,10,5,5,4,4,3};
			ciD = new customIconData(x20,y20,Color.white);
			icon4.addData(ciD);
			names.addElement("Elipse");
			icons.addElement(icon4);
			customIcon icon5 = new customIcon();
			int[] x5 = {2,14,14,2,2};
			int[] y5 = {2,2,14,14,2};
			ciD = new customIconData(x5,y5,Color.black);
			icon5.addData(ciD);
			int[] x10 = {4,7,7,4,4};
			int[] y10 = {3,3,6,6,3};
			ciD = new customIconData(x10,y10,Color.red);
			icon5.addData(ciD);
			int[] x11 = {10,13,13,10};
			int[] y11 = {4,7,7,4};
			ciD = new customIconData(x11,y11,Color.green);
			icon5.addData(ciD);
			int[] x12 = {7,12,12,7,5};
			int[] y12 = {9,9,11,11,9};
			ciD = new customIconData(x12,y12,Color.blue);
			icon5.addData(ciD);
			names.addElement("Image");
			icons.addElement(icon5);
			customIcon icon6 = new customIcon();
			int[] x6 = {1,15,15,10,10,6,6,1,1};
			int[] y6 = {2,2,5,5,14,14,5,5,2};
			ciD = new customIconData(x6,y6,Color.black);
			icon6.addData(ciD);
			names.addElement("Text");
			icons.addElement(icon6);
			customIcon icon7 = new customIcon();
			int[] x7 = {1,15,15,1};
			int[] y7 = {1,1,15,15};
			ciD = new customIconData(x7,y7,Color.black);
			icon7.addData(ciD);
			int[] x14 = {2,14,14,2};
			int[] y14 = {2,2,14,14};
			ciD = new customIconData(x14,y14,Color.white);
			icon7.addData(ciD);
			int[] x15 = {10,13,13,10};
			int[] y15 = {3,3,6,6};
			ciD = new customIconData(x15,y15,Color.black);
			icon7.addData(ciD);
			int[] x16 = {3,9,9,3};
			int[] y16 = {6,6,7,7};
			ciD = new customIconData(x16,y16,Color.black);
			icon7.addData(ciD);
			int[] x17 = {3,11,11,3};
			int[] y17 = {8,8,9,9};
			ciD = new customIconData(x17,y17,Color.black);
			int[] x18 = {3,9,9,3};
			int[] y18 = {10,10,11,11};
			ciD = new customIconData(x18,y18,Color.black);
			icon7.addData(ciD);
			int[] x19 = {3,8,8,3};
			int[] y19 = {12,12,13,13};
			ciD = new customIconData(x19,y19,Color.black);
			icon7.addData(ciD);
			icon7.addData(ciD);
			names.addElement("VirtualMsg");
			icons.addElement(icon7);
			customIcon icon8 = new customIcon();
			int[] x8 = {1,4,4,1,1};
			int[] y8 = {1,1,4,4,1};
			ciD = new customIconData(x8,y8,Color.black);
			icon8.addData(ciD);
			int[] x21 = {7,10,10,7,7};
			int[] y21 = {1,1,4,4,1};
			ciD = new customIconData(x21,y21,Color.black);
			icon8.addData(ciD);
			int[] x22 = {13,16,16,13,13};
			int[] y22 = {1,1,4,4,1};
			ciD = new customIconData(x22,y22,Color.black);
			icon8.addData(ciD);
			int[] x23 = {1,4,4,1,1};
			int[] y23 = {7,7,10,10,7};
			ciD = new customIconData(x23,y23,Color.black);
			icon8.addData(ciD);
			int[] x24 = {7,10,10,7,7};
			int[] y24 = {7,7,10,10,7};
			ciD = new customIconData(x24,y24,Color.black);
			icon8.addData(ciD);
			int[] x25 = {13,16,16,13,13};
			int[] y25 = {7,7,10,10,7};
			ciD = new customIconData(x25,y25,Color.black);
			icon8.addData(ciD);
			int[] x26 = {1,4,4,1,1};
			int[] y26 = {13,13,16,16,13};
			ciD = new customIconData(x26,y26,Color.black);
			icon8.addData(ciD);
			int[] x27 = {7,10,10,7,7};
			int[] y27 = {13,13,16,16,13};
			ciD = new customIconData(x27,y27,Color.black);
			icon8.addData(ciD);
			int[] x28 = {13,16,16,13,13};
			int[] y28 = {13,13,16,16,13};
			ciD = new customIconData(x28,y28,Color.black);
			icon8.addData(ciD);
			names.addElement("Grid");
			icons.addElement(icon8);
			customIcon icon9 = new customIcon();
			int[] x9 = {2,14,14,2,2};
			int[] y9 = {2,2,14,14,2};
			ciD = new customIconData(x9,y9,Color.black);
			icon9.addData(ciD);
			names.addElement("Fill");
			icons.addElement(icon9);

			customIcon icon10 = new customIcon();
			int[] x29 = {1,14,14,1,1};
			int[] y29 = {1,1,3,3,1};
			ciD = new customIconData(x29,y29,Color.black);
			icon10.addData(ciD);
			int[] x30 = {1,14,14,1,1};
			int[] y30 = {4,4,7,7,4};
			ciD = new customIconData(x30,y30,Color.black);
			icon10.addData(ciD);
			int[] x31 = {1,14,14,1,1};
			int[] y31 = {8,8,12,12,8};
			ciD = new customIconData(x31,y31,Color.black);
			icon10.addData(ciD);
			names.addElement("Width");
			icons.addElement(icon10);
		}
		public void dialogClose() {diControlCanvasHide();}
		public void dialogMoved() {diControlCanvasSave();} 
		public buttonCanvas diControlCanvas() {return canvas;}
		public void diControlCanvasShow() {
			canvas.buttonCanvasShow();
			canvas.buttonCanvasPanel().loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "dic");
			canvas.buttonCanvasPanel().addMsgDialogListener(this);
		}
		public void diControlCanvasSave() {
			if (canvas.buttonCanvasPanel() != null) {
				canvas.buttonCanvasPanel().savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "dic");
			}
		}
		public void diControlCanvasHide() {
			if (canvas.buttonCanvasPanel() != null) {
				canvas.buttonCanvasHide();
			}
		}
		protected void finalize() throws Throwable {
			diControlCanvasHide();
			super.finalize();
		}
	}

	public void setJavaLookAndFeel() {
		try {
			UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
		} catch (Exception e) {;}
	}
	public void setMotifLookAndFeel() {
		try {
			UIManager.setLookAndFeel("com.sun.java.swing.plaf.motif.MotifLookAndFeel");
		} catch (Exception e) {;}
	}
	
	public String	selFile;
	public enum fileDialogType {OPEN,SAVEAS};
	   public Vector fileIncludes(Vector files,String filePattern) {
		   Vector v = new Vector();

		   String filePatternRegExp = "";
		   for (int i=0;i<filePattern.length();i++) {
			   char ch = filePattern.charAt(i);
			   switch (ch) {
			   	case '.':
				   filePatternRegExp = filePatternRegExp + "\\.";
				   break;
			   	case '*':
				   filePatternRegExp = filePatternRegExp + ".*";
				   break;
			   	case '?':
				   filePatternRegExp = filePatternRegExp + ".";
				   break;
			   	default:
				   char data[] = {ch};
				   filePatternRegExp = filePatternRegExp + new String(data);
				   break;
			   }
		   }
		   filePatternRegExp = "^" + filePatternRegExp + "$";
//		   displayDialog("File pattern regfexp : "+ filePatternRegExp);
		   
		   v.addElement(new String("")); // ignore . directory
		   for (int i=1;i<files.size();i++) {
			   String tmp = (String)files.elementAt(i);
			   if (tmp.matches(filePatternRegExp)) {
				   v.addElement(new String("*"));
			   } else {
				   v.addElement(new String(""));
			   }
		   }
		   return v;
	   }
	public String[] getFileSet(String name) {
		Vector v = new Vector();
		xmlDataFile f = new xmlDataFile();
		f.openXMLDataFile(supportFunctions.getPathFilenameNoExt(name),"filesets",false);
		if (f != null) {
			org.w3c.dom.Document doc = f.getXMLDocument();
			NodeList n = executeXPathExpr(doc,"/filesets/fileset/file/");
			for (int i=0;i<n.getLength();i++) {
				org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(i);
				v.addElement(e.getAttribute("name"));
			}
		}
		f.closeXMLDataFile();
		String[] tmp = new String[v.size()];
		v.copyInto(tmp);
		return tmp;
	}
	public String[] getFileList(String startDirectory,String filePattern) {
		ehsFile xyz = new ehsFile(startDirectory,"");		
		if (startDirectory.length() == 0) {
			//startDirectory = xyz.getcwd();
			//startDirectory = startDirectory + "\\..\\..\\applications\\" + appDirectory;
			//startDirectory = removeDotDirectories(startDirectory);
			startDirectory = ""+dataRelativePath+"/" + appDirectory;
			xyz.setdirectory(startDirectory);
		} 
		xyz.listFiles();
		Vector files = xyz.getFiles();
		Vector filetypes = xyz.getFileTypes();
		Vector fileIncludes = fileIncludes(files,filePattern);
		Vector v =new Vector();
		for (int i=0;i<files.size();i++){
			String f=(String)files.elementAt(i);
			String ii=(String)fileIncludes.elementAt(i);
			String t=(String)filetypes.elementAt(i);
			if ( ii.length()!=0 || t.equals("dir")) {v.addElement(f);}
		}
		String[] tmp = new String[v.size()];
		v.copyInto(tmp);
		return tmp;
	}
	public class fileDialog extends JDialog implements ActionListener,ListSelectionListener {
		private JButton	butOK;
		private JButton butCancel;
		private JList	listFiles;
		private String 	startDirectory,filePattern;
		private Vector	files,filetypes;
		private fileDialogType type;
		private DefaultListModel listFilesM;
	   
		public String getFilename() {return selFile;}
		public String getDirectory() {return startDirectory;}
		public String getRelDirectory() {
			// note 10 is the length of webcommon + 1
			return startDirectory.substring(startDirectory.indexOf("webcommon")+10);
		}
		public fileDialog(Frame parent,String startDirectory,String filePattern,fileDialogType type) {
		   super(parent,"",true);

		   this.startDirectory = startDirectory;
		   this.filePattern = filePattern;
		   this.type = type;
		   
		   selFile = "";
		   String title = "";
		   listFilesM = new DefaultListModel();
		   listFiles = new JList(listFilesM);
		   butOK = new JButton("Ok");
		   butCancel = new JButton("Cancel");
		   butOK.setPreferredSize(new Dimension(10*charWidth,charHeight));
		   butCancel.setPreferredSize(new Dimension(10*charWidth,charHeight));

		   if (type == fileDialogType.OPEN) {title = "File Open";} else {title = "File Save As";}
		   setTitle(title);

		   JPanel p = new JPanel();
		   listFiles.addListSelectionListener(this);
		   
		   MouseListener mouseListener = new MouseAdapter() {
			   public void mouseClicked(MouseEvent e) {
				   if (e.getClickCount() == 2) {
					   int index = listFiles.locationToIndex(e.getPoint());
					   OKLogic();
				   }
			   }
		   };
		   listFiles.addMouseListener(mouseListener);
		   listFiles.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		   listFiles.setVisibleRowCount(5);
		   JScrollPane pane = new JScrollPane(listFiles);
		   pane.setAlignmentX(Component.LEFT_ALIGNMENT);
		   pane.setPreferredSize(new Dimension(25*charWidth,5*charHeight));
		   p.add(pane);
		   JPanel p1 = new JPanel();
		   p1.setLayout(new BoxLayout(p1,BoxLayout.Y_AXIS));
		   butOK.addActionListener(this);
		   butCancel.addActionListener(this);
		   p1.add(butOK);
		   p1.add(butCancel);
		   JPanel p2 = new JPanel();
		   p2.setLayout(new BoxLayout(p2,BoxLayout.X_AXIS));
		   p2.add(p);
		   p2.add(p1);
		   add(p2,"East");

		   fileListInit();
		   
		   addWindowListener(new WindowAdapter() {
   		     public void windowClosing(WindowEvent evt) {
			     selFile = "";
			     dispose();
		     }
		   });
		   pack();
		   setVisible(true);
	   }
	   	   
	   public String removeDotDirectories(String path) {
			Vector old = supportFunctions.splitIntoTokens(path,"\\");
			Vector v = new Vector();
			
			for (int i=0;i<old.size();i++) {
				String tmp = (String)old.elementAt(i);
				if (tmp.equals(".")) {continue;}
				if (tmp.equals("..")) {
					v.removeElementAt(v.size()-1);
				} else {
					v.addElement(tmp);
				}
			}
			String s = "";
			for (int i=0;i<v.size();i++) {
				if (i!=0) {s=s+"\\";}
				s = s + (String)v.elementAt(i);
			}			
				
			return s;
	   }
	   public void fileListInit() {
		ehsFile xyz = new ehsFile(startDirectory,"");
		if (startDirectory.length() == 0) {
			//startDirectory = xyz.getcwd();
			//startDirectory = startDirectory + "\\..\\..\\applications\\" + appDirectory;
			//startDirectory = removeDotDirectories(startDirectory);
			startDirectory = ""+dataRelativePath+"/" + appDirectory;
			xyz.setdirectory(startDirectory);
		} 
		xyz.listFiles();
		files = xyz.getFiles();
		filetypes = xyz.getFileTypes();
		Vector fileIncludes = fileIncludes(files,filePattern);
		listFilesM.removeAllElements();
		for (int i=1;i<files.size();i++) {
			String tmp = (String)fileIncludes.elementAt(i);
			String file = (String)files.elementAt(i);
			String filetype = (String)filetypes.elementAt(i);
			file=file.trim();
			filetype=filetype.trim();
			//TRACE("file:"+file+",type:"+filetype,4);
			if (tmp.length() != 0 || filetype.equals("dir")) {
				if (filetype.equals("dir")) {
					listFilesM.addElement("[" + file + "]");
				} else {
					listFilesM.addElement(file);
				}
			}
		}
		if (type == fileDialogType.OPEN) {
			butOK.setText("Open");
			butOK.setToolTipText("Open File");
		} else {
			listFilesM.addElement("New File");
			butOK.setText("Save");
			butOK.setToolTipText("Save File");
		}
		listFiles.setSelectedIndex(0);
	   }
	   
	   public void destroy() {
	   	dispose();
	   }
	   
	   public void OKLogic() {
		   selFile = (String)listFiles.getSelectedValue();
		   if (selFile.startsWith("[")) {
			   //startDirectory = startDirectory + "\\" + selFile.substring(1,selFile.length()-1);
			   //startDirectory = removeDotDirectories(startDirectory);
			   startDirectory = startDirectory + "/" + selFile.substring(1,selFile.length()-1);
			   fileListInit();
			   return;
		   }
		   if (selFile.equals("New File")) {
			   selFile = JOptionPane.showInputDialog(null,"Enter FileName","Save As",JOptionPane.QUESTION_MESSAGE);
		   }
		   dispose();
	   }
	   public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == butOK) {
			   OKLogic();
		   }
		   if (evt.getSource() == butCancel) {
			   selFile = "";
			   dispose();
		   }
	   }
		public void valueChanged(ListSelectionEvent evt) {
		   if (!evt.getValueIsAdjusting()) {
			   selFile = (String)listFiles.getSelectedValue();
		   }
		}
	}

	String fileCommonDialog(String startDirectory,String filePattern,fileDialogType type) {
		fileDialog fileDlg = new fileDialog(getTopLevelParent(this),startDirectory,filePattern,type);
		if (fileDlg.getFilename().length() == 0) {
			return null;
		}
		//return fileDlg.getRelDirectory() + "/" + fileDlg.supportFunctions.getFilename();
		return fileDlg.getDirectory() + "/" + fileDlg.getFilename();
	}
	String fileOpenDialog(String startDirectory,String filePattern) {
		FileDialog d = new FileDialog((Frame)null,"File Open",FileDialog.LOAD);
		d.setFile(filePattern);
		d.setDirectory(startDirectory);
		d.show();
		String filename = d.getFile();
		if (filename == null) {filename = "";return null;}
		//return d.getDirectory() + "\\" + d.getFile();
		return d.getDirectory() + d.getFile();
		
		//return fileCommonDialog(startDirectory,filePattern,fileDialogType.OPEN);
	}
	String fileSaveDialog(String startDirectory,String filePattern) {
		FileDialog d = new FileDialog((Frame)null,"File Save",FileDialog.SAVE);
		d.setFile(filePattern);
		d.setDirectory(startDirectory);
		d.show();
		String filename = d.getFile();
		if (filename == null) {filename = "";}
//		return d.getDirectory() + "\\" + d.getFile();
		return d.getDirectory() + d.getFile();
		
		//return fileCommonDialog(startDirectory,filePattern,fileDialogType.SAVEAS);
	}
	
	public fontDialog fontCommonDialog() {
		fontDialog dlg = new fontDialog(getTopLevelParent(this));
		if (dlg.isOK()) {
			return dlg;
		} 
		return (fontDialog)null;
	}
	public hdlSearchReplaceDialog searchreplaceCommonDialog() {
		hdlSearchReplaceDialog dlg = new hdlSearchReplaceDialog(getTopLevelParent(this));
		if (dlg.isOK()) {
			return dlg;
		} 
		return (hdlSearchReplaceDialog)null;
	}
	public class searchreplaceDialog extends JDialog implements ActionListener {
		private JButton	butFind,butReplace,butReplaceAll,butCancel;
		private JRadioButton forwardRB,backwardRB,allRB,selectedRB;
		private ButtonGroup directionBG,selectionBG;
		private boolean OKPressed = false;
		private JCheckBox caseSensitiveCB,regExpressionCB;
		private JTextField searchTF,replaceTF;
		
		public searchreplaceDialog(Frame parent) {
			super(parent,"Search and Replace",false);
			
			JPanel searchPanel = new JPanel();
			searchPanel.setLayout(new BoxLayout(searchPanel,BoxLayout.X_AXIS));
			searchPanel.add(new JLabel("Search Text:"));
			searchTF = new JTextField("",10);
			searchPanel.add(searchTF);
			
			JPanel replacePanel = new JPanel();
			replacePanel.setLayout(new BoxLayout(replacePanel,BoxLayout.X_AXIS));
			replacePanel.add(new JLabel("Replace Text:"));
			replaceTF = new JTextField("",10);
			replacePanel.add(replaceTF);
			
			JPanel controlPanel = new JPanel();
			controlPanel.setLayout(new BoxLayout(controlPanel,BoxLayout.X_AXIS));			
			forwardRB = new JRadioButton("Forward");
			forwardRB.setActionCommand("Forward");
			forwardRB.addActionListener(this);
			forwardRB.setSelected(true);
			backwardRB = new JRadioButton("Backward");
			backwardRB.setActionCommand("Backward");
			backwardRB.addActionListener(this);
			directionBG = new ButtonGroup();
			directionBG.add(forwardRB);
			directionBG.add(backwardRB);

			JPanel controlPanel1 = new JPanel();
			controlPanel1.setLayout(new BoxLayout(controlPanel1,BoxLayout.X_AXIS));			
			allRB = new JRadioButton("All");
			allRB.setActionCommand("All");
			allRB.addActionListener(this);
			allRB.setSelected(true);
			selectedRB = new JRadioButton("Selected");
			selectedRB.setActionCommand("Selected");
			selectedRB.addActionListener(this);
			selectionBG = new ButtonGroup();
			selectionBG.add(allRB);
			selectionBG.add(selectedRB);
			controlPanel1.add(forwardRB);
			controlPanel1.add(backwardRB);
			controlPanel1.add(allRB);
			controlPanel1.add(selectedRB);
			
			JPanel controlPanel2 = new JPanel();
			controlPanel2.setLayout(new BoxLayout(controlPanel2,BoxLayout.X_AXIS));			
			regExpressionCB = new JCheckBox("Regular Expression");
			controlPanel2.add(regExpressionCB);
			caseSensitiveCB = new JCheckBox("Case Sensitive");
			controlPanel2.add(caseSensitiveCB);

			JPanel buttonPanel = new JPanel();
			buttonPanel.setLayout(new BoxLayout(buttonPanel,BoxLayout.X_AXIS));
			butFind = new JButton("Find");
			butReplace = new JButton("Replace");
			butReplaceAll = new JButton("Replace All");
			butCancel = new JButton("Cancel");
			butFind.addActionListener(this);
			butReplace.addActionListener(this);
			butReplaceAll.addActionListener(this);
			butCancel.addActionListener(this);
			buttonPanel.add(butFind);
			buttonPanel.add(butReplace);
			buttonPanel.add(butReplaceAll);
			buttonPanel.add(butCancel);
			
			JPanel p = new JPanel();
			p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
			p.add(searchPanel);
			p.add(replacePanel);
			p.add(controlPanel);
			p.add(controlPanel1);
			p.add(controlPanel2);
			p.add(buttonPanel);

			setLayout(new BorderLayout());
			add(p,BorderLayout.CENTER);
			
			addWindowListener(new WindowAdapter() {
				public void windowClosing(WindowEvent evt) {
					OKPressed = false;
					dispose();
				}
			});
			
			pack();
			setVisible(true);
		}
		   public void destroy() {
		   		  dispose();
		   }
		   public void actionPerformed(ActionEvent evt) {
			   //evt.getActionCommand() 
			   if (evt.getSource() == butFind) {
				   SRFind(searchTF.getText());
			   }
			   if (evt.getSource() == butReplace) {
				   SRReplace(searchTF.getText(),replaceTF.getText());
			   }
			   if (evt.getSource() == butReplaceAll) {
				   SRReplaceAll(searchTF.getText(),replaceTF.getText());
			   }
			   if (evt.getSource() == butCancel) {
				   OKPressed = false;
				   dispose();
			   }
		   }
		   public void SRFind(String find) {;}
		   public void SRReplace(String find,String replace) {;}
		   public void SRReplaceAll(String find,String replace) {;}
		   public boolean isRegExpression() {return regExpressionCB.isSelected();}
		   public boolean isCaseSensitive() {return caseSensitiveCB.isSelected();}
		   public boolean isOK() {return OKPressed;}
		   public String getSearchText() {return searchTF.getText();}
		   public String getReplaceText() {return replaceTF.getText();}
		   public void setSearchString(String s) {searchTF.setText(s);}
		   public void setReplaceString(String s) {replaceTF.setText(s);}
		   public boolean isAll() {return allRB.isSelected();}
		   public boolean isSelected() {return selectedRB.isSelected();}
		   public boolean isForward() {return forwardRB.isSelected();}
		   public boolean isBackward() {return backwardRB.isSelected();}
	}
	
	public class fontDialog extends JDialog implements ActionListener,ItemListener {
		private JButton	butOK,butCancel;
		private JCheckBox boldCB,underlineCB,italicCB;
		private Choice fontList,sizeList;
		private boolean OKPressed = false;
		private Font font = null;
		private JLabel labExample;
		   
	   
		public fontDialog(Frame parent) {
		   super(parent,"Font Selection",true);

		   JPanel p = new JPanel();
		   p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
		
		   fontList = new Choice();
		   GraphicsEnvironment graphicsEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();
		   String[] fontNames = graphicsEnv.getAvailableFontFamilyNames();
		   for (int i=0;i<fontNames.length;i++) {
			   fontList.addItem(fontNames[i]);
		   }
		   fontList.select(0);
		   fontList.addItemListener(this);
		   int[] fontSizes = {10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,46,52,58,64,72};
		   sizeList = new Choice();
		   for (int i=0;i<fontSizes.length;i++) {
			   sizeList.addItem(String.valueOf(fontSizes[i]));
		   }
		   sizeList.select(0);
		   sizeList.addItemListener(this);
		   boldCB = new JCheckBox("Bold");
		   boldCB.addItemListener(this);
		   underlineCB = new JCheckBox("Underline");
		   underlineCB.addItemListener(this);
		   italicCB = new JCheckBox("Italic");
		   italicCB.addItemListener(this);
		   
		   butOK = new JButton("OK");
		   butCancel = new JButton("Cancel");
		   butOK.addActionListener(this);
		   butCancel.addActionListener(this);
		   p.add(fontList);
		   p.add(sizeList);
		   p.add(boldCB);
		   p.add(underlineCB);
		   p.add(italicCB);
		   p.add(butOK);
		   p.add(butCancel);

		   setLayout(new BorderLayout());
		   add(p,BorderLayout.CENTER);
		   
		   labExample = new JLabel("ABCDEFG abcdefg");
		   labExample.setHorizontalAlignment(JLabel.CENTER);
		   labExample.setPreferredSize(new Dimension(10*charWidth,8*charHeight));
		   add(labExample,BorderLayout.SOUTH);
		   
		   calcFont();
		   
		   addWindowListener(new WindowAdapter() {
   		     public void windowClosing(WindowEvent evt) {
			   font = null;
			   OKPressed = false;
			   dispose();
		     }
		   });
		   pack();
		   setVisible(true);
	   }
	   
	   public void destroy() {
	   		  dispose();
	   }
	   
	   public int getFontSize() {return Integer.parseInt(sizeList.getSelectedItem());}
	   public String getFontName() {return fontList.getSelectedItem();}
	   public boolean isBold() {return boldCB.isSelected();}
	   public boolean isUnderline() {return underlineCB.isSelected();}
	   public boolean isItalic() {return italicCB.isSelected();}
	   public boolean isOK() {return OKPressed;}
	   public Font getFont() {return font;}	   

	   public void setFontSizeList(int[] sizes) {
		   sizeList.removeAll();
		   for (int i=0;i<sizes.length;i++) {
			   sizeList.addItem(String.valueOf(sizes[i]));
		   }
		   sizeList.select(0);
		   calcFont();
	   }
	   public void calcFont() {
		   TRACE("fontDialog:name:"+getFontName(),4);
		   int fontStyle = Font.PLAIN;
		   if (isBold()) {fontStyle = fontStyle | Font.BOLD;}
		   if (isItalic()) {fontStyle = fontStyle | Font.ITALIC;}
		   font = new Font(getFontName(),fontStyle,getFontSize());
		   if (isUnderline()) {
				font = getUnderlinedFont(font);
		   }
		   
		   labExample.setFont(font);
		   //labExample.getParent().invalidate();
		   //labExample.getParent().validate();
	   }
	   public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == butOK) {
				calcFont();
				OKPressed = true;
				dispose();
		   }
		   if (evt.getSource() == butCancel) {
			   font = null;
			   OKPressed = false;
			   dispose();
		   }
	   }
	   public void itemStateChanged(ItemEvent evt) {
			calcFont();
	   }
	}
	   
	
	public void displaySplashScreen(String title,String image,String extraText,int timeToDisplay) {
		splashScreenDialog d = new splashScreenDialog(getTopLevelParent(this),title,image,extraText,timeToDisplay);
	}
	public class splashScreenDialog extends JDialog implements pictureUtils {
	    private	Timer 			tick;
		private	int				timeoutSecs,currentSecs;
		private	pictureCanvas 	splashCanvas;
		public String 			title;
		public String 			extraText;
		
		public void pictureStart() {}
		public void pictureFinish() {}
		public void picturePaint(Graphics g){
			Graphics2D g2d = (Graphics2D)g;
			Font orgFont = g2d.getFont();
			float size = g2d.getFont().getSize();
			Font newFont = g2d.getFont().deriveFont(Font.BOLD,size + 20);
			FontMetrics fm = getFontMetrics(newFont);
			int width = fm.stringWidth(title);
			int height = fm.getHeight();
			int ascent = fm.getAscent();
			int x = (splashCanvas.width() - width) / 2;
			Font newFont1 = g2d.getFont().deriveFont(Font.BOLD,size + 10);
			FontMetrics fm1 = getFontMetrics(newFont1);
			int width1 = fm1.stringWidth(extraText);
			int height1 = fm1.getHeight();
			int ascent1 = fm1.getAscent();
			int x1 = (splashCanvas.width() - width1) / 2;
			int yGap = (splashCanvas.height() - (height + height1)) / 3;
			int y = yGap + height;
			int y1 = yGap + height + 10 + height1;
			
			Font newFont2 = g2d.getFont().deriveFont(Font.BOLD,size);
			FontMetrics fm2 = getFontMetrics(newFont2);
			int height2 = fm2.getHeight();
			int ascent2 = fm2.getAscent();
			String s2 = "Unregistered";
			if (systemUserReg.getUserRegistered()) {s2 = "Registered To: " + systemUserReg.getUserName();}
			int y2 = splashCanvas.height() - (2 * height2);
			String s3 = "Serial Number: ";
			if (systemUserReg.getUserRegistered()) {s3 = s3 + systemUserReg.getSerialNumber();}
			int y3 = splashCanvas.height() - height2;
			
			int botWidth = fm2.stringWidth(s2);
			if (botWidth < fm2.stringWidth(s3)) {botWidth = fm.stringWidth(s3);}
			int topWidth = fm.stringWidth(title);
			if (topWidth < fm1.stringWidth(extraText)) {topWidth = fm1.stringWidth(extraText);}
	
			g2d.setColor(Color.white);
			g2d.fill3DRect(x - 5,y - height,topWidth + 5 + 5,height + 10 + height1 + 5,true);
			g2d.setColor(Color.black);
			g2d.setFont(newFont);
			g2d.drawString(title,x,y);
			g2d.setFont(newFont1);
			g2d.drawString(extraText,x1,y1);
			
			g2d.setColor(Color.white);
			g2d.fill3DRect(5,y2 - height2 - 5,botWidth + 5,(2 * height2) + 5 + 5,true);
			g2d.setColor(Color.black);
			g2d.setFont(newFont2);
			g2d.drawString(s2,10,y2);
			g2d.drawString(s3,10,y3);
			
			g2d.setFont(orgFont);
		}
		public splashScreenDialog(Frame parent,String title,String image,String extraText,int timeToDisplay) {
			super(parent,title,true);

			this.title = title;
			this.extraText = extraText;
			
			timeoutSecs = 5;
			currentSecs = 0;
	
			splashCanvas = new pictureCanvas(image);			
			splashCanvas.addPictureListener(this);
			
			setTimeoutTick(timeToDisplay);
			Panel splashPanel = new Panel(new FlowLayout(FlowLayout.LEFT));
			splashPanel.add(splashCanvas);
			setLayout(new BorderLayout());
			add(splashPanel,"North");
			Toolkit tk = Toolkit.getDefaultToolkit();
			Dimension d = tk.getScreenSize();
			setLocation((d.width - splashCanvas.width()) / 2,(d.height - splashCanvas.height())/2);
			
			addWindowListener(new WindowAdapter() {
				public void windowClosing(WindowEvent evt) {
				tick.stop();
				dispose();
				}
			});
			
		   ActionListener task = new ActionListener() {
  				 public void actionPerformed(ActionEvent evt) {
						timedDialogTick(currentSecs++);
						if (currentSecs > timeoutSecs) {
							timedDialogTmeout();
							destroy();
						}
					 }
			};
		    tick = new Timer(1000,task);
		    tick.start();

		    pack();
		    setVisible(true);
		}	
		public void setTimeoutTick(int i) {timeoutSecs = i;}
		public int getTimeoutTick() {return timeoutSecs;}
		public int getCurrentTick() {return currentSecs;}
		public void timedDialogTmeout() {}
		public void timedDialogTick(int tick) {}
		public void destroy() {
			tick.stop();
			dispose();
	   }
	}
	
	Font getRotatedFont(Font f,int degrees) {
		AffineTransform rotation = AffineTransform.getRotateInstance(Math.toRadians(degrees));
		return f.deriveFont(rotation);
	}
	public class textBlock {
		private	AttributedString	text;
		private int					startIndex;
		private int					characterWidth;

		textBlock() {startIndex=0;text = new AttributedString("");characterWidth=charWidth;}
		textBlock(String s) {startIndex=0;text = new AttributedString(s);}
		textBlock(String s,int i) {startIndex=i;text = new AttributedString(s);}
		void setScalingFactor(float factor) {
			float f = (float)charWidth * factor;
			characterWidth = (int)f;
		}
		void setStartIndex(int i) {startIndex = i;}
		int getStartIndex() {return startIndex;}
		void setText(String s) {text = new AttributedString(s);}
		AttributedString getText() {return text;}
		void drawText(Graphics2D g2d,int x,int y) {
			AttributedCharacterIterator iter = text.getIterator();
			//LineMetrics metrics =
			g2d.drawString(iter,x,y);
		}
		void drawJustifiedText(Graphics2D g2d,int x,int y,int w) {
			int MARGIN = 3;
			AttributedCharacterIterator iter = text.getIterator();
			FontRenderContext frc = new FontRenderContext(null,true,true);
			LineBreakMeasurer measurer = new LineBreakMeasurer(iter,frc);
			float wrappingWidth = w - 2*MARGIN;
			float curY = MARGIN;
			Vector vLayouts = new Vector();
			Vector vPenPositions = new Vector();
			TextLayout layout = null;
			Point2D.Float penPosition = null;
			while (measurer.getPosition() < iter.getEndIndex()) {
				layout = measurer.nextLayout(wrappingWidth);
				curY += (layout.getAscent());
				if (vLayouts.size() > 0) {
					TextLayout previousLine = (TextLayout)vLayouts.elementAt(vLayouts.size() - 1);
					previousLine = previousLine.getJustifiedLayout(wrappingWidth * 2);
					vLayouts.setElementAt(previousLine,vLayouts.size() - 1);
				}
				penPosition = new Point2D.Float(MARGIN,curY);
				vPenPositions.addElement(penPosition);
				vLayouts.addElement(layout);
				curY += layout.getDescent() + layout.getLeading();
			}
			
			for (int i=0;i<vLayouts.size();i++) {
				TextLayout t = (TextLayout)vLayouts.elementAt(i);
				Point2D.Float p = (Point2D.Float)vPenPositions.elementAt(i);
				t.draw(g2d,p.x,p.y);
			}
		}
		public String[] splitIntoLines(String textOrg,FontMetrics fm,int width) {
			String text = textOrg;
			Vector v = new Vector();
			int charsPerLine = width / fm.charWidth('O');
			if (text.length() < charsPerLine) {
				v.addElement(text);
			} else {
				while (text.length() > charsPerLine) {
					int index = text.lastIndexOf(' ',charsPerLine);
					if (index == -1) {index = charsPerLine;}
					v.addElement(text.substring(0,index));
					text = text.substring(index);
				}
				if (text.length() != 0) {v.addElement(text);}
			}
		
			String[] tmp = new String[v.size()];
			v.copyInto(tmp);
			return tmp;
		}
		public int getMaxStringWidthInPixels(String string) {
			return getGraphics().getFontMetrics().stringWidth(string);
		}
		public int getMaxStringWidthInPixels(String[] strings) {
			int maxWidth = 0;
			for (int i=0;i<strings.length;i++) {
				int width = getMaxStringWidthInPixels(strings[i]);
				if (width > maxWidth) {maxWidth = width;}
			}
			return maxWidth;
		}
		public int getMaxStringWidthInPixels(Vector strings) {
			int maxWidth = 0;
			for (int i=0;i<strings.size();i++) {
				String s = (String)strings.elementAt(i);
				int width = getMaxStringWidthInPixels(s);
				if (width > maxWidth) {maxWidth = width;}
			}
			return maxWidth;
		}
		public void boxCenterText(Graphics2D g2d,Color back,String s1,String s2,int x,int y,int w,int h) {
			Font orgFont = g2d.getFont();
			int height,ascent;
			int width1=0,width2=0,x0=0,x1=0,y0=0,y1=0;
			float size = g2d.getFont().getSize();
			size = size + 1;
			do { // reduce the font size until the text fits in the bounding box
				Font newFont = g2d.getFont().deriveFont(size - 1);
				g2d.setFont(newFont);
				FontMetrics fm1 = getFontMetrics(newFont);
				width1 = fm1.stringWidth(s1);
				if (s2.length() != 0) width2 = fm1.stringWidth(s2);
				height = fm1.getHeight();
				ascent = fm1.getAscent();
				size = size - 1;
			}
			while(((width1 > w) || (width2  > w)) && size > 0);
			x0 = x + (w - width1) / 2;
			x1 = x + (w - width2) / 2;
			if (s2.length() == 0) {
				y0 = y + (h - height) / 2 + ascent;
			} else {
				y0 = y + (h - (int)(height * 2.2)) / 2 + ascent;
				y1 = y0 + (int)(height * 1.2);
			}
			g2d.setColor(back);
			g2d.fillRoundRect(x,y,w,h,20,20);
			g2d.setColor(Color.black);
			g2d.drawRoundRect(x,y,w,h,20,20);
			g2d.drawString(s1,x0,y0);
			if (s2.length() != 0) {
				g2d.drawString(s2,x1,y1);
			}
			g2d.setFont(orgFont);
		}
	}

	public class ParserGetter extends HTMLEditorKit {
		// purely to make this method public 
		public HTMLEditorKit.Parser getParser() {
			return super.getParser();
		}
	}
	public void testSyntaxEditorPane() {
		syntaxEditorPaneDialog d = new syntaxEditorPaneDialog(getTopLevelParent(this));
		displayDialog(d.HDLTA.getRawText());
	}
	
	// Our own version of an Iterator that allows us to look at non-leaf tags as well.
	public static class TagIterator {
		private HTML.Tag tag;
		private ElementIterator pos;
		TagIterator(HTML.Tag t, javax.swing.text.Document doc) {
			tag = t;
			pos = new ElementIterator(doc);
			next();
		}
		public AttributeSet getAttributes() {
			javax.swing.text.Element elem = pos.current();
			if (elem != null) {
				AttributeSet a =
					(AttributeSet)elem.getAttributes().getAttribute(tag);
					if (a == null) {
						return elem.getAttributes();
					}
				return a;
			}
			return null;
		}
		public void next() {
			for (pos.next(); isValid(); pos.next()) {
				javax.swing.text.Element elem = pos.current();
				if (elem.getName().equals(tag.toString())) {
					break;
				}
				AttributeSet a = pos.current().getAttributes();
				if (a.isDefined(tag)) {
					// we found the next one
					break;
				}
			}
		}
		public HTML.Tag getTag() { return tag; }
		public boolean isValid() {
			return (pos.current() != null);
		}
	}
	
	public class syntaxEditorPaneFormat {
		private	String formatName;
		private	String formatRegEx;
		private	String formatStartHTML;
		private	String formatEndHTML;
		private boolean formatEnabled;
		
		public syntaxEditorPaneFormat(String name,String regex,String start,String end) {
			formatName = name;
			formatRegEx = regex;
			formatStartHTML = start.toLowerCase();
			formatEndHTML = end.toLowerCase();
			formatEnabled = true;
		}
		public void saveAsXML(org.w3c.dom.Document doc,org.w3c.dom.Element root) {
			org.w3c.dom.Element setting = doc.createElement("syntaxeditorpaneformat");
			setting.setAttribute("name",formatName);
			setting.setAttribute("regex",formatRegEx);
			setting.setAttribute("starthtml",formatStartHTML);
			setting.setAttribute("endhtml",formatEndHTML);
			root.appendChild(setting);
		}
		public void setEnabled(boolean bEnable) {formatEnabled = bEnable;}
		public boolean getEnabled() {return formatEnabled;}
		public String getFormatName() {return formatName;}
		public String getFormatRegEx() {return formatRegEx;}
		public String getFormatStartHTML() {return formatStartHTML;}
		public String getFormatEndHTML() {return formatEndHTML;}
		public void setFormatName(String s) {formatName = s;}
		public void setFormatRegEx(String s) {formatRegEx = s;}
		public void setFormatStartHTML(String s) {formatStartHTML = s;}
		public void setFormatEndHTML(String s) {formatEndHTML = s;}
	}
	public class syntaxPaneEditorKit extends HTMLEditorKit {
		public void install(JEditorPane paneEditor) {
			super.install(paneEditor);
		}
		public ViewFactory getViewFactory() {
			return new syntaxPaneViewFactory();
		}
		public class syntaxPaneViewFactory extends HTMLEditorKit.HTMLFactory {
			public View create(javax.swing.text.Element elem) {
				return super.create(elem);
			}
		}
	}
	// An example "no view" View class to hide any content found inside
	// Element elem. Basically, we return a 0x0 bounding box
	// and do nothing in the paint() method.
	public static class NoView extends View {
		public NoView(javax.swing.text.Element elem) {
			super(elem);
			setSize(0.0f, 0.0f);
		}
		public int viewToModel(float fx, float fy, Shape a,Position.Bias[] bias) {
			return 0;
		}
		public Shape modelToView(int pos, Shape a, Position.Bias b)
			throws BadLocationException {
				return new Rectangle(0, 0);
			}
		public float getPreferredSpan(int axis) {
			return 0.0f;
		}
		public void paint(Graphics g, Shape allocation) {
		}
	}
	public class floatingWindow implements KeyListener {
		private	JTextArea 	tf = null;
		private	msg3Dialog 	d = null;
		private	boolean 	bEscapeFlag = true;
		
		public void keyTyped(KeyEvent evt) {}	
		public void keyReleased(KeyEvent evt) {}	
		public void keyPressed(KeyEvent evt) {
			int keyCode = evt.getKeyCode();
			if (keyCode == KeyEvent.VK_ESCAPE && bEscapeFlag) {destory();}
		}
		public void setEscapeFlag(boolean b) {bEscapeFlag = b;}
		public floatingWindow(JPanel p,String title) {
			d = displayPanelDialog(p,title);
		}
		public floatingWindow(String text,String title,int cols,int rows) {
			JPanel p = new JPanel();
			tf = new JTextArea(text,cols,rows);
			tf.setBackground(lightyellow);
			tf.addKeyListener(this);
			tf.setWrapStyleWord(true);
			tf.setEditable(false);
			p.add(tf);
			d = displayPanelDialog(p,title);
		}
		public boolean isValid() {
			if (d == null) {return false;} else {return true;}
		}
		public void setLocation(int x,int y) {
			if (d != null) {d.setLocation(x,y);}
		}
		public void destory() {
			if (d != null) {
				d.destory();
				d.dispose();
				d = null;
			}
		}
		protected void finalize() throws Throwable {
			destory();
			super.finalize();
		}		
	}
	
	public class SEPComponent {
		private SEPScrollPane 		sp = null;
		private syntaxEditorPane 	jep = null;
		
		public SEPComponent(syntaxEditorPane jep,int cols,int rows) {
			this.jep = jep;
			sp = new SEPScrollPane(jep);
			sp.setPreferredSize(new Dimension(cols*charWidth,rows*charHeight));
			jep.setScrollPane(sp);
		}
		public SEPScrollPane getScrollPane() {return sp;}
		public syntaxEditorPane getEditorPane() {return jep;}
	}
	public class JScrollPaneRulerHeader extends JComponent {
	    public int INCH = Toolkit.getDefaultToolkit().getScreenResolution();
	    public static final int HORIZONTAL = 0;
	    public static final int VERTICAL = 1;
	    public static final int SIZE = 35;
	 
	    public int orientation;
	    public boolean isMetric;
	    private int increment;
	    private int units;
	 
	    public JScrollPaneRulerHeader(int o, boolean m) {
	        orientation = o;
	        isMetric = m;
	        setIncrementAndUnits();
	    }
	 
	    public void setIsMetric(boolean isMetric) {
	        this.isMetric = isMetric;
	        setIncrementAndUnits();
	        repaint();
	    }
	 
	    private void setIncrementAndUnits() {
	        if (isMetric) {
	            units = (int)((double)INCH / (double)2.54); // dots per centimeter
	            increment = units;
	        } else {
	            units = INCH;
	            increment = units / 2;
	        }
	    }
	 
	    public boolean isMetric() {
	        return this.isMetric;
	    }
	 
	    public int getIncrement() {
	        return increment;
	    }
	 
	    public void setPreferredHeight(int ph) {
	        setPreferredSize(new Dimension(SIZE, ph));
	    }
	 
	    public void setPreferredWidth(int pw) {
	        setPreferredSize(new Dimension(pw, SIZE));
	    }
	 
	    protected void paintComponent(Graphics g) {
	        Rectangle drawHere = g.getClipBounds();
	 
	        // Fill clipping area with dirty brown/orange.
	        g.setColor(new Color(230, 163, 4));
	        g.fillRect(drawHere.x, drawHere.y, drawHere.width, drawHere.height);
	 
	        // Do the ruler labels in a small font that's black.
	        g.setFont(new Font("SansSerif", Font.PLAIN, 10));
	        g.setColor(Color.black);
	 
	        // Some vars we need.
	        int end = 0;
	        int start = 0;
	        int tickLength = 0;
	        String text = null;
	 
	        // Use clipping bounds to calculate first and last tick locations.
	        if (orientation == HORIZONTAL) {
	            start = (drawHere.x / increment) * increment;
	            end = (((drawHere.x + drawHere.width) / increment) + 1)
	                  * increment;
	        } else {
	            start = (drawHere.y / increment) * increment;
	            end = (((drawHere.y + drawHere.height) / increment) + 1)
	                  * increment;
	        }
	 
	        // Make a special case of 0 to display the number
	        // within the rule and draw a units label.
	        if (start == 0) {
	            text = Integer.toString(0) + (isMetric ? " cm" : " in");
	            tickLength = 10;
	            if (orientation == HORIZONTAL) {
	                g.drawLine(0, SIZE-1, 0, SIZE-tickLength-1);
	                g.drawString(text, 2, 21);
	            } else {
	                g.drawLine(SIZE-1, 0, SIZE-tickLength-1, 0);
	                g.drawString(text, 9, 10);
	            }
	            text = null;
	            start = increment;
	        }
	 
	        // ticks and labels
	        for (int i = start; i < end; i += increment) {
	            if (i % units == 0)  {
	                tickLength = 10;
	                text = Integer.toString(i/units);
	            } else {
	                tickLength = 7;
	                text = null;
	            }
	 
	            if (tickLength != 0) {
	                if (orientation == HORIZONTAL) {
	                    g.drawLine(i, SIZE-1, i, SIZE-tickLength-1);
	                    if (text != null)
	                        g.drawString(text, i-3, 21);
	                } else {
	                    g.drawLine(SIZE-1, i, SIZE-tickLength-1, i);
	                    if (text != null)
	                        g.drawString(text, 9, i+3);
	                }
	            }
	        }
	    }
	}
	interface lineNumberListener {
		public void mouseClicked(int x,int y,boolean bDoubleClicked,int lineNumber);
	}
	public class JScrollPaneLineNumberHeader extends JComponent implements MouseListener {
		private Vector				markerTypes = new Vector();
		private Hashtable			markers = null;
		private	int					maxLineNumber = 0;
		private int					xMargin = 5;
		private	int					charHeightAdjust = 3;
		private	lineNumberListener	target = null;
		private	Rectangle 			drawHere;

		public JScrollPaneLineNumberHeader() {
			markers = new Hashtable();	
			addMouseListener(this);
	    }
		public void addLineNumberListener(lineNumberListener l) {
			target = l;
		}
		public void removeLineNumberListener() {
			target = null;
		}
		public void mouseEntered(MouseEvent evt) {}
		public void mouseExited(MouseEvent evt) {}
		public void mouseClicked(MouseEvent evt) {
				int line = ((evt.getY()-drawHere.y) / (charHeight+charHeightAdjust)) + 1;
				if (line > maxLineNumber) {line = 0;}
				//displayDialog("Line Number:"+String.valueOf(line));
				if (evt.getClickCount() == 2) {
					TRACE("JScrollPaneLineNumberHeader:Double Click:Line "+String.valueOf(line),4);
					if (target != null) {target.mouseClicked(evt.getX(),evt.getY(),true,line);}
				} else {
					TRACE("JScrollPaneLineNumberHeader:Single Click:Line "+String.valueOf(line),4);
					if (target != null) {target.mouseClicked(evt.getX(),evt.getY(),false,line);}					
				}
		}
		public void mousePressed(MouseEvent evt) {}
		public void mouseReleased(MouseEvent evt) {}
	    public void update() {
	    	repaint();
	    }
		protected void paintComponent(Graphics g) {
			Graphics2D g2d = (Graphics2D)g;
			//Rectangle drawHere = g.getClipBounds(); // draw only visible part of header
			drawHere = new Rectangle(0,0,getWidth(),getHeight()); // draw all of header
	        g.setColor(Color.LIGHT_GRAY);
	        g.fillRect(drawHere.x, drawHere.y, drawHere.width, drawHere.height);
	        g.setColor(Color.BLACK);
	        for (int i=1;i<maxLineNumber+1;i++) {
	        	g.drawString(String.valueOf(i), drawHere.x+xMargin, drawHere.y+(i*(charHeight+charHeightAdjust)));
	        	for (int ii=0;ii<markerTypes.size();ii++) {
	        		ImageIcon icon = getMarkerAtLine((String)markerTypes.elementAt(ii),i-1);
	        		if (icon != null) {
	        			icon.paintIcon(null,g2d,
	        					drawHere.x + drawHere.width - icon.getIconWidth(),
	        					(drawHere.y+(i*(charHeight+charHeightAdjust)))
	        						- icon.getIconHeight());
	        		}
	        	}
	        }
	    }
		public void updateMaxLineNumber(int max) {
			maxLineNumber = max;
			TRACE("JScrollPaneLineNumberHeader:updateMaxLineNumber:"+String.valueOf(max),4);
			
			update();
		}
		public void setMarkerAtLine(ImageIcon i,String type,int lineNumber) {
			if (!markerTypes.contains(type)) {markerTypes.addElement(type);}
			String key = type + String.valueOf(lineNumber);
			Object o = markers.get(key);
			if (o != null) {markers.remove(key);}
			markers.put(key, i);
			
			update();
		}
		public ImageIcon getMarkerAtLine(String type,int lineNumber) {
			String key = type + String.valueOf(lineNumber);
			Object o = markers.get(key);
			if (o != null) {return (ImageIcon)o;}
			
			return null;
		}
		public void removeMarkerAtLine(String type,int lineNumber) {
			String key = type + String.valueOf(lineNumber);
			markers.remove(key);
			
			update();
		}
		public void removeAllMarkers(String type) {
			for (Enumeration e=markers.keys(); e.hasMoreElements();) {
				String nextKey = (String) e.nextElement();
				if (nextKey.startsWith(type)) {markers.remove(nextKey);}
			}
			
			update();
		}
		public void removeAllMarkers() {
			TRACE("JScrollPaneLineNumberHeader:removeAllMarkers",4);
			markers.clear();
			markerTypes.removeAllElements();
			
			update();
		}
	}
	public class JScrollPaneSolidColorCorner extends JComponent {
		private	Color	c = null;
		
		public JScrollPaneSolidColorCorner(Color c) {
			this.c = c;
		}
	    protected void paintComponent(Graphics g) {
	        g.setColor(c);
	        g.fillRect(0, 0, getWidth(), getHeight());
	    }
	}
	/*
	 *  Implements a simple highlight painter that renders a rectangle around the
	 *  area to be highlighted.
	 *
	 */
	public class SquigglePainter extends DefaultHighlighter.DefaultHighlightPainter
	{
		public SquigglePainter(Color color)
		{
			super( color );
		}

		/**
		 * Paints a portion of a highlight.
		 *
		 * @param  g the graphics context
		 * @param  offs0 the starting model offset >= 0
		 * @param  offs1 the ending model offset >= offs1
		 * @param  bounds the bounding box of the view, which is not
		 *	       necessarily the region to paint.
		 * @param  c the editor
		 * @param  view View painting for
		 * @return region drawing occured in
		 */
		public Shape paintLayer(Graphics g, int offs0, int offs1, Shape bounds, JTextComponent c, View view)
		{
			Rectangle r = getDrawingArea(offs0, offs1, bounds, view);

			if (r == null) return null;

			//  Do your custom painting

			Color color = getColor();
			g.setColor(color == null ? c.getSelectionColor() : color);

			//  Draw the squiggles

			int squiggle = 2;
			int twoSquiggles = squiggle * 2;
			int y = r.y + r.height - squiggle;

	        for (int x = r.x; x <= r.x + r.width - twoSquiggles; x += twoSquiggles)
	        {
	            g.drawArc(x, y, squiggle, squiggle, 0, 180);
	            g.drawArc(x + squiggle, y, squiggle, squiggle, 180, 181);
	        }

			// Return the drawing area

			return r;
		}


		private Rectangle getDrawingArea(int offs0, int offs1, Shape bounds, View view)
		{
			// Contained in view, can just use bounds.

			if (offs0 == view.getStartOffset() && offs1 == view.getEndOffset())
			{
				Rectangle alloc;

				if (bounds instanceof Rectangle)
				{
					alloc = (Rectangle)bounds;
				}
				else
				{
					alloc = bounds.getBounds();
				}

				return alloc;
			}
			else
			{
				// Should only render part of View.
				try
				{
					// --- determine locations ---
					Shape shape = view.modelToView(offs0, Position.Bias.Forward, offs1,Position.Bias.Backward, bounds);
					Rectangle r = (shape instanceof Rectangle) ? (Rectangle)shape : shape.getBounds();

					return r;
				}
				catch (BadLocationException e)
				{
					// can't render
				}
			}

			// Can't render

			return null;
		}
	}
	/*
	 *  Implements a simple highlight painter that renders a rectangle around the
	 *  area to be highlighted.
	 *
	 */
	public class RectanglePainter extends DefaultHighlighter.DefaultHighlightPainter
	{
		public RectanglePainter(Color color)
		{
			super( color );
		}

		/**
		 * Paints a portion of a highlight.
		 *
		 * @param  g the graphics context
		 * @param  offs0 the starting model offset >= 0
		 * @param  offs1 the ending model offset >= offs1
		 * @param  bounds the bounding box of the view, which is not
		 *	       necessarily the region to paint.
		 * @param  c the editor
		 * @param  view View painting for
		 * @return region drawing occured in
		 */
		public Shape paintLayer(Graphics g, int offs0, int offs1, Shape bounds, JTextComponent c, View view)
		{
			Rectangle r = getDrawingArea(offs0, offs1, bounds, view);

			if (r == null) return null;

			//  Do your custom painting

			Color color = getColor();
			g.setColor(color == null ? c.getSelectionColor() : color);

			//  Code is the same as the default highlighter except we use drawRect(...)

//			g.fillRect(r.x, r.y, r.width, r.height);
			g.drawRect(r.x, r.y, r.width - 1, r.height - 1);

			// Return the drawing area

			return r;
		}


		private Rectangle getDrawingArea(int offs0, int offs1, Shape bounds, View view)
		{
			// Contained in view, can just use bounds.

			if (offs0 == view.getStartOffset() && offs1 == view.getEndOffset())
			{
				Rectangle alloc;

				if (bounds instanceof Rectangle)
				{
					alloc = (Rectangle)bounds;
				}
				else
				{
					alloc = bounds.getBounds();
				}

				return alloc;
			}
			else
			{
				// Should only render part of View.
				try
				{
					// --- determine locations ---
					Shape shape = view.modelToView(offs0, Position.Bias.Forward, offs1,Position.Bias.Backward, bounds);
					Rectangle r = (shape instanceof Rectangle) ? (Rectangle)shape : shape.getBounds();

					return r;
				}
				catch (BadLocationException e)
				{
					// can't render
				}
			}

			// Can't render

			return null;
		}
	}
	public class SEPScrollPane extends JScrollPane implements AdjustmentListener {
		public SEPScrollPane(JEditorPane jep) {
			super(jep);
			getVerticalScrollBar().addAdjustmentListener(this);
		}
		public void adjustmentValueChanged(AdjustmentEvent e) {
			int value = e.getValue();
		}
	}
	public class suggestionPanel extends JPanel implements ItemListener {
		private syntaxEditorPane sep = null;
		
		public suggestionPanel(syntaxEditorPane sep) {
			this.sep = sep;
		}
		public syntaxEditorPane getSyntaxEditorPane() {return sep;}
		public void itemStateChanged(ItemEvent evt) {
			if (evt.getStateChange() == evt.SELECTED) {
				List source = (List)evt.getSource();
				String item = source.getSelectedItem();
				itemSelected(item);
			}
		}
		public void itemSelected(String item) {
			TRACE("suggestionPanel:Item Selected:" + item,4);
			getSyntaxEditorPane().suggestionSelected(item);
		}
	}
	// A simple class that searches for a word in
	// a document and highlights occurrences of that word

	class WordSearcher {
	  public WordSearcher(JTextComponent comp) {
	    this.comp = comp;
	  }

	  // Search for a word and return the offset of the
	  // first occurrence. 
	  public int search(String word) {
	    int firstOffset = -1;

	    if (word == null || word.equals("")) {
	      return -1;
	    }

	    // Look for the word we are given - insensitive search
	    String content = null;
	    try {
	      Document d = comp.getDocument();
	      content = d.getText(0, d.getLength()).toLowerCase();
	    } catch (BadLocationException e) {
	      // Cannot happen
	      return -1;
	    }

	    word = word.toLowerCase();
	    int lastIndex = 0;
	    int wordSize = word.length();

	    while ((lastIndex = content.indexOf(word, lastIndex)) != -1) {
	      int endIndex = lastIndex + wordSize;
	      //try {
	        //highlighter.addHighlight(lastIndex, endIndex, painter);
	      //} catch (BadLocationException e) {
	        // Nothing to do
	     // }
	      if (firstOffset == -1) {
	        firstOffset = lastIndex;
	      }
	      lastIndex = endIndex;
	    }

	    return firstOffset;
	  }

	  protected JTextComponent comp;
	}

	public class syntaxEditorPane extends JTextPane implements DocumentListener,KeyListener,CaretListener,MouseListener,MouseMotionListener {
		private	Vector 			formats = new Vector();
		private	boolean 		applyFormats = true;
		private	HTMLEditorKit 	kit;
		private int				documentPos = 0;
		private	String 			currentWord = "";
		private int				currentRow = 0;
		private int				currentCol = 0;
		protected boolean		bInit = false;
		private	int				maxLineNumber = 0;
		private SEPScrollPane 	sp = null;
		private String			hoverWord = "",lastHoverWord="";
		private boolean 		bAutoComplete = true;
		private boolean			bIntelliSense = true;
		private	floatingWindow	intelliSenseWindow = null,sugsWindow = null;
		
		public void loadAsXML(String filename) {
			removeAllFormats();
			xmlDataFile f = new xmlDataFile();
			f.openXMLDataFile(filename,"syntaxeditorpaneformats");
			NodeList nl = f.buildNodeList("syntaxeditorpaneformat");
			for (int i=0;i<nl.getLength();i++) {
				org.w3c.dom.Node n = nl.item(i);
				String name = n.getNodeName();
				org.w3c.dom.Element e = (org.w3c.dom.Element)n;

				String nodeAttribs = "";
				nodeAttribs = e.getAttribute("name");
				nodeAttribs = nodeAttribs + "," + e.getAttribute("regex");
				nodeAttribs = nodeAttribs + "," + e.getAttribute("starthtml");
				nodeAttribs = nodeAttribs + "," + e.getAttribute("endhtml");
						
				Vector v1 = supportFunctions.splitIntoTokens(nodeAttribs);
				addFormat(new syntaxEditorPaneFormat((String)v1.elementAt(0),(String)v1.elementAt(1),(String)v1.elementAt(2),(String)v1.elementAt(3)));
			}
			f.closeXMLDataFile();
		}
		public void saveAsXML(String filename) {
			xmlDataFile f = new xmlDataFile();
			f.openXMLDataFile(filename,"syntaxeditorpaneformats");
			org.w3c.dom.Element root = f.getRootElement();
			org.w3c.dom.Document doc = f.getXMLDocument();
			for (int i=0;i<formats.size();i++) {
				syntaxEditorPaneFormat format = (syntaxEditorPaneFormat)formats.elementAt(i);
				format.saveAsXML(doc,root);
			}
			f.closeXMLDataFile();
		}
		public void suggestionSelected(String suggestion) {
			SEPSuggestionSelected(suggestion);
			getSugsWindow().destory();
		}
		public void SEPSuggestionSelected(String suggestion) {
			Document doc = getDocument();
			try {
				doc.insertString(getCaretPosition(), suggestion, null);
			} catch (Exception e) {;}
		}
		public boolean getAutoComplete() {return bAutoComplete;}
		public boolean getIntelliSense() {return bIntelliSense;}
		public void setAutoComplete(boolean b) {bAutoComplete = b;}
		public void setIntelliSense(boolean b) {bIntelliSense = b;}
		public String[] SEPAutoCompleteSuggestions(String text) {
			return null;
		}
		public String SEPIntelliSenseString(String s) {return null;}
		public String getHoverWord() {return hoverWord;}
		public void setScrollPane(SEPScrollPane sp) {this.sp = sp;}
		public SEPScrollPane getScrollPane() {return sp;}
		public void gotoLine() {
			int gotoLine = getPropValue("Enter Line Number","Line Number (1-"+String.valueOf(getMaxLineNumber())+"):",getCurrentRow()+1);
			if (gotoLine > 0 && gotoLine < getMaxLineNumber()+1) {
				int pos = 1; // 1st documentPos is 1
				gotoLine = gotoLine - 1; // make zero based
				Vector lines = supportFunctions.splitIntoTokens(getRawText(),"\n");
				for(int i=0;i<gotoLine;i++) {
					String line = (String)lines.elementAt(i);
					pos = pos + line.length() + 1;
				}
				setCaretPosition(pos);
			} else {
				displayDialog("Invalid Line Number");
			}
		}
		public int getMaxLineNumber() {return maxLineNumber;}
		public void setMaxLineNumber(int num) {
			SEPUpdateMaxLineNumber(num);
			maxLineNumber = num;
		}
		public void SEPUpdateMaxLineNumber(int num) {
		}
		
		public void mouseEntered(MouseEvent evt) {}
		public void mouseExited(MouseEvent evt) {}
		public void mouseClicked(MouseEvent evt) {
				if (evt.getClickCount() == 2) {
				}
		}
		public void mousePressed(MouseEvent evt) {
			  int button = evt.getModifiers();
			  if (evt.getClickCount() == 2) {return;}
			  if ((button & MouseEvent.BUTTON3_MASK) != 0) {
				  SEPRightClickAction(evt);
			  } else {
			  }
		}
		public void mouseReleased(MouseEvent evt) {}
		public floatingWindow getSugsWindow() {return sugsWindow;}
		public void doSuggestions(DocumentEvent e) {
			if (getAutoComplete() == true) {
				String word = getWordAtPos(getRawText(),e.getOffset());
				String[] suggestions = SEPAutoCompleteSuggestions(word);
				if (suggestions != null) {
					if (sugsWindow != null) {sugsWindow.destory();}
					suggestionPanel p = new suggestionPanel(this);
					List sugs = new List(5);
					for (int i=0;i<suggestions.length;i++) {
						sugs.add(suggestions[i]);
					}
					sugs.addItemListener(p);
					p.add(sugs);
					sugs.select(0);
					sugsWindow = new floatingWindow(p,"Suggestions");
				}
			}						
		}
		public void mouseMoved(MouseEvent evt) {
			JTextPane editor = (JTextPane) evt.getSource();
			Document doc = editor.getDocument();
			if (doc instanceof HTMLDocument) {
				HTMLDocument htmlDoc = (HTMLDocument) doc;
			    Point loc = evt.getPoint();
			    int pos = editor.viewToModel(loc);
			    //TRACE("Document Position:"+String.valueOf(pos),4);
				hoverWord = getWordAtPos(getRawText(),pos);
				//TRACE("Document Word:"+hoverWord,4);
			}
			if (getIntelliSense()) {
				String text = SEPIntelliSenseString(hoverWord);
				if (text != null) 
				{
					if (intelliSenseWindow != null) {
						if (!intelliSenseWindow.isValid()) {intelliSenseWindow = null;}
					}
					if (intelliSenseWindow != null && lastHoverWord.equals(hoverWord)) {
					} else {
						if (intelliSenseWindow != null) {
							intelliSenseWindow.destory();
							intelliSenseWindow = null;
						}
						lastHoverWord = hoverWord;
						intelliSenseWindow = new floatingWindow(text,"title",20,5);
					}
				} else {
					// remove any existing msg window
					if (intelliSenseWindow != null) {
							intelliSenseWindow.destory();
							intelliSenseWindow = null;
							lastHoverWord = "";
					}
				}
			}
			SEPHoverAction(evt);
	    }
		public void mouseDragged(MouseEvent evt) {
	    }

		public String getCurrentWord() {return currentWord;}
		public String getWordAtPos(String line,int pos) {
			String word = "";
			if (pos < 0 || pos >= line.length()) {return "";}
			int beginIndex = 0;
			int endIndex = line.length() - 1;
			for (int i=pos;i>-1;i--) {
				if (line.charAt(i) == ' ' || line.charAt(i) == '\n') {
					beginIndex = i + 1;
					break;
				}
			}
			for (int i=pos+1;i<line.length();i++) {
				if (line.charAt(i) == ' ' || line.charAt(i) == '\n') {
					endIndex = i - 1;
					break;
				}
			}
			
			return line.substring(beginIndex, endIndex+1);
		}
		public String getLineText(int lineNumber) {
			Vector lines = supportFunctions.splitIntoTokens(getRawText(),"\n");
			if (lineNumber<0 || lineNumber>lines.size()) {return "";}
			return (String)lines.elementAt(lineNumber);
		}
		public void updateCurrentWord(int row,int col) {
			Vector lines = supportFunctions.splitIntoTokens(getRawText(),"\n");
			setMaxLineNumber(lines.size());
			if (lines.size() == 0) {currentWord="";return;} // no text!!!
			currentWord = getWordAtPos((String)lines.elementAt(row),col);
		}
		public syntaxEditorPane() {
			super();

			setEditable(true);
			setEditorKitForContentType("text/html",new HTMLEditorKit());
			//setEditorKitForContentType("text/html",new syntaxPaneEditorKit());
	        //setEditorKitForContentType("text/html",new CollapsibleEditorKit());
			setContentType("text/html");
			addKeyListener(this);
			addCaretListener(this);
			addMouseListener(this);
			addMouseMotionListener(this);
			getDocument().addDocumentListener(this);
			
			kit = (HTMLEditorKit)getEditorKit();
			StyleSheet ss = new StyleSheet();
			try {
				URL ssURL = new URL(getCodeBase(),remoteHostRelativePath+"/css/syntaxeditorpane.css");
				BufferedReader in = new BufferedReader(new InputStreamReader(ssURL.openStream()));
				ss.loadRules(in,null);
				kit.setStyleSheet(ss);
			} catch (Exception e) {;}
			//StyleSheet styles = kit.getStyleSheet();
			//Enumeration rules = styles.getStyleNames();
			//while (rules.hasMoreElements()) {
             //String name = (String) rules.nextElement();
             //Style rule = styles.getStyle(name);
             //displayDialog(rule.toString());
			//}
		}
		public int getRow(int pos, syntaxEditorPane editor) {
			int rn = (pos==0) ? 1 : 0;
			try {
				int offs=pos;
				while( offs>0) {
					offs=Utilities.getRowStart(editor, offs)-1;
					rn++;
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			return rn;
		}
		public int getColumn(int pos, syntaxEditorPane editor) {
			try {
				return pos-Utilities.getRowStart(editor, pos)+1;
			} catch (Exception e) {
				e.printStackTrace();
			}
			return -1;
		}
		public void caretUpdate(CaretEvent e) {
			documentPos = e.getDot();
			clickedAt(getRow(e.getDot(), (syntaxEditorPane)e.getSource()),getColumn(e.getDot(), (syntaxEditorPane)e.getSource()));
		}
		public void textUpdated(DocumentEvent e) {
			
		}
		public void textUpdated1(DocumentEvent e) {
			doSuggestions(e);
			Vector lines = supportFunctions.splitIntoTokens(getRawText(),"\n");
			setMaxLineNumber(lines.size());
			textUpdated(e);
		}
		public void insertUpdate(DocumentEvent e) {
			textUpdated1(e);
		}
	    public void removeUpdate(DocumentEvent e) {
			textUpdated1(e);
	    }
	    public void changedUpdate(DocumentEvent e) {
	        //Plain text components do not fire these events
			textUpdated1(e);
	    }
		public void keyTyped(KeyEvent evt) {
			char keyTyped = evt.getKeyChar();
		}	
		public void keyReleased(KeyEvent evt) {
		}	
		public void keyPressed(KeyEvent evt) {
			int mods = evt.getModifiers();
			int keyCode = evt.getKeyCode();
			boolean shiftDown = false;
			boolean ctrlDown = false;
			if ((mods & InputEvent.SHIFT_MASK) != 0) {shiftDown = true;}
			if ((mods & InputEvent.CTRL_MASK) != 0) {ctrlDown = true;}

			if (keyCode == KeyEvent.VK_G && ctrlDown == true) {
				gotoLine();
			}
			if (keyCode == KeyEvent.VK_F && ctrlDown == true) {
				searchReplace();
			}
			if (keyCode == KeyEvent.VK_A && ctrlDown == true) {
				makeCollapsibleArea();
			}
			if (keyCode == KeyEvent.VK_B && ctrlDown == true) {
				clearCollapsibleArea();
			}
			if (keyCode == KeyEvent.VK_H && ctrlDown == true) {
				//setTextNew("",0);
				setText("I Love\nJoide <font color='red'>Foster</font>");
			}
			if (keyCode == KeyEvent.VK_ENTER) {
				try {
					kit.insertHTML((HTMLDocument)getDocument(),documentPos,"<font>&nbsp;<br>&nbsp;</font>",0,0,HTML.Tag.FONT);
				} catch (Exception e) {;}
				evt.consume(); // dispose of VK_ENTER key event
				return;				
			}
		}
		public void searchReplace() { // override in derived class
		}
		public boolean getApplyFormats() {return applyFormats;}
		public void setApplyFormats(boolean b) {applyFormats = b;}
		public String stringRepeat(String s,int count) {
			String ret = "";
			for (int i=0;i<count;i++) {ret = ret + s;}
			return ret;
		}
		public String doFormats(String s) {
			if (!applyFormats) {return s;}
			String searchString = s;
			for (int i=0;i<formats.size();i++) {
				syntaxEditorPaneFormat format = (syntaxEditorPaneFormat)formats.elementAt(i);
				if (format.getEnabled() == true) {
					Pattern p = Pattern.compile(format.getFormatRegEx());
					Matcher m = p.matcher(searchString);
					int offset = 0;
					String tmp = searchString;
					if (m.groupCount() != 1) {
						displayDialog("More then one capture group");
					}
					while (m.find()) {
						int startPos = m.start(1) + offset;
						int endPos = startPos + m.group(1).length();
						offset = offset + format.getFormatStartHTML().length() +  format.getFormatEndHTML().length();
						s = s.substring(0, startPos) + format.getFormatStartHTML() + m.group(1) + format.getFormatEndHTML() + s.substring(endPos);
						tmp = tmp.substring(0,startPos) + stringRepeat("#",format.getFormatStartHTML().length()+m.group(1).length()+format.getFormatEndHTML().length())+tmp.substring(endPos);
					}
					searchString = tmp;
				}
			}

			return s;
		}
		public Vector getFormats() {return formats;}
		public void addFormat(syntaxEditorPaneFormat format) {
			formats.addElement(format);
		}
		public void removeFormat(String name) {
			for (int i=0;i<formats.size();i++) {
				syntaxEditorPaneFormat format = (syntaxEditorPaneFormat)formats.elementAt(i);
				if (name.equals(format.getFormatName())) {
					formats.removeElement(format);
					return; // as we now have changed size of vector
				}
			}
		}
		public void removeAllFormats() {
			formats.removeAllElements();
		}
		public String getTextNew() {
			HTMLDocument doc = (HTMLDocument)getDocument();
			int length = doc.getLength();
			String text = "";
			try {
				text = doc.getText(0, length);
			} catch (Exception e) {;}
			
			return text;
		}
		public void setTextNew(String text,int nOffset) {
			HTMLDocument doc = (HTMLDocument)getDocument();
			//Vector lines = supportFunctions.splitIntoTokens(text,"\n");
			//setMaxLineNumber(lines.size());

			//setText(text);

			try {
				 kit.insertHTML(doc, doc.getLength(), "<span><b>hello</span>", 0, 0, HTML.Tag.SPAN);
				 kit.insertHTML(doc, doc.getLength(), "<span><font color='red'><u>world</u></font></span>", 0, 0, HTML.Tag.SPAN);
//				Element[] roots = doc.getRootElements(); // #0 is the HTML element, #1 the bidi-root
//				Element body = null;
//				for( int i = 0; i < roots[0].getElementCount(); i++ ) {
//				    Element element = roots[0].getElement( i );
//				    if( element.getAttributes().getAttribute( StyleConstants.NameAttribute ) == HTML.Tag.BODY ) {
//				        body = element;
//				        break;
//				    }
//				}
//				doc.insertAfterStart( body, text );

				//kit.insertHTML((HTMLDocument)getDocument(),nOffset,text,0,0,HTML.Tag.BR);
				//doc.insertString(nOffset, text, new SimpleAttributeSet());
			} catch (Exception e) {;}
		}
		public String getRawText() {
			//String text = getTextNew();
			
			String text = getText();
			text = text.replace("\n", "");
			text = text.replace("<br>","\n");
			text = stripHTMLStrutureTags(text);
			text = stripHTMLTags(text);
			text = text.replaceAll("\\s{2,}"," ");
			text = text.trim();			
			return text;
		}
		public void setRawText(String s) {
			Vector lines = supportFunctions.splitIntoTokens(s,"\n");
			setMaxLineNumber(lines.size());

			s = s.replaceAll("<","&lt"); 			
			s = s.replaceAll(">","&gt"); 			
			s = s.replaceAll("\\n","<br>\n"); // as we loading text into an HTML control
			
			s = doFormats(s);
			setText(s);
		}
		public String stripHTMLStrutureTags(String s) {
			s = s.replaceAll("<html>","");
			s = s.replaceAll("</html>","");
			s = s.replaceAll("<head>","");
			s = s.replaceAll("</head>","");
			s = s.replaceAll("<body>","");
			s = s.replaceAll("</body>","");
			return s;
		}
		public String stripHTMLTags(String s) {
			s = s.replaceAll("<p.*?>","");
			s = s.replaceAll("</p>","");
			s = s.replaceAll("<font.*?>","");
			s = s.replaceAll("</font>","");
			s = s.replaceAll("<b>","");
			s = s.replaceAll("</b>","");
			s = s.replaceAll("<i>","");
			s = s.replaceAll("</i>","");
			s = s.replaceAll("&quot;","\"");
			s = s.replaceAll("&lt;","<");
			s = s.replaceAll("&gt;",">");
			return s;
		}
		public void clickedAt(int row,int col) {
			if (bInit == true) {return;} 
			currentRow = row-1;
			currentCol = col-1;
			updateCurrentWord(row-1,col-1);
			displayDialog(getCurrentWord());
			//displayDialog("Clicked on row " + String.valueOf(row-1) + " Column " + String.valueOf(col-1));		
			//displayDialog("documentPos:"+String.valueOf(documentPos));
			SEPClickedAt(row-1,col-1);
		}
		public int getDocumentPos() {return documentPos;}
		public int getCurrentRow() {return currentRow;}
		public int getCurrentCol() {return currentCol;}
		public void SEPHoverAction(MouseEvent evt){
			
		}
		public void SEPRightClickAction(MouseEvent evt){
			
		}
		public void SEPClickedAt(int row,int col){
		}
		protected CollapsibleView getCollapsibleView(int offset) {
	        View v=getUI().getRootView(this);
	        while( v!=null && v.getViewCount()>0) {
	            if (v instanceof CollapsibleView) {
	                return (CollapsibleView)v;
	            }
	            int i=v.getViewIndex(offset, Position.Bias.Forward);
	            if (i>=0 && i<v.getViewCount()) {
	                v=v.getView(i);
	            }
	            else {
	                break;
	            }
	        }

	        return null;
	    }
		protected void insertSpecs(DefaultStyledDocument doc, int offset, DefaultStyledDocument.ElementSpec[] specs) {
	        try {
//	            doc.insert(0, specs);  method is protected so we have to
	            //extend document or use such a hack
	            Method m=DefaultStyledDocument.class.getDeclaredMethod("insert", new Class[] {int.class, DefaultStyledDocument.ElementSpec[].class});
	            m.setAccessible(true);
	            m.invoke(doc, new Object[] {offset, specs});
	        } catch (Exception e) {
	            e.printStackTrace();
	        }
	    }
		protected void makeCollapsibleArea() {
	        try {
	            int start=getSelectionStart();
	            int end=getSelectionEnd();
	            if (start==end) {
	                return;
	            }
	            clearCollapsibleArea();
	            if (start>end) {
	                int tmp=start;
	                start=end;
	                end=tmp;
	            }

	            DefaultStyledDocument doc=(DefaultStyledDocument)getDocument();
	            start=(doc).getParagraphElement(start).getStartOffset();
	            end=doc.getParagraphElement(end).getEndOffset();

	            ArrayList<DefaultStyledDocument.ElementSpec> specs=new ArrayList<DefaultStyledDocument.ElementSpec>();
	            DefaultStyledDocument.ElementSpec spec;
	            int offs=start;
	            while (offs<end) {
	                Element par=doc.getParagraphElement(offs);

	                spec=new DefaultStyledDocument.ElementSpec(par.getAttributes(), DefaultStyledDocument.ElementSpec.StartTagType);
	                specs.add(spec);
	                for (int i=0; i<par.getElementCount(); i++) {
	                    Element leaf=par.getElement(i);
	                    String text=doc.getText(leaf.getStartOffset(), leaf.getEndOffset()-leaf.getStartOffset());
	                    spec=new DefaultStyledDocument.ElementSpec(leaf.getAttributes(),DefaultStyledDocument.ElementSpec.ContentType, text.toCharArray(), 0, text.length());
	                    specs.add(spec);
	                }
	                spec=new DefaultStyledDocument.ElementSpec(par.getAttributes(), DefaultStyledDocument.ElementSpec.EndTagType);
	                specs.add(spec);

	                offs=par.getEndOffset();
	            }

	            doc.remove(start, end-start);
	            DefaultStyledDocument.ElementSpec[] specArray = new DefaultStyledDocument.ElementSpec[specs.size()+4];
	            DefaultStyledDocument.ElementSpec closePar = new DefaultStyledDocument.ElementSpec(new SimpleAttributeSet(), DefaultStyledDocument.ElementSpec.EndTagType);
	            specArray[0]=closePar;

	            SimpleAttributeSet attrs=new SimpleAttributeSet();
	            attrs.addAttribute(DefaultStyledDocument.ElementNameAttribute, COLLAPSIBLE_AREA_ELEMENT);
	            DefaultStyledDocument.ElementSpec areaStart = new DefaultStyledDocument.ElementSpec(attrs, DefaultStyledDocument.ElementSpec.StartTagType);
	            specArray[1]=areaStart;

	            for (int i=0; i<specs.size(); i++) {
	                specArray[i+2]=specs.get(i);
	            }

	            DefaultStyledDocument.ElementSpec areaEnd = new DefaultStyledDocument.ElementSpec(attrs, DefaultStyledDocument.ElementSpec.EndTagType);
	            specArray[specArray.length-2]=areaEnd;

	            DefaultStyledDocument.ElementSpec openPar = new DefaultStyledDocument.ElementSpec(attrs, DefaultStyledDocument.ElementSpec.StartTagType);
	            specArray[specArray.length-1]=openPar;

	            insertSpecs(doc, start, specArray);
	        } catch (BadLocationException e) {
	            e.printStackTrace();  
	        }
	    }    
	    protected void clearCollapsibleArea() {
	        try {
	            DefaultStyledDocument doc=(DefaultStyledDocument)getDocument();
	            Element root=doc.getDefaultRootElement();
	            for (int i=0; i<root.getElementCount(); i++) {
	                Element elem=root.getElement(i);
	                if (COLLAPSIBLE_AREA_ELEMENT.equals(elem.getName())) {
	                    ArrayList<DefaultStyledDocument.ElementSpec> specs=new ArrayList<DefaultStyledDocument.ElementSpec>();
	                    DefaultStyledDocument.ElementSpec spec;
	                    for (int j=0; j<elem.getElementCount(); j++) {
	                        Element par=elem.getElement(j);
	                        spec=new DefaultStyledDocument.ElementSpec(par.getAttributes(), DefaultStyledDocument.ElementSpec.StartTagType);
	                        specs.add(spec);
	                        for (int k=0; k<par.getElementCount(); k++) {
	                            Element leaf=par.getElement(k);
	                            String text=doc.getText(leaf.getStartOffset(), leaf.getEndOffset()-leaf.getStartOffset());
	                            spec=new DefaultStyledDocument.ElementSpec(leaf.getAttributes(),DefaultStyledDocument.ElementSpec.ContentType, text.toCharArray(), 0, text.length());
	                            specs.add(spec);
	                        }
	                        spec=new DefaultStyledDocument.ElementSpec(par.getAttributes(), DefaultStyledDocument.ElementSpec.EndTagType);
	                        specs.add(spec);
	                    }

	                    int start=elem.getStartOffset();
	                    doc.remove(start, elem.getEndOffset()-start);

	                    DefaultStyledDocument.ElementSpec[] specArray = new DefaultStyledDocument.ElementSpec[specs.size()+2];
	                    DefaultStyledDocument.ElementSpec closePar = new DefaultStyledDocument.ElementSpec(new SimpleAttributeSet(), DefaultStyledDocument.ElementSpec.EndTagType);
	                    specArray[0]=closePar;

	                    for (int j=0; j<specs.size(); j++) {
	                        specArray[j+1]=specs.get(j);
	                    }

	                    DefaultStyledDocument.ElementSpec openPar = new DefaultStyledDocument.ElementSpec(new SimpleAttributeSet(), DefaultStyledDocument.ElementSpec.StartTagType);
	                    specArray[specArray.length-1]=openPar;

	                    insertSpecs(doc, start, specArray);
	                    break;
	                }
	            }
	        } catch (BadLocationException e) {
	            e.printStackTrace();  
	        }
	    }
	}
	
	public class CollapsibleEditorKit extends HTMLEditorKit { //StyledEditorKit {
	    MouseListener lstCollapse=new MouseAdapter() {
	        public void mouseClicked(MouseEvent e) {
	            JEditorPane src=(JEditorPane)e.getSource();

	            int pos=src.viewToModel(e.getPoint());
	            View v=src.getUI().getRootView(src);
	            while (v!=null && !(v instanceof CollapsibleView)) {
	                int i=v.getViewIndex(pos, Position.Bias.Forward);
	                v=v.getView(i);
	            }

	            if (v!=null) {
	                Shape a=getAllocation(v, src);
	                if (a!=null) {
	                    Rectangle r=a instanceof Rectangle ? (Rectangle)a : a.getBounds();
	                    r.width=CollapsibleView.AREA_SHIFT;
	                    r.height=CollapsibleView.AREA_SHIFT;

	                    if (r.contains(e.getPoint())) {
	                        CollapsibleView cv=(CollapsibleView)v;
	                        cv.setExpanded(!cv.isExpanded());

	                        DefaultStyledDocument doc= (DefaultStyledDocument)src.getDocument();
	                        try {
	                            doc.insertString(pos, "\n", new SimpleAttributeSet());
	                            doc.remove(pos,1);
	                        } catch (BadLocationException e1) {
	                            e1.printStackTrace();
	                        }
	                    }
	                }
	            }
	        }
	    };

	    Cursor oldCursor;
	    MouseMotionListener lstMoveCollapse=new MouseMotionAdapter() {
	        public void mouseMoved(MouseEvent e) {
	            JEditorPane src=(JEditorPane)e.getSource();
	            if (oldCursor==null) {
	                oldCursor=src.getCursor();
	            }

	            int pos=src.viewToModel(e.getPoint());
	            View v=src.getUI().getRootView(src);
	            while (v!=null && !(v instanceof CollapsibleView)) {
	                int i=v.getViewIndex(pos, Position.Bias.Forward);
	                v=v.getView(i);
	            }

	            if (v!=null) {
	                Shape a=getAllocation(v, src);
	                if (a!=null) {
	                    Rectangle r=a instanceof Rectangle ? (Rectangle)a : a.getBounds();
	                    r.width=CollapsibleView.AREA_SHIFT;
	                    r.height=CollapsibleView.AREA_SHIFT;

	                    if (r.contains(e.getPoint())) {
	                        CollapsibleView cv=(CollapsibleView)v;

	                        src.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
	                        return;
	                    }
	                }
	            }

	            src.setCursor(oldCursor);
	        }
	    };

	    public ViewFactory getViewFactory() {
	        return new CollapsibleEditorKit.StyledViewFactory();
	    }
	    public void install(JEditorPane c) {
	        super.install(c);
	        c.addMouseListener(lstCollapse);
	        c.addMouseMotionListener(lstMoveCollapse);
	    }
	    public void deinstall(JEditorPane c) {
	        c.removeMouseListener(lstCollapse);
	        c.removeMouseMotionListener(lstMoveCollapse);
	        super.deinstall(c);
	    }

	    protected Shape getAllocation(View v, JEditorPane edit) {
	        Insets ins=edit.getInsets();
	        View vParent=v.getParent();
	        int x=ins.left;
	        int y=ins.top;
	        while(vParent!=null) {
	            int i=vParent.getViewIndex(v.getStartOffset(), Position.Bias.Forward);
	            Shape alloc=vParent.getChildAllocation(i, new Rectangle(0,0, Short.MAX_VALUE, Short.MAX_VALUE));
	            x+=alloc.getBounds().x;
	            y+=alloc.getBounds().y;

	            vParent=vParent.getParent();
	        }

	        if (v instanceof BoxView) {
	            int ind=v.getParent().getViewIndex(v.getStartOffset(), Position.Bias.Forward);
	            Rectangle r2=v.getParent().getChildAllocation(ind, new Rectangle(0,0,Integer.MAX_VALUE,Integer.MAX_VALUE)).getBounds();

	            return new Rectangle(x,y, r2.width, r2.height);
	        }

	        return new Rectangle(x,y, (int)v.getPreferredSpan(View.X_AXIS), (int)v.getPreferredSpan(View.Y_AXIS));
	    }


	    class StyledViewFactory implements ViewFactory {

	        public View create(Element elem) {
	            String kind = elem.getName();
	            if (kind != null) {
	                if (kind.equals(AbstractDocument.ContentElementName)) {
	                    return new LabelView(elem);
	                }
	                else if (kind.equals(AbstractDocument.ParagraphElementName)) {
	                    return new ParagraphView(elem);
	                }
	                else if (kind.equals(AbstractDocument.SectionElementName)) {
	                    return new BoxView(elem, View.Y_AXIS);
	                }
	                else if (kind.equals(StyleConstants.ComponentElementName)) {
	                    return new ComponentView(elem);
	                }
	                else if (kind.equals(StyleConstants.IconElementName)) {
	                    return new IconView(elem);
	                }
	                else if (kind.equals(COLLAPSIBLE_AREA_ELEMENT)) {
	                    return new CollapsibleView(elem);
	                }
	            }

	            // default to text display
	            return new LabelView(elem);
	        }

	    }
	}
	public class CollapsibleView extends BoxView {
	    private boolean isExpanded=true;
	    public static final int AREA_SHIFT=10;

	    public CollapsibleView(Element elem) {
	        super(elem, View.Y_AXIS);
	        setInsets((short)0, (short)AREA_SHIFT, (short)0, (short)0);
	    }
	    
	    public void paint(Graphics g, Shape alloc) {
	        Rectangle a=alloc instanceof Rectangle ? (Rectangle)alloc : alloc.getBounds();
	        Shape oldClip=g.getClip();
	        if (!isExpanded()) {
	            Area newClip=new Area(oldClip);
	            newClip.intersect(new Area(a));
	            g.setClip(newClip);
	        }
	        super.paint(g, a);
	        g.setClip(oldClip);
	        a.width--;
	        a.height--;
	        g.setColor(Color.lightGray);
	        ((Graphics2D)g).draw(a);
	        g.drawRect(a.x,  a.y, AREA_SHIFT,AREA_SHIFT);

	        if (!isExpanded()) {
	            g.drawLine(a.x+AREA_SHIFT/2, a.y+2, a.x+AREA_SHIFT/2, a.y+AREA_SHIFT-2);
	        }
	        g.drawLine(a.x+2, a.y+AREA_SHIFT/2, a.x+AREA_SHIFT-2, a.y+AREA_SHIFT/2);
	    }

	    public float getPreferredSpan(int axis) {
	        if (isExpanded() || axis!=View.Y_AXIS) {
	            return super.getPreferredSpan(axis);
	        }
	        else {
	            View firstChild=getView(0);
	            if (firstChild instanceof BoxView && ((BoxView)firstChild).getAxis()==View.Y_AXIS) {
	                return getTopInset()+firstChild.getView(0).getPreferredSpan(View.Y_AXIS);
	            }
	            else {
	                return getTopInset()+firstChild.getPreferredSpan(View.Y_AXIS);
	            }
	        }
	    }

	    public float getMinimumSpan(int axis) {
	        if (isExpanded() || axis!=View.Y_AXIS) {
	            return super.getMinimumSpan(axis);
	        }
	        else {
	            View firstChild=getView(0);
	            if (firstChild instanceof BoxView && ((BoxView)firstChild).getAxis()==View.Y_AXIS) {
	                return getTopInset()+firstChild.getView(0).getMinimumSpan(View.Y_AXIS);
	            }
	            else {
	                return getTopInset()+firstChild.getMinimumSpan(View.Y_AXIS);
	            }
	        }
	    }

	    public float getMaximumSpan(int axis) {
	        if (isExpanded() || axis!=View.Y_AXIS) {
	            return super.getMaximumSpan(axis);
	        }
	        else {
	            View firstChild=getView(0);
	            if (firstChild instanceof BoxView && ((BoxView)firstChild).getAxis()==View.Y_AXIS) {
	                return getTopInset()+firstChild.getView(0).getMaximumSpan(View.Y_AXIS);
	            }
	            else {
	                return getTopInset()+firstChild.getMaximumSpan(View.Y_AXIS);
	            }
	        }
	    }

	    public boolean isExpanded() {
	        return isExpanded;
	    }

	    public void setExpanded(boolean expanded) {
	        isExpanded = expanded;
	    }

	    protected int getNextNorthSouthVisualPositionFrom(int pos, Position.Bias b,
							      Shape a, int direction,
							      Position.Bias[] biasRet)
		                                        throws BadLocationException {
	        int newPos=super.getNextNorthSouthVisualPositionFrom(pos, b, a, direction, biasRet);
	        if (!isExpanded()) {
	            if (newPos<getView(0).getView(0).getEndOffset()) {
	                //first line of first child
	                return newPos;
	            }
	            if (direction== SwingConstants.SOUTH) {
	                int ind=getParent().getViewIndex(getStartOffset(), Position.Bias.Forward);
	                if (ind<getParent().getViewCount()) {
	                    while (newPos<getEndOffset() && newPos>=0) {
	                        int p=super.getNextNorthSouthVisualPositionFrom(newPos, b, a, direction, biasRet);
	                        if (p<0) {
	                            newPos=getParent().getNextVisualPositionFrom(newPos, b, a, direction, biasRet);
	                            break;
	                        }
	                        newPos=p;
	                    }
	                }
	            }
	            else {
	                int ind=getParent().getViewIndex(getStartOffset(), Position.Bias.Forward);
	                if (ind<getParent().getViewCount()) {
	                    while (newPos>getStartOffset() && newPos>0) {
	                        int p=super.getNextNorthSouthVisualPositionFrom(newPos, b, a, direction, biasRet);
	                        if (p<0) {
	                            newPos=getParent().getNextVisualPositionFrom(newPos, b, a, direction, biasRet);
	                            break;
	                        }
	                        newPos=p;
	                        if (newPos<getView(0).getView(0).getEndOffset()) {
	                            //first line of first child
	                            return newPos;
	                        }
	                    }
	                }
	            }
	        }

	        return newPos;
	    }

	    protected int getNextEastWestVisualPositionFrom(int pos, Position.Bias b,
							    Shape a,
							    int direction,
							    Position.Bias[] biasRet)
		                                        throws BadLocationException {
	        int newPos=super.getNextEastWestVisualPositionFrom(pos, b, a, direction, biasRet);
	        if (!isExpanded()) {
	            if (newPos>=getStartOffset() && newPos<getView(0).getView(0).getEndOffset()) {
	                //first line of first child
	                return newPos;
	            }
	            else if (newPos>=getView(0).getView(0).getEndOffset()) {
	                if (direction==SwingConstants.EAST) {
	                    newPos=Math.min(getDocument().getLength()-1, getEndOffset());
	                }
	                else {
	                    newPos=getView(0).getView(0).getEndOffset()-1;
	                }
	            }
	        }

	        return newPos;
	    }
	}

	public class syntaxEditorPaneDialog extends JDialog implements ActionListener {
		   private syntaxEditorPane	HDLTA;
		   private Button			ok;
		   
		   public syntaxEditorPaneDialog(Frame parent) {
		   		  super(parent,"Syntax Editor Pane Test",true);
				  setLayout(new FlowLayout(FlowLayout.CENTER));
	   			  addWindowListener(new WindowAdapter() {
	   			     public void windowClosing(WindowEvent evt) {
	   		            dispose();
	                 }
			      });
				  HDLTA = new syntaxEditorPane();
				  HDLTA.setBackground(lightyellow);
				  HDLTA.setRawText("I love <b>Joide</b>");
				  JScrollPane sp = new JScrollPane(HDLTA);
				  sp.setPreferredSize(new Dimension(15*charWidth,5*charHeight));
 				  ok = new Button("Ok");
				  ok.addActionListener(this);
				  add(sp);
				  add(ok);
				  pack();
				  setVisible(true);
		   }
		   
			public void actionPerformed(ActionEvent evt) {
				if (evt.getSource() == ok) {
					dispose();
				}
			}
		   
		   public void destroy() {
		   		  dispose();
		   }	
	}

	public class drawingItemPropsDialog extends JDialog implements ActionListener {
		   private	Button		ok,cancel,chooseColor;
		   private	Color		strokeColor;
		   private	JSpinner	ctrStrokeWidth;
		   private	boolean		OKPressed = false;
		   
		   public drawingItemPropsDialog(Frame parent,drawingItem di) {
		   		  super(parent,"Drawing Item Properties",true);
				  setLayout(new FlowLayout(FlowLayout.CENTER));
	   			  addWindowListener(new WindowAdapter() {
	   			     public void windowClosing(WindowEvent evt) {
	   		            dispose();
	                 }
			      });

				strokeColor = di.getColor();			
				ctrStrokeWidth = new JSpinner();
				ctrStrokeWidth.setValue(new Integer(di.getStrokeWidth()));
				add(ctrStrokeWidth);
				chooseColor = new Button("Choose Color");
				chooseColor.addActionListener(this);
				add(chooseColor);
				ok = new Button("Ok");
				ok.addActionListener(this);
				add(ok);
				cancel = new Button("Cancel");
				cancel.addActionListener(this);
				add(cancel);
				pack();
				setVisible(true);
		   	}		   
			public boolean isOK() {return OKPressed;}
			public Color getColor() {return strokeColor;}
			public int getStrokeWidth() {return (Integer)ctrStrokeWidth.getValue();}
			public void actionPerformed(ActionEvent evt) {
				if (evt.getSource() == chooseColor) {
					Color c = JColorChooser.showDialog(this,"Choose Color",getColor());
					if (c != null) {strokeColor = c;}
				}
				if (evt.getSource() == ok) {OKPressed = true;dispose();}
				if (evt.getSource() == cancel) {dispose();}
			}
			public void destroy() {
		   		dispose();
		   	}
	}
	
	public class connectorPropsDialog extends JDialog implements ActionListener {
		   	private 	Button	ok,cancel;
		   	private	JTextField	connectorTextStart,connectorTextEnd;
			private	boolean		OKPressed = false;
		   
		   	public connectorPropsDialog(Frame parent,drawingItemConnector conn) {
		   		super(parent,"Connector Properties",true);
				setLayout(new FlowLayout(FlowLayout.CENTER));
	   			addWindowListener(new WindowAdapter() {
	   				public void windowClosing(WindowEvent evt) {
	   		            	dispose();
	                 		}
			      });
				connectorTextStart = new JTextField("",20);
				connectorTextEnd = new JTextField("",20);
				connectorTextStart.setText(conn.getTextStart());
				connectorTextEnd.setText(conn.getTextEnd());
				add(connectorTextStart);
				add(connectorTextEnd);
				ok = new Button("Ok");
				ok.addActionListener(this);
				add(ok);
				cancel = new Button("Cancel");
				cancel.addActionListener(this);
				add(cancel);
				pack();
				setVisible(true);
		   	}
		   
			public void actionPerformed(ActionEvent evt) {
				if (evt.getSource() == ok) {OKPressed = true;dispose();}
				if (evt.getSource() == cancel) {dispose();}
			}
			public boolean isOK() {return OKPressed;}
			public String getTextStart() {return connectorTextStart.getText();}
			public String getTextEnd() {return connectorTextEnd.getText();}
			public void destroy() {
		   		  dispose();
		   	}
	}

public class ConnectLine {
    public static final int LINE_TYPE_SIMPLE = 0;
    public static final int LINE_TYPE_RECT_1BREAK = 1;
    public static final int LINE_TYPE_RECT_2BREAK = 2;

    public static final int LINE_START_HORIZONTAL = 0;
    public static final int LINE_START_VERTICAL = 1;

    public static final int LINE_ARROW_NONE = 0;
    public static final int LINE_ARROW_SOURCE = 1;
    public static final int LINE_ARROW_DEST = 2;
    public static final int LINE_ARROW_BOTH = 3;

    public int LINE_ARROW_WIDTH = 10;

    /**
     * Source line point
     */
    Point p1;
    /**
     * Destination line point
     */
    Point p2;

    /**
     * Line type can be one of LINE_TYPE_SIMPLE, LINE_TYPE_RECT_1BREAK, LINE_TYPE_RECT_2BREAK
     */
    int lineType = LINE_TYPE_SIMPLE;
    /**
     * for the LINE_TYPE_RECT_2BREAK type the param defines how line should be rendered
     */
    int lineStart = LINE_START_HORIZONTAL;
    /**
     * arrow can be one of following
     * LINE_ARROW_NONE - no arrow
     * LINE_ARROW_SOURCE - arrow beside source point
     * LINE_ARROW_DEST - arrow beside dest point
     * LINE_ARROW_BOTH - both source and dest has arrows
     */
    int lineArrow = LINE_ARROW_NONE;
	GeneralPath linePath = null;
    /**
     * Constructs default line
     * @param p1 Point start
     * @param p2 Point end
     */
    public ConnectLine(Point p1, Point p2) {
        this(p1, p2, LINE_TYPE_SIMPLE, LINE_START_HORIZONTAL, LINE_ARROW_NONE);
    }

    /**
     * Constructs line with specified params
     * @param p1 Point start
     * @param p2 Point end
     * @param lineType int type of line (LINE_TYPE_SIMPLE, LINE_TYPE_RECT_1BREAK, LINE_TYPE_RECT_2BREAK)
     * @param lineStart int for the LINE_TYPE_RECT_2BREAK type the param defines how line should be rendered
     * @param lineArrow int defines line arrow type
     */
    public ConnectLine(Point p1, Point p2, int lineType, int lineStart, int lineArrow) {
        this.p1 = p1;
        this.p2 = p2;
        this.lineType = lineType;
        this.lineStart = lineStart;
        this.lineArrow = lineArrow;
		this.linePath = null;
    }

    /**
     * Paints the line with specified params
     * @param g2d Graphics2D
     */
    public void paint(Graphics2D g2d) {
		linePath = new GeneralPath();
        switch (lineType) {
            case LINE_TYPE_SIMPLE:
                paintSimple(g2d);
                break;
            case LINE_TYPE_RECT_1BREAK:
                paint1Break(g2d);
                break;
            case LINE_TYPE_RECT_2BREAK:
                paint2Breaks(g2d);
                break;
        }
    }

    protected void paintSimple(Graphics2D g2d) {
		linePath.moveTo(p1.x, p1.y);linePath.lineTo(p2.x, p2.y);
        g2d.drawLine(p1.x, p1.y, p2.x, p2.y);
        switch (lineArrow) {
            case LINE_ARROW_DEST:
                paintArrow(g2d, p1, p2);
                break;
            case LINE_ARROW_SOURCE:
                paintArrow(g2d, p2, p1);
                break;
            case LINE_ARROW_BOTH:
                paintArrow(g2d, p1, p2);
                paintArrow(g2d, p2, p1);
                break;
        }
    }

    protected void paintArrow(Graphics2D g2d, Point p1, Point p2) {
        paintArrow(g2d, p1, p2, getRestrictedArrowWidth(p1, p2));
    }

    protected void paintArrow(Graphics2D g2d, Point p1, Point p2, int width) {
        Point2D.Float pp1 = new Point2D.Float(p1.x, p1.y);
        Point2D.Float pp2 = new Point2D.Float(p2.x, p2.y);
        Point2D.Float left = getLeftArrowPoint(pp1, pp2, width);
        Point2D.Float right = getRightArrowPoint(pp1, pp2, width);

        g2d.drawLine(p2.x, p2.y, Math.round(left.x), Math.round(left.y));
        g2d.drawLine(p2.x, p2.y, Math.round(right.x), Math.round(right.y));
    }

    protected void paint1Break(Graphics2D g2d) {
        if (lineStart == LINE_START_HORIZONTAL) {
			linePath.moveTo(p1.x, p1.y);linePath.lineTo(p2.x, p1.y);linePath.lineTo(p2.x, p2.y);
            g2d.drawLine(p1.x, p1.y, p2.x, p1.y);
            g2d.drawLine(p2.x, p1.y, p2.x, p2.y);
            switch (lineArrow) {
                case LINE_ARROW_DEST:
                    paintArrow(g2d, new Point(p2.x, p1.y), p2);
                    break;
                case LINE_ARROW_SOURCE:
                    paintArrow(g2d, new Point(p2.x, p1.y), p1);
                    break;
                case LINE_ARROW_BOTH:
                    paintArrow(g2d, new Point(p2.x, p1.y), p2);
                    paintArrow(g2d, new Point(p2.x, p1.y), p1);
                    break;
            }
        }
        else if (lineStart == LINE_START_VERTICAL) {
			linePath.moveTo(p1.x, p1.y);linePath.lineTo(p1.x, p2.y);linePath.lineTo(p2.x, p2.y);
            g2d.drawLine(p1.x, p1.y, p1.x, p2.y);
            g2d.drawLine(p1.x, p2.y, p2.x, p2.y);
            switch (lineArrow) {
                case LINE_ARROW_DEST:
                    paintArrow(g2d, new Point(p1.x, p2.y), p2);
                    break;
                case LINE_ARROW_SOURCE:
                    paintArrow(g2d, new Point(p1.x, p2.y), p1);
                    break;
                case LINE_ARROW_BOTH:
                    paintArrow(g2d, new Point(p1.x, p2.y), p2);
                    paintArrow(g2d, new Point(p1.x, p2.y), p1);
                    break;
            }
        }
    }

    protected void paint2Breaks(Graphics2D g2d) {
        if (lineStart == LINE_START_HORIZONTAL) {
			linePath.moveTo(p1.x, p1.y);linePath.lineTo(p1.x + (p2.x - p1.x) / 2, p1.y);
			linePath.lineTo(p1.x + (p2.x - p1.x) / 2, p2.y);linePath.lineTo(p2.x, p2.y);
            g2d.drawLine(p1.x, p1.y, p1.x + (p2.x - p1.x) / 2, p1.y);
            g2d.drawLine(p1.x + (p2.x - p1.x) / 2, p1.y, p1.x + (p2.x - p1.x) / 2, p2.y);
            g2d.drawLine(p1.x + (p2.x - p1.x) / 2, p2.y, p2.x, p2.y);
            switch (lineArrow) {
                case LINE_ARROW_DEST:
                    paintArrow(g2d, new Point(p1.x + (p2.x - p1.x) / 2, p2.y), p2);
                    break;
                case LINE_ARROW_SOURCE:
                    paintArrow(g2d, new Point(p1.x + (p2.x - p1.x) / 2, p1.y), p1);
                    break;
                case LINE_ARROW_BOTH:
                    paintArrow(g2d, new Point(p1.x + (p2.x - p1.x) / 2, p2.y), p2);
                    paintArrow(g2d, new Point(p1.x + (p2.x - p1.x) / 2, p1.y), p1);
                    break;
            }
        }
        else if (lineStart == LINE_START_VERTICAL) {
			linePath.moveTo(p1.x, p1.y);linePath.lineTo( p1.x, p1.y + (p2.y - p1.y) / 2);
			linePath.lineTo(p2.x, p1.y + (p2.y - p1.y) / 2);linePath.lineTo(p2.x, p2.y);
            
			g2d.drawLine(p1.x, p1.y, p1.x, p1.y + (p2.y - p1.y) / 2);
            g2d.drawLine(p1.x, p1.y + (p2.y - p1.y) / 2, p2.x, p1.y + (p2.y - p1.y) / 2);
            g2d.drawLine(p2.x, p1.y + (p2.y - p1.y) / 2, p2.x, p2.y);

            switch (lineArrow) {
                case LINE_ARROW_DEST:
                    paintArrow(g2d, new Point(p2.x, p1.y + (p2.y - p1.y) / 2), p2);
                    break;
                case LINE_ARROW_SOURCE:
                    paintArrow(g2d, new Point(p1.x, p1.y + (p2.y - p1.y) / 2), p1);
                    break;
                case LINE_ARROW_BOTH:
                    paintArrow(g2d, new Point(p2.x, p1.y + (p2.y - p1.y) / 2), p2);
                    paintArrow(g2d, new Point(p1.x, p1.y + (p2.y - p1.y) / 2), p1);
                    break;
            }
        }
    }

    public int getLineType() {
        return lineType;
    }

    public void setLineType(int type) {
        lineType = type;
    }

    public int getLineStart() {
        return lineStart;
    }

    public void setLineStart(int start) {
        lineStart = start;
    }

    public int getLineArrow() {
        return lineArrow;
    }

    public void setLineArrow(int arrow) {
        lineType = lineArrow;
    }

    public Point getP1() {
        return p1;
    }

    public void setP1(Point p) {
        p1 = p;
    }

    public Point getP2() {
        return p2;
    }

    public void setP2(Point p) {
        p2 = p;
    }
	public GeneralPath getLinePath() {
		return linePath;
	}

    protected Point2D.Float getMidArrowPoint(Point2D.Float p1, Point2D.Float p2, float w) {
        Point2D.Float res = new Point2D.Float();
        float d = Math.round(Math.sqrt( (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)));

        if (p1.x < p2.x) {
            res.x = p2.x - w * Math.abs(p1.x - p2.x) / d;
        }
        else {
            res.x = p2.x + w * Math.abs(p1.x - p2.x) / d;
        }

        if (p1.y < p2.y) {
            res.y = p2.y - w * Math.abs(p1.y - p2.y) / d;
        }
        else {
            res.y = p2.y + w * Math.abs(p1.y - p2.y) / d;
        }

        return res;
    }

    protected Point2D.Float getLeftArrowPoint(Point2D.Float p1, Point2D.Float p2) {
        return getLeftArrowPoint(p1, p2, LINE_ARROW_WIDTH);
    }

    protected Point2D.Float getLeftArrowPoint(Point2D.Float p1, Point2D.Float p2, float w) {
        Point2D.Float res = new Point2D.Float();
        double alpha = Math.PI / 2;
        if (p2.x != p1.x) {
            alpha = Math.atan( (p2.y - p1.y) / (p2.x - p1.x));
        }
        alpha += Math.PI / 10;
        float xShift = Math.abs(Math.round(Math.cos(alpha) * w));
        float yShift = Math.abs(Math.round(Math.sin(alpha) * w));
        if (p1.x <= p2.x) {
            res.x = p2.x - xShift;
        }
        else {
            res.x = p2.x + xShift;
        }
        if (p1.y < p2.y) {
            res.y = p2.y - yShift;
        }
        else {
            res.y = p2.y + yShift;
        }
        return res;
    }

    protected Point2D.Float getRightArrowPoint(Point2D.Float p1, Point2D.Float p2) {
        return getRightArrowPoint(p1, p2, LINE_ARROW_WIDTH);
    }

    protected Point2D.Float getRightArrowPoint(Point2D.Float p1, Point2D.Float p2, float w) {
        Point2D.Float res = new Point2D.Float();
        double alpha = Math.PI / 2;
        if (p2.x != p1.x) {
            alpha = Math.atan( (p2.y - p1.y) / (p2.x - p1.x));
        }
        alpha -= Math.PI / 10;
        float xShift = Math.abs(Math.round(Math.cos(alpha) * w));
        float yShift = Math.abs(Math.round(Math.sin(alpha) * w));
        if (p1.x < p2.x) {
            res.x = p2.x - xShift;
        }
        else {
            res.x = p2.x + xShift;
        }
        if (p1.y <= p2.y) {
            res.y = p2.y - yShift;
        }
        else {
            res.y = p2.y + yShift;
        }
        return res;
    }

    protected int getRestrictedArrowWidth(Point p1, Point p2) {
        return Math.min(LINE_ARROW_WIDTH, (int) Math.sqrt( (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)));
    }
}
public class JConnector {
    public static final int CONNECT_LINE_TYPE_SIMPLE = 0;
    public static final int CONNECT_LINE_TYPE_RECTANGULAR = 1;
    protected drawingItem source;
    protected drawingItem dest;
    protected ConnectLine line;
    protected int lineArrow = ConnectLine.LINE_ARROW_NONE;
    protected int lineType = CONNECT_LINE_TYPE_RECTANGULAR;
    protected Color lineColor;

    /**
     * Constructs default connector.
     * @param source drawingItem
     * @param dest darwingItem
     */
    public JConnector(drawingItem source, drawingItem dest) {
        this(source, dest, ConnectLine.LINE_ARROW_NONE, Color.BLACK);
    }

    /**
     * Constructs a connector with specified arrow and color.
     * @param source drawingItem
     * @param dest drawingItem
     * @param lineArrow int
     * @param lineColor Color
     */
    public JConnector(drawingItem source, drawingItem dest, int lineArrow, Color lineColor) {
        this(source, dest, lineArrow, CONNECT_LINE_TYPE_RECTANGULAR, lineColor);
    }

    /**
     * Constructs a connector with specified arrow, line type and color.
     * @param source drawingItem
     * @param dest drawingItem
     * @param lineArrow int
     * @param lineType int
     * @param lineColor Color
     */
    public JConnector(drawingItem source, drawingItem dest, int lineArrow, int lineType, Color lineColor) {
        this.source = source;
        this.dest = dest;
        this.lineArrow = lineArrow;
        this.lineType = lineType;
        this.lineColor = lineColor;
    }	
	public GeneralPath getConnectorPath() {return line.getLinePath();}
	public Point getP1() {return line.getP1();}
	public Point getP2() {return line.getP2();}
    /**
     * It resets clip to draw connecting line between components and set the clip back.
     * @param g2d Graphics2D
     */
    public void drawConnector(Graphics2D g2d) {
        calculateLine();
        if (line != null) {
            Shape oldClip = g2d.getClip();
            g2d.setClip(getLineBounds());
            g2d.setColor(lineColor);
            line.paint(g2d);
            g2d.setClip(oldClip);
        }
    }

    protected void calculateLine() {
        Rectangle rSource = source.getBoundingRect();
        Rectangle rDest = dest.getBoundingRect();
		
        if (rSource.intersects(rDest)) {
            line = null;
            return;
        }

        boolean xIntersect = (rSource.x <= rDest.x && rSource.x + rSource.width >= rDest.x)
            || (rDest.x <= rSource.x && rDest.x + rDest.width >= rSource.x);
        boolean yIntersect = rSource.y <= rDest.y && rSource.y + rSource.height >= rDest.y
            || (rDest.y <= rSource.y && rDest.y + rDest.height >= rSource.y);

        if (xIntersect) {
            int y1;
            int y2;
            int x1 = rSource.x + rSource.width / 2;
            int x2 = rDest.x + rDest.width / 2;
            if (rSource.y + rSource.height <= rDest.y) {
                //source higher
                y1 = rSource.y + rSource.height;
                y2 = rDest.y;
            }
            else {
                y1 = rSource.y;
                y2 = rDest.y + rDest.height;
            }
            line = new ConnectLine(new Point(x1, y1), new Point(x2, y2), ConnectLine.LINE_TYPE_RECT_2BREAK, ConnectLine.LINE_START_VERTICAL, lineArrow);
            if (lineType == CONNECT_LINE_TYPE_SIMPLE) {
                line.setLineType(ConnectLine.LINE_TYPE_SIMPLE);
            }
        }
        else if (yIntersect) {
            int y1 = rSource.y + rSource.height / 2;
            ;
            int y2 = rDest.y + rDest.height / 2;
            ;
            int x1;
            int x2;
            if (rSource.x + rSource.width <= rDest.x) {
                x1 = rSource.x + rSource.width;
                x2 = rDest.x;
            }
            else {
                x1 = rSource.x;
                x2 = rDest.x + rDest.width;
            }
            line = new ConnectLine(new Point(x1, y1), new Point(x2, y2), ConnectLine.LINE_TYPE_RECT_2BREAK, ConnectLine.LINE_START_HORIZONTAL, lineArrow);
            if (lineType == CONNECT_LINE_TYPE_SIMPLE) {
                line.setLineType(ConnectLine.LINE_TYPE_SIMPLE);
            }
        }
        else {
            int y1;
            int y2;
            int x1;
            int x2;
            if (rSource.y + rSource.height <= rDest.y) {
                //source higher
                y1 = rSource.y + rSource.height / 2;
                y2 = rDest.y;
                if (rSource.x + rSource.width <= rDest.x) {
                    x1 = rSource.x + rSource.width;
                }
                else {
                    x1 = rSource.x;
                }
                x2 = rDest.x + rDest.width / 2;
            }
            else {
                y1 = rSource.y + rSource.height / 2;
                y2 = rDest.y + rDest.height;
                if (rSource.x + rSource.width <= rDest.x) {
                    x1 = rSource.x + rSource.width;
                }
                else {
                    x1 = rSource.x;
                }
                x2 = rDest.x + rDest.width / 2;
            }
            line = new ConnectLine(new Point(x1, y1), new Point(x2, y2), ConnectLine.LINE_TYPE_RECT_1BREAK, ConnectLine.LINE_START_HORIZONTAL, lineArrow);
            if (lineType == CONNECT_LINE_TYPE_SIMPLE) {
                line.setLineType(ConnectLine.LINE_TYPE_SIMPLE);
            }
        }
    }

    protected Rectangle getLineBounds() {
        int add = 10;
        int maxX = Math.max(line.getP1().x, line.getP2().x);
        int minX = Math.min(line.getP1().x, line.getP2().x);
        int maxY = Math.max(line.getP1().y, line.getP2().y);
        int minY = Math.min(line.getP1().y, line.getP2().y);

        Rectangle res = new Rectangle(minX - add, minY - add, maxX - minX + 2 * add, maxY - minY + 2 * add);
        return res;
    }

    public drawingItem getSource() {
        return source;
    }
    public drawingItem getDest() {
        return dest;
    }

    public Color getLineColor() {
        return lineColor;
    }

    public void setLineColor(Color c) {
        lineColor = c;
    }

    public int getLineType() {
        return lineType;
    }

    public void setLineType(int type) {
        lineType = type;
    }

    public int getLineArrow() {
        return lineArrow;
    }

    public void setLineArrow(int arrow) {
        lineArrow = arrow;
    }
}

	public connSymbol symIDAsInt(int i) {
		for (connSymbol s : connSymbol.values()) {
			if (s.symID() == i) {return s;}
		}
		
		return connSymbol.NONE;
	}
	public enum connSymbol {NONE(0);
		private final int symID;
		connSymbol(int i) {
			this.symID = i;
		}
		public int symID() {return symID;}
	};
	public enum connEdge {NONE(0),TOP(1),RIGHT(2),BOTTOM(3),LEFT(4);
		private final int edgeID;
		connEdge(int i) {
			this.edgeID = i;
		}
		public int edgeID() {return edgeID;}
	};
	public class drawingItemConnector {
		private JConnector connector;
		private String	connectorTextStart;
		private String	connectorTextEnd;
		private	String	connectorID;
		private connSymbol connectorStartSymbol;
		private connSymbol connectorEndSymbol;
		private	int		connectorLayer;
	
		public drawingItemConnector(drawingItem start,drawingItem end,String textStart,String textEnd,int symStart,int symEnd,String id,int layer) {
			connector = new JConnector(start,end);
			connectorTextStart = textStart;
			connectorTextEnd = textEnd;
			connectorID = id;
			connectorStartSymbol = symIDAsInt(symStart);
			connectorEndSymbol = symIDAsInt(symEnd);
			connectorLayer = layer;
		}
		public drawingItemConnector(drawingItem start,drawingItem end,String textStart,String textEnd,String id) {
			connector = new JConnector(start,end);
			connectorTextStart = textStart;
			connectorTextEnd = textEnd;
			connectorID = id;
			connectorStartSymbol = connSymbol.NONE;
			connectorEndSymbol = connSymbol.NONE;
		}
		public connEdge getConnEdge(drawingItem d,Point ptConn) {
			int margin = 10;
			Rectangle r = d.getTransformBoundingBox();
			float cx = (float)r.getWidth() / (float)2.00;
			float cy = (float)r.getHeight() / (float)2.00;
			
			Rectangle r1 = new Rectangle((int)r.getX()+(int)cx,(int)r.getY(),2*margin,2*margin);
			r1.translate(-margin,-margin);
			if (r1.contains(ptConn.x,ptConn.y)) {return connEdge.TOP;}
			r1 = new Rectangle((int)r.getX()+(int)r.getWidth(),(int)r.getY()+(int)cy,2*margin,2*margin);
			r1.translate(-margin,-margin);
			if (r1.contains(ptConn.x,ptConn.y)) {return connEdge.RIGHT;}
			r1 = new Rectangle((int)r.getX()+(int)cx,(int)r.getY()+(int)r.getHeight(),2*margin,2*margin);
			r1.translate(-margin,-margin);
			if (r1.contains(ptConn.x,ptConn.y)) {return connEdge.BOTTOM;}
			r1 = new Rectangle((int)r.getX(),(int)r.getY()+(int)cy,2*margin,2*margin);
			r1.translate(-margin,-margin);
			if (r1.contains(ptConn.x,ptConn.y)) {return connEdge.LEFT;}
			
			return connEdge.NONE;
		}
		public Point getTextStartPoint(String text,drawingItem d,Point ptConn) {
			int margin = 10;
			int textX = ptConn.x;
			int textY = ptConn.y;
			int stringWidth =  text.length() * charWidth;
			
			connEdge edge = getConnEdge(d,ptConn);
			if (edge == connEdge.TOP) {textX = textX + margin;textY = textY - margin;}
			if (edge == connEdge.RIGHT) {textX = textX + margin;textY = textY - margin;}
			if (edge == connEdge.BOTTOM) {textX = textX + margin;textY = textY + margin;}
			if (edge == connEdge.LEFT) {textX = textX - margin - stringWidth;textY = textY - margin;}
			
			return new Point(textX,textY);
		}
		public String getID() {return connectorID;}
		public void setID(String s) {connectorID = s;}
		public drawingItem getStart() {return connector.getSource();}
		public drawingItem getEnd() {return connector.getDest();}
		public boolean hitTest(int x,int y) {
			GeneralPath p = connector.getConnectorPath();
			Graphics2D g2d = (Graphics2D)getGraphics();
			Rectangle r = new Rectangle(x-2,y-2,4,4);
			return g2d.hit(r,p,true);
		}
		public void drawConnector(Graphics2D g2d) {
			connector.drawConnector(g2d);
			Point pt1 = connector.getP1();
			Point pt2 = connector.getP2();
			Point start = getTextStartPoint(getTextStart(),getStart(),connector.getP1());
			Point end = getTextStartPoint(getTextEnd(),getEnd(),connector.getP2());
			g2d.drawString(getTextStart(),start.x,start.y);
			g2d.drawString(getTextEnd(),end.x,end.y);
			
			int sourceEdgeId = getConnEdge(getStart(),connector.getP1()).edgeID();
			int destEdgeId = getConnEdge(getEnd(),connector.getP2()).edgeID();
			drawConnSymbol(g2d,connectorStartSymbol,(int)((sourceEdgeId-1) * Math.PI));
			drawConnSymbol(g2d,connectorEndSymbol,(int)((destEdgeId-1) * Math.PI));
		}
		public int getLayer() {return connectorLayer;}
		public void setTextStart(String s) {connectorTextStart = s;}
		public String getTextStart() {return connectorTextStart;}
		public void setTextEnd(String s) {connectorTextEnd = s;}
		public String getTextEnd() {return connectorTextEnd;}
		public int getSymStart() {return connectorStartSymbol.symID();}
		public int getSymEnd() {return connectorEndSymbol.symID();}
		public connSymbol getStartSymbol() {return connectorStartSymbol;}
		public connSymbol getEndSymbol() {return connectorEndSymbol;}
		public void setStartSymbol(connSymbol ci) {connectorStartSymbol = ci;}
		public void setEndSymbol(connSymbol ci) {connectorEndSymbol = ci;}
		void drawConnSymbol(Graphics2D g2d,connSymbol connSym,int rotate) {
			if (connSym == connSymbol.NONE) {return;}
		}
	}

//	public final static class xmlSupport {
		public NodeList executeXPathExpr(org.w3c.dom.Document xmlDocument,String xPathExpr) {
			try {
				XPath xPath =  XPathFactory.newInstance().newXPath();
				return (NodeList) xPath.compile(xPathExpr).evaluate(xmlDocument, XPathConstants.NODESET);
			} catch (Exception e) {return (NodeList)null;}
		}
	/*
		public String executeXQuery(String xqueryfilename) {
			String retData = "";
			
			try {
			      InputStream inputStream = new FileInputStream(new File(xqueryfilename));
			      XQDataSource ds = new SaxonXQDataSource();
			      XQConnection conn = ds.getConnection();
			      XQPreparedExpression exp = conn.prepareExpression(inputStream);
			      XQResultSequence result = exp.executeQuery();
			      
			      while (result.next()) {
			         //System.out.println(result.getItemAsString(null));
			    	  retData = retData + result.getItemAsString(null) + "/n";
			      }
			   } catch (Exception e) {
				   return "";
			   }
			
			return retData;
		}	
		*/
//	}

	public abstract class drawingItem extends Component {
		  protected	int	diOriginX,diOriginY;
		  protected	String	diParam1,diParam2,diParam3,diParam4,diUnique;
		  protected	Color	diColor;
		  protected	boolean	diFilled,diCanTransform;
		  protected	String	diID;
		  protected	Vector  diFocusHandles = new Vector();
		  protected	int	diOffsetX,diOffsetY;
		  protected String  diGroupID;
		  protected	int	diStrokeWidth;
		  protected int diType;
		  protected	int	diLayer;
		  protected	int	diRotAngle;
		  protected	Rectangle rcTransformBoundingBox;
 		  protected	Rectangle rcLastPos;
		  protected	String userDefinedName = "";
		  protected 	int			iSheet;

		  public boolean canDelete() {return true;}
		  public void delete() {;}
		  public void editor() {;}
		  public int getSheet() {return iSheet;}
		  public void setSheet(int i) {iSheet = i;}
		  public void setUserDefinedName(String s) {userDefinedName = s;}
		  public String getUserDefinedName() {return userDefinedName;}
		  public drawingItem() {}
		  public drawingItem(int type,String id,int orgX,int orgY,String p1,String p2,String p3,String p4,boolean fill,Color c) {
			  diOriginX = orgX;
			  diOriginY = orgY;
			  diParam1 = p1;
			  diParam2 = p2;
			  diParam3 = p3;
			  diParam4 = p4;
			  diFilled = fill;
			  diColor = c;
			  diID = id;
			  diOffsetX = 0;
			  diOffsetY = 0;
			  diUnique = "";
			  diGroupID = "";
			  diStrokeWidth = 1;
			  diType = type;
			  diLayer = 1;
			  diRotAngle = 0;
			  diCanTransform = true;
			  rcTransformBoundingBox = new Rectangle(0,0,0,0);
			  rcLastPos = new Rectangle(0,0,0,0);
			  iSheet = 1;
		  }
		  
		  public String getParams(String entity) {
			return entity + "," + String.valueOf(getType()) + "," + String.valueOf(getOriginX()) + "," + String.valueOf(getOriginY()) + "," + getParam1() + "," + getParam2() + "," + getParam3() + "," + getParam4() + "," + valueOf(getFilled()) + "," + getColorName(getColor());
		  }
		  public Rectangle getTransformBoundingBox() {return rcTransformBoundingBox;}
		  public void setTransformBoundingBox(Rectangle bounding) {
			Rectangle rc = getBoundingRect(); // bounding rectangle at an angle of 0 degrees rotation
			Point pt = centerPoint(rc);
			// rotate rc by diRotAngle degrees around the center point
			AffineTransform rotation = AffineTransform.getRotateInstance(Math.toRadians(diRotAngle),pt.x,pt.y);
			Shape s = rotation.createTransformedShape((Shape)rc);
			// check that the rotated drawing item fits in the supplied bounding rect, if not leave 
			// the transform rectangle unchanged
			if (rectContainsRect(bounding,(Rectangle)s.getBounds())) {
				rcTransformBoundingBox = s.getBounds();
			} else {
				rcTransformBoundingBox = getBoundingRect();
			}
		  }
		  public boolean getCanTransform() {return diCanTransform;}
		  public void setCanTransform(boolean b) {diCanTransform = b;}
		  public int getLayer() {return diLayer;}
		  public void setLayer(int i) {diLayer = i;}
		  public int getRotAngle() {return diRotAngle;}
		  public void setRotAngle(int i) {diRotAngle = i;}
		  public int getType() {return diType;}
		  public void setType(int i) {diType = i;}
		  public int getStrokeWidth() {return diStrokeWidth;}
		  public void setStrokeWidth(int i) {diStrokeWidth = i;}
		  public String getGroupID() {return diGroupID;}
		  public void setGroupID(String s) {diGroupID = s;}
		  public void setOffsetX(int i) {diOffsetX = i;}
		  public int getOffsetX() {return diOffsetX;}
		  public void setOffsetY(int i) {diOffsetY = i;}
		  public int getOffsetY() {return diOffsetY;}
		  public void setColor(Color c) {diColor = c;}
		  public Color getColor() {return diColor;}
		  public void setOrigin(Point p) {diOriginX = p.x;diOriginY = p.y;}
		  public Point getOrigin() {return new Point(diOriginX,diOriginY);}
		  public void setFilled(boolean b) {diFilled = b;}
		  public boolean getFilled() {return diFilled;}
		  public void setParam1(String s) {diParam1 = s;}
		  public String getParam1() {return diParam1;}
		  public void setParam2(String s) {diParam2 = s;}
		  public String getParam2() {return diParam2;}
		  public void setParam3(String s) {diParam3 = s;}
		  public String getParam3() {return diParam3;}
		  public void setParam4(String s) {diParam4 = s;}
		  public String getParam4() {return diParam4;}
		  public String getUnique() {return diUnique;}
		  public void setUnique(String s) {diUnique = s;}
		  public void setID(String s) {diID = s;}
		  public String getID() {return diID;}
		  public void paint() {paint((Graphics2D)getGraphics(),false);}
		  public void paint(Graphics2D g2d) {paint(g2d,false);}
		  public void paint(Graphics2D g2d,boolean focus) {}
		  public void teardownPaint(Graphics2D g2d,boolean focus) {
			  if (focus) {drawFocusHandles(g2d);}
		  }
		  public Point centerPoint(Rectangle r) {
			float cx = (float)r.getWidth() / (float)2.00;
			float cy = (float)r.getHeight() / (float)2.00;
			cx = cx + (float)r.getX();
			cy = cy + (float)r.getY();
			return new Point((int)cx,(int)cy);
		  }
		  public void setupPaint(Graphics2D g2d,boolean focus) {
			  g2d.setColor(diColor);
			  g2d.setStroke(new BasicStroke(diStrokeWidth));
			  Point pt = centerPoint(getTransformBoundingBox());
			  AffineTransform rotation = AffineTransform.getRotateInstance(Math.toRadians(diRotAngle),pt.x,pt.y);
			  g2d.setTransform(rotation);
		  }
		public boolean hitTest(int x,int y) {
			  Rectangle r = getTransformBoundingBox();
			  return r.contains(x,y);
		}
		  public Rectangle getBoundingRect() {return new Rectangle(0,0,0,0);}
		  public String getCompositeID() {return "";}
		  public int hitTestFocusHandles(int x,int y) {
			  for (int i=0;i<diFocusHandles.size();i++) {
				  Rectangle r = (Rectangle)diFocusHandles.elementAt(i);
				  if (r.contains(x,y)) {return i;}
			  }
			  return -1;
		  }
		  public void drawFocusHandles(Graphics2D g2d) {
			  calcFocusHandles();
  			  g2d.setColor(Color.black);
			  for (int i=0;i<diFocusHandles.size();i++) {
				  Rectangle r = (Rectangle)diFocusHandles.elementAt(i);
				  if (!r.isEmpty()) {g2d.fillRect((int)r.getX(),(int)r.getY(),(int)r.getWidth(),(int)r.getHeight());}
			  }
		  }
		  public void calcFocusHandles() {
			  int focusHandleSize = 10;
			  
			  diFocusHandles.removeAllElements();
			  Rectangle r = getTransformBoundingBox();
			  diFocusHandles.addElement(new Rectangle((int)r.getX(),(int)r.getY(),focusHandleSize,focusHandleSize));
			  diFocusHandles.addElement(new Rectangle((int)r.getX()+(int)r.getWidth()-focusHandleSize,(int)r.getY(),focusHandleSize,focusHandleSize));
			  diFocusHandles.addElement(new Rectangle((int)r.getX(),(int)r.getY()+(int)r.getHeight()-focusHandleSize,focusHandleSize,focusHandleSize));
			  diFocusHandles.addElement(new Rectangle((int)r.getX()+(int)r.getWidth()-focusHandleSize,(int)r.getY()+(int)r.getHeight()-focusHandleSize,focusHandleSize,focusHandleSize));
			  
			  int halfWidth = (int)r.getWidth() / 2;
			  int halfHeight = (int)r.getHeight() / 2;
			  
			  if (r.getWidth() > 10*focusHandleSize) {
				  diFocusHandles.addElement(new Rectangle((int)r.getX()+halfWidth,(int)r.getY(),focusHandleSize,focusHandleSize));
				  diFocusHandles.addElement(new Rectangle((int)r.getX()+halfWidth,(int)r.getY()+(int)r.getHeight()-focusHandleSize,focusHandleSize,focusHandleSize));
			  } else {
				  diFocusHandles.addElement(new Rectangle(0,0,0,0));
				  diFocusHandles.addElement(new Rectangle(0,0,0,0));
			  }
			  if (r.getHeight() > 10*focusHandleSize) {
				  diFocusHandles.addElement(new Rectangle((int)r.getX(),(int)r.getY()+halfHeight,focusHandleSize,focusHandleSize));
				  diFocusHandles.addElement(new Rectangle((int)r.getX()+(int)r.getWidth()-focusHandleSize,(int)r.getY()+halfHeight,focusHandleSize,focusHandleSize));
			  } else {
				  diFocusHandles.addElement(new Rectangle(0,0,0,0));
				  diFocusHandles.addElement(new Rectangle(0,0,0,0));
			  }
			  // calculate centre rotation focus handle
			  if (getCanTransform()) {
				Point pt = centerPoint(getTransformBoundingBox());
				diFocusHandles.addElement(new Rectangle(pt.x,pt.y,focusHandleSize,focusHandleSize));
			  }
		  }
		  public void fitToRectangle(Rectangle r) {;}
		  public void showPropsDialog(String entity) {
		  	drawingItemPropsDialog d = new drawingItemPropsDialog(getTopLevelParent(this),this);
			if (d.isOK()) {
				setColor(d.getColor());
				systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIColor='"+getColorName(d.getColor())+"' WHERE sdcDIEntity='"+entity+"' AND sdcDIName='"+getID()+"'","");
				setStrokeWidth(d.getStrokeWidth());
				systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIStrokeWidth="+String.valueOf(d.getStrokeWidth())+" WHERE sdcDIEntity='"+entity+"' AND sdcDIName='"+getID()+"'","");
			} 
			d.dispose();
		  }
		  public int getOriginX() {return diOriginX;}
		  public int getOriginY() {return diOriginY;}
		  public void getDrawingItemAsXML(org.w3c.dom.Document doc,org.w3c.dom.Element root) {
			org.w3c.dom.Element setting = doc.createElement("drawingitem");
			setting.setAttribute("layer",String.valueOf(getLayer()));
			setting.setAttribute("rotangle",String.valueOf(getRotAngle()));
			setting.setAttribute("type",String.valueOf(getType()));
			setting.setAttribute("name",getID());
			setting.setAttribute("originx",String.valueOf(getOriginX()));
			setting.setAttribute("originy",String.valueOf(getOriginY()));
			setting.setAttribute("color",getColorName(getColor()));
			setting.setAttribute("fill",valueOf(getFilled()));
			setting.setAttribute("param1",getParam1());
			setting.setAttribute("param2",getParam2());
			setting.setAttribute("param3",getParam3());
			setting.setAttribute("param4",getParam4());
			setting.setAttribute("unique",getUnique());
			setting.setAttribute("width",String.valueOf(getStrokeWidth()));
			root.appendChild(setting);
		  }
	}

	public class lineDrawingItem extends drawingItem {
		public lineDrawingItem() {} 
		public lineDrawingItem(String id,int orgX,int orgY,String p1,String p2,boolean fill,Color c) {
			super(dcTypeLine,id,orgX,orgY,p1,p2,"","",fill,c);
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
			g2d.drawLine(dcLastX,dcLastY,xCord,yCord);
		}
		public void paint(Graphics2D g2d,boolean focus) {
			  setupPaint(g2d,focus);
			  g2d.drawLine(diOriginX,diOriginY,Integer.parseInt(diParam1),Integer.parseInt(diParam2));
			  teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			setOrigin(new Point((int)r.getX(),(int)r.getY()));
			diParam1 = String.valueOf((int)r.getWidth()+(int)r.getX());
			diParam2 = String.valueOf((int)r.getHeight()+(int)r.getY());
		}
		public Rectangle getBoundingRect() {
			  int x1 = diOriginX,y1 = diOriginY;
			  int x2 = Integer.parseInt(diParam1),y2 = Integer.parseInt(diParam2);
			  if (Integer.parseInt(diParam1) < diOriginX) {x1 = Integer.parseInt(diParam1);x2=diOriginX;} else {x1 = diOriginX;}
	    	  	  if (Integer.parseInt(diParam2) < diOriginY) {y1 = Integer.parseInt(diParam2);y2=diOriginY;} else {y1 = diOriginY;}
			  int width = Math.abs(x1 - x2);
			  int height = Math.abs(y1 - y2);
			  return new Rectangle(x1,y1,width,height);
		}
	}

	public class imageDrawingItem extends drawingItem {
		 protected	Image	i = null;

		 public imageDrawingItem() {}
		 public imageDrawingItem(String id,int orgX,int orgY,String p1,String p2,boolean fill,Color c) {
			super(dcTypeImage,id,orgX,orgY,p1,p2,"","",fill,c);
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
		}
		  public void paint(Graphics2D g2d,boolean focus) {
			  setupPaint(g2d,focus);
			  if (i == null) {
				  Toolkit toolkit = Toolkit.getDefaultToolkit();
				  MediaTracker	mt = new MediaTracker(this);
				  i = toolkit.getImage(getParam1());
				  mt.addImage(i,1);
				  try {
					  mt.waitForID(1);
			   	  } catch(Exception e) {e.printStackTrace();}
					if (mt.isErrorAny()) {
						TRACE("Error in loading image " + getParam1(),4);
					}
			  }
			  Vector v = supportFunctions.splitIntoTokens(getParam2(),",");
			  int width = Integer.parseInt((String)v.elementAt(0));
			  int height = Integer.parseInt((String)v.elementAt(1));
			  g2d.drawImage(i,diOriginX,diOriginY,width,height,null);
			  teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			setOrigin(new Point((int)r.getX(),(int)r.getY()));
			setParam2(String.valueOf((int)r.getWidth()) + "," + String.valueOf((int)r.getHeight()));
		}
		public Rectangle getBoundingRect() {
			  int x1 = diOriginX,y1 = diOriginY;
			  Vector v = supportFunctions.splitIntoTokens(getParam2(),",");
			  int width = Integer.parseInt((String)v.elementAt(0));
			  int height = Integer.parseInt((String)v.elementAt(1));
			  return new Rectangle(x1,y1,width,height);
		}
	}

	public class textDrawingItem extends drawingItem {
		public textDrawingItem() {}
		public textDrawingItem(String id,int orgX,int orgY,String p1,String p2,boolean fill,Color c) {
			super(dcTypeText,id,orgX,orgY,p1,p2,"","",fill,c);
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
		}
		  public void paint(Graphics2D g2d,boolean focus) {
			setupPaint(g2d,focus);

			// set font size to fit in width pixels
			Vector v = supportFunctions.splitIntoTokens(getParam2(),",");
			int width = Integer.parseInt((String)v.elementAt(0));
			int height = Integer.parseInt((String)v.elementAt(1));
			
			float fontSize = 1;
			int w = 0;
			do {
				Font newFont = g2d.getFont().deriveFont(fontSize++);
				g2d.setFont(newFont);
				FontMetrics fm = getFontMetrics(g2d.getFont());
				w = fm.stringWidth(diParam1 + "OO");
			}
			while(w < width);
			
			// g2d already has the font of the correct size selected into it
			g2d.drawString(diParam1,diOriginX,diOriginY);
			teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			setOrigin(new Point((int)r.getX(),(int)r.getY()));
			setParam2(String.valueOf((int)r.getWidth()) + "," + String.valueOf((int)r.getHeight()));
		}
		public Rectangle getBoundingRect() {
			  int x1 = diOriginX,y1 = diOriginY;
			  Vector v = supportFunctions.splitIntoTokens(getParam2(),",");
			  int width = Integer.parseInt((String)v.elementAt(0));
			  int height = Integer.parseInt((String)v.elementAt(1));
			  return new Rectangle(x1,y1,width,height);
		}
	}

	public class elispeDrawingItem extends drawingItem {
		public elispeDrawingItem() {}
		public elispeDrawingItem(String id,int orgX,int orgY,String p1,String p2,boolean fill,Color c) {
			super(dcTypeElispe,id,orgX,orgY,p1,p2,"","",fill,c);
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
					  	if (dcFilled) {
							g2d.fillOval(dcLastX,dcLastY,Math.abs(dcLastX-xCord),Math.abs(dcLastY-yCord));
						} else {
							g2d.drawOval(dcLastX,dcLastY,Math.abs(dcLastX-xCord),Math.abs(dcLastY-yCord));
						}
		}
		  public void paint(Graphics2D g2d,boolean focus) {
			  setupPaint(g2d,focus);
			  if (diFilled) {
				  g2d.fillOval(diOriginX,diOriginY,Math.abs(diOriginX-Integer.parseInt(diParam1)),Math.abs(diOriginY-Integer.parseInt(diParam2)));
			  } else {
				  g2d.drawOval(diOriginX,diOriginY,Math.abs(diOriginX-Integer.parseInt(diParam1)),Math.abs(diOriginY-Integer.parseInt(diParam2)));
			  }
			  teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			setOrigin(new Point((int)r.getX(),(int)r.getY()));
			diParam1 = String.valueOf((int)r.getWidth()+(int)r.getX());
			diParam2 = String.valueOf((int)r.getHeight()+(int)r.getY());
		}
		public Rectangle getBoundingRect() {
			  int x1 = diOriginX,y1 = diOriginY;
			  int x2 = Integer.parseInt(diParam1),y2 = Integer.parseInt(diParam2);
			  int width = Math.abs(diOriginX-Integer.parseInt(diParam1));
			  int height = Math.abs(diOriginY-Integer.parseInt(diParam2));
			  return new Rectangle(x1,y1,width,height);
		}
	}

	public class textboxDrawingItem extends drawingItem {
		public textboxDrawingItem() {}
		public textboxDrawingItem(String id,int orgX,int orgY,String p1,String p2,boolean fill,Color c) {
			super(dcTypeTextBox,id,orgX,orgY,p1,p2,"","",fill,c);
		}
		  public void paint(Graphics2D g2d,boolean focus) {
			  setupPaint(g2d,focus);
			  if (diFilled) {
				  g2d.fillRect(diOriginX,diOriginY,Math.abs(diOriginX-Integer.parseInt(diParam1)),Math.abs(diOriginY-Integer.parseInt(diParam2)));
			  } else {
				  g2d.drawRect(diOriginX,diOriginY,Math.abs(diOriginX-Integer.parseInt(diParam1)),Math.abs(diOriginY-Integer.parseInt(diParam2)));				  
			  }
			  textBlock t = new textBlock(diParam1);
			  t.drawText(g2d,diOriginX+3,diOriginY+3);
			  teardownPaint(g2d,focus);
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
		}
		public void fitToRectangle(Rectangle r) {
			setOrigin(new Point((int)r.getX(),(int)r.getY()));
			diParam1 = String.valueOf((int)r.getWidth()+(int)r.getX());
			diParam2 = String.valueOf((int)r.getHeight()+(int)r.getY());
		}
		public Rectangle getBoundingRect() {
			  int x1 = diOriginX,y1 = diOriginY;
			  int x2 = Integer.parseInt(diParam1),y2 = Integer.parseInt(diParam2);
			  int width = Math.abs(diOriginX-Integer.parseInt(diParam1));
			  int height = Math.abs(diOriginY-Integer.parseInt(diParam2));
			  return new Rectangle(x1,y1,width,height);
		}
	}

	public class switchGCSheetDrawingItem extends drawingItem {
		private	String		newGCSheetName = "";
		private Rectangle	boundingRect;
		private int			size = charHeight + 2 + 2;
		
		public void setNewGCSheetName(String name) {newGCSheetName = name;}
		public String getNewGCSheetName() {return newGCSheetName;}
		public switchGCSheetDrawingItem() {}
		public switchGCSheetDrawingItem(String id,int orgX,int orgY,String p1,String p2,String p3,String p4,boolean fill,Color c) {
			super(dcTypeSwitchGCSheet,id,orgX,orgY,p1,p2,p3,p4,fill,c);
			
			setNewGCSheetName(p1);
			boundingRect = new Rectangle(orgX,orgY,size,size);
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
			// do nothing here if drawing item is of a fixed size
		}
		public void paint(Graphics2D g2d,boolean focus) {
			  setupPaint(g2d,focus);
			  g2d.drawRect(diOriginX,diOriginY,size,size); 
			  g2d.drawString("G",diOriginX,diOriginY);
			  teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			// do nothing here if drawing item is of a fixed size
		}
		public Rectangle getBoundingRect() {
			  return boundingRect;
		}
	}
	public class rectDrawingItem extends drawingItem {
		public rectDrawingItem() {}
		public rectDrawingItem(String id,int orgX,int orgY,String p1,String p2,boolean fill,Color c) {
			super(dcTypeRect,id,orgX,orgY,p1,p2,"","",fill,c);
		}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
						if (dcFilled) {
							g2d.fillRect(dcLastX,dcLastY,Math.abs(dcLastX-xCord),Math.abs(dcLastY-yCord));
						} else {
							g2d.drawRect(dcLastX,dcLastY,Math.abs(dcLastX-xCord),Math.abs(dcLastY-yCord));
						}
		}
		public void paint(Graphics2D g2d,boolean focus) {
			  setupPaint(g2d,focus);
			  if (diFilled) {
				  g2d.fillRect(diOriginX,diOriginY,Math.abs(diOriginX-Integer.parseInt(diParam1)),Math.abs(diOriginY-Integer.parseInt(diParam2)));
			  } else {
				  g2d.drawRect(diOriginX,diOriginY,Math.abs(diOriginX-Integer.parseInt(diParam1)),Math.abs(diOriginY-Integer.parseInt(diParam2)));				  
			  }
			  teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			setOrigin(new Point((int)r.getX(),(int)r.getY()));
			diParam1 = String.valueOf((int)r.getWidth()+(int)r.getX());
			diParam2 = String.valueOf((int)r.getHeight()+(int)r.getY());
		}
		public Rectangle getBoundingRect() {
			  int x1 = diOriginX,y1 = diOriginY;
			  int x2 = Integer.parseInt(diParam1),y2 = Integer.parseInt(diParam2);
			  int width = Math.abs(diOriginX-Integer.parseInt(diParam1));
			  int height = Math.abs(diOriginY-Integer.parseInt(diParam2));
			  return new Rectangle(x1,y1,width,height);
		}
	}
	

	public class multiPagePrintableCanvas extends printableCanvas implements Printable,Pageable {
		// developed from code in JAVA Examples page 330
		PageFormat 	format;
		int 		numPages;
		double 		scaleFactor;
		double 		printX,printY;
		double 		printHeight,printWidth;
		double		documentHeight;
		Rectangle 	drawRect;
		ArrayList 	pageLengths = new ArrayList(); // for a document of n pages, stores lengths of pages 0 to n-2, last page assumed to have a full length
		ArrayList 	pageOffsets = new ArrayList(); // for a document of n pages, stores the starting offset of pages 1 to n-1, offset of page 0 is always 0
		
		public multiPagePrintableCanvas() {
			scaleFactor = 0.75; // as the default fonts are overly large
			format = new PageFormat();
			printX = format.getImageableX()/scaleFactor;
			printY = format.getImageableY()/scaleFactor;
			printWidth = format.getImageableWidth()/scaleFactor;
			printHeight = format.getImageableHeight()/scaleFactor;
			documentHeight = calcDocumentHeight();
			drawRect = new Rectangle(0,0,(int)printWidth,(int)documentHeight);
			if (documentHeight > printHeight) {paginate(drawRect);}
			numPages = pageLengths.size() + 1;			
		}
		public void paint(Graphics2D g2d) { // need to override this function
		}
		public double getDocumentHeight() {return documentHeight;}
		public double calcDocumentHeight() { // need to override this function
			return 0;
		}
		public void paginate(Rectangle2D allocation) { // need to override this function
			// this function fills in the pageLengths and pageOffsets ArrayLists
		}
		public Printable getPrintable(int pageNum) {return this;}
		public int getNumberOfPages() {return numPages;}
		public PageFormat getPageFormat(int pageNum) {
			if (pageNum == numPages-1) {return format;}
			double pageLength = ((java.lang.Double)pageLengths.get(pageNum)).doubleValue();
			PageFormat f = (PageFormat)format.clone();
			Paper p = f.getPaper();
			if (f.getOrientation() == PageFormat.PORTRAIT) {
				p.setImageableArea(printX*scaleFactor,printY*scaleFactor,printWidth*scaleFactor,printHeight*scaleFactor);
			} else {
				p.setImageableArea(printY*scaleFactor,printX*scaleFactor,printHeight*scaleFactor,printWidth*scaleFactor);
			}
			f.setPaper(p);
			return f;
		}
		public Graphics2D printPageSetup(Graphics g,int pageNum) {
			Graphics2D g2d = (Graphics2D)g;
			// translate to accomadate the top and left margins
			g2d.translate(format.getImageableX(),format.getImageableY());
			// scale page by specified factor
			g2d.scale(scaleFactor,scaleFactor);
			// display page number centered in the area of the top margin
			// set a new clpping region so we can draw in the top margin
			// but remember old one so we can restore it
			if (pageNum > 0) {
				Font headerFont = new Font("Serif",Font.PLAIN,12);
				Shape orgClip = g.getClip();
				g.setClip(new Rectangle(0,(int)-printY,(int)printWidth,(int)printY));
				String s = "- " + (pageNum+1) + " -";
				FontRenderContext frc = g2d.getFontRenderContext();
				Rectangle2D r = headerFont.getStringBounds(s,frc);
				LineMetrics metrics = headerFont.getLineMetrics(s,frc);
				g.setFont(headerFont);
				g.setColor(Color.black);
				g.drawString(s,(int)((printWidth-r.getWidth())/2),(int)(-(printY-r.getHeight())/2 + metrics.getAscent()));
				g.setClip(orgClip);
			}
			double pageStart = 0.0, pageLength = printHeight;
			if (pageNum > 0) {pageStart = ((java.lang.Double)pageOffsets.get(pageNum-1)).doubleValue();}
			if (pageNum < numPages-1) {pageLength = ((java.lang.Double)pageLengths.get(pageNum)).doubleValue();}
			// scroll so that apporiate part of document is lined up
			// with the upper-left corner of the page
			g2d.translate(0.0,-pageStart);
			
			return g2d;
		}
		// PrinterJob calls the print method to render the graphics
		// object, starting at pageIndex of 0
		// return PAGE_EXISTS if you have printed that page
		// return NO_SUCH_PAGE if there are no more pages left
	    public int print(Graphics g,PageFormat format,int pagenum) {
		   if (pagenum >= numPages) {return Printable.NO_SUCH_PAGE;}
		   Graphics2D g2d = printPageSetup(g,pagenum);
		   paint(g2d);
		   return Printable.PAGE_EXISTS;
	    }
	}

	public boolean rectContainsRect(Rectangle r1,Rectangle r2) {
		if (!r1.contains(new Point(r2.x,r2.y))) {return false;}
		if (!r1.contains(new Point(r2.x + r2.width,r2.y))) {return false;}
		if (!r1.contains(new Point(r2.x + r2.width,r2.y + r2.height))) {return false;}
		if (!r1.contains(new Point(r2.x,r2.y + r2.height))) {return false;}
	
		return true;
	}
	public interface drawingCanvasUtils {
		public void rightClickAction(Vector v,MouseEvent evt);
		public void leftClickAction(drawingItem d,MouseEvent evt);
		public void leftClickSelectedAction(Vector v,MouseEvent evt);
		public void doubleClickAction(drawingItem d,MouseEvent evt);
		public void hoverAction(drawingItem d,MouseEvent evt);
		public void customDoCommand(String cmd,String params,drawingItem d);
		public boolean canvasDoubleClickAction(MouseEvent evt);
		public boolean canvasLeftClickAction(MouseEvent evt);
	}
	public class RowEditorModel
	 {
	      private Hashtable data;
	      public RowEditorModel()
	      {
	          data = new Hashtable();
	      }
	     public void addEditorForRow(int row, TableCellEditor e )
	     {
	         data.put(new Integer(row), e);
	     }
	     public void removeEditorForRow(int row)
	     {
	         data.remove(new Integer(row));
	     }
	     public TableCellEditor getEditor(int row)
	     {
	         return (TableCellEditor)data.get(new Integer(row));
	     }
	 }
	public class JTableX extends JTable
	 {
	     protected RowEditorModel rm;
	
	     public JTableX()
	     {
	         super();
	         rm = null;
	     }
	     public JTableX(TableModel tm)
	     {
	         super(tm);
	         rm = null;
	     }
	
	     public JTableX(TableModel tm, TableColumnModel cm)
	     {
	         super(tm,cm);
	         rm = null;
	     }
	
	     public JTableX(TableModel tm, TableColumnModel cm,
	      ListSelectionModel sm)
	     {
	         super(tm,cm,sm);
	         rm = null;
	     }
	
	     public JTableX(int rows, int cols)
	     {
	         super(rows,cols);
	         rm = null;
	     }
	
	     public JTableX(final Vector rowData, final Vector columnNames)
	     {
	         super(rowData, columnNames);
	         rm = null;
	     }
	
	     public JTableX(final Object[][] rowData, final Object[] colNames)
	     {
	         super(rowData, colNames);
	         rm = null;
	     }
	
	     // new constructor
	     public JTableX(TableModel tm, RowEditorModel rm)
	     {
	         super(tm,null,null);
	         this.rm = rm;
	     }
	
	     public void setRowEditorModel(RowEditorModel rm)
	     {
	         this.rm = rm;
	     }
	
	     public RowEditorModel getRowEditorModel()
	     {
	         return rm;
	     }
	
	     public TableCellEditor getCellEditor(int row, int col)
	     {
	         TableCellEditor tmpEditor = null;
	         if (rm!=null)
	             tmpEditor = rm.getEditor(row);
	         if (tmpEditor!=null)
	             return tmpEditor;
	         return super.getCellEditor(row,col);
	     }
	 }
	public interface propBoxDialogListener {
		public void propChanged(String title,statusCanvasProp tmp,String newValue);		
	}
	public class propBoxDialog extends JDialog implements TableModelListener {
		private JButton	OKBut,CANCELBut;
		private JTableX statusTable;
		private statusCanvasTableModel statusTableM;
		private String[] colNames = {"Name","Value"};
		private Vector	props = new Vector();
		private	boolean bOK = false;
		private	String id;
		private String title;
		private propBoxDialogListener target = null;

		public void addPropBoxDialogListener(propBoxDialogListener pbdl) {target = pbdl;}
		public void removePropBoxDialogListener() {target = null;}
		public void saveAsXML(String name) {
			configurationSettings settings = new configurationSettings();
			settings.openConfigurationSettings(""+dataRelativePath+"/"+appDirectory+"/"+name+"_"+id);
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				settings.setConfigurationSetting(tmp.getName(),tmp.getValue());
			}
			settings.closeConfigurationSettings();
		}
		public void loadAsXML(String name) {
			configurationSettings settings = new configurationSettings();
			settings.openConfigurationSettings(""+dataRelativePath+"/"+appDirectory+"/"+name+"_"+id);
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				tmp.setValue(settings.getConfigurationSetting(tmp.getName(),""));
			}
			settings.closeConfigurationSettings();
		}
		public void createComboBoxRender(String[] options,int rowNumber) {
			JComboBox cb = new JComboBox();
			//TableColumn tc = statusTable.getColumnModel().getColumn(colNumber);
			
			for (int i=0;i<options.length;i++) {
				cb.addItem(options[i]);
			}
			//tc.setCellEditor(new DefaultCellEditor(cb));
			statusTable.getRowEditorModel().addEditorForRow(rowNumber,new DefaultCellEditor(cb));
		}
		public JTable getStatusTable() {return statusTable;}
		public boolean isOK() {return bOK;}
		public Vector getProps() {return props;}
		public void tableChanged(TableModelEvent evt) {
			int row = evt.getFirstRow();
			int column = evt.getColumn();
			TableModel model = (TableModel)evt.getSource();
			if (row == -1 || column == -1) {return;}
			//TRACE("tableChanged: row="+String.valueOf(row)+", column="+String.valueOf(column),4);
			// get and set table data using getValueAt(row,column) and setValueAt(row,column)
			// we need to cast them to the apporiate data types as stored as type Object
			statusCanvasProp tmp = (statusCanvasProp)props.elementAt(row);
			Object o =  statusTable.getValueAt(row,column);
			tmp.setValue((String)o);
			if (target != null) {
				target.propChanged(title,tmp,(String)o);
			}
		}
		public void setEnabledPropByName(String name,boolean enable) {
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				if (name.equals(tmp.getName())) {tmp.setEnabled(enable);}
			}
			statusTableM.setProps(props);
		}
		public String getPropByName(String name) {
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				if (name.equals(tmp.getName())) {return tmp.getValue();}
			}
			return "";
		}
		public void setPropByName(String name,String value) {
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				if (name.equals(tmp.getName())) {tmp.setValue(value);}
			}
		}
		public String[][] buildStatusCanvasTableCells() {
			int columns = colNames.length;
			String[][] cells = new String[props.size()][columns];
			int i = 0;
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				cells[i][0] = tmp.getName();  
				cells[i][1] = tmp.getValue(); 
				i++;
			}
			return(cells);
		}
		
		public propBoxDialog(Frame parent,String msg,Vector v,String id,propBoxDialogListener pbdl) {
			super(parent,msg,true);
			
			this.target = pbdl;
			this.id = id;
			this.title = msg;
			props = v;
			String[][]data = buildStatusCanvasTableCells();
			statusTableM = new statusCanvasTableModel(data,colNames);
			statusTableM.addTableModelListener(this);
			statusTableM.setProps(props);
			statusTable = new JTableX(statusTableM);
			statusTable.setPreferredScrollableViewportSize(new Dimension(250,(charHeight*props.size()))); // 100 GDB 20102016
			JScrollPane statusTablePane = new JScrollPane(statusTable);
			
	        // create a RowEditorModel... this is used to hold the extra
	        // information that is needed to deal with row specific editors
	        RowEditorModel rm = new RowEditorModel();
	        // tell the JTableX which RowEditorModel we are using
	        statusTable.setRowEditorModel(rm);
	        
			for(int i=0;i<props.size();i++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(i);
				if (tmp.isCombo()) {createComboBoxRender(tmp.getComboOpts(),i);}
			}
			
			JPanel p = new JPanel();
			p.setBackground(Color.gray);
			p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));
			p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
			p.add(statusTablePane);
			p.add(Box.createRigidArea(new Dimension(charWidth,(int) (1.5*charHeight))));
			JPanel p1 = new JPanel();
			p1.setBackground(Color.gray);
			p1.setLayout(new BoxLayout(p1,BoxLayout.X_AXIS));
			OKBut = new JButton("Ok");
			p1.add(OKBut);
			CANCELBut = new JButton("Cancel");
			p1.add(CANCELBut);
			JPanel p3 = new JPanel();
			p3.setBackground(Color.gray);
			p3.setLayout(new BoxLayout(p3,BoxLayout.Y_AXIS));
			p3.add(p);
			p3.add(p1);
			add(p3);

			ActionListener OKTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					bOK = true;
					dispose();
			   }
			};
			OKBut.addActionListener(OKTask);
			ActionListener CANCELTask = new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					for (int j=0;j<props.size();j++) {
						statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
						tmp.setValue(tmp.getIntValue());
					}
					dispose();
			   }
			};
			CANCELBut.addActionListener(CANCELTask);
	   	    addComponentListener(new ComponentAdapter() {
				public void componentMoved(ComponentEvent evt) {
					//savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "stc");
				}
			});
			bOK = false;
			pack();
			//loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "stc");
			setVisible(true);
		}
		
		public void destory() {
			dispose();
		}
	}
	public propBoxDialog displayPropBoxDialog(String msg,Vector props,String id) {
		Frame top = getTopLevelParent(this);		
		propBoxDialog d = new propBoxDialog(top,msg,props,id,null);
		return d;
	}
	public propBoxDialog displayPropBoxDialog(String msg,Vector props) {
		Frame top = getTopLevelParent(this);		
		propBoxDialog d = new propBoxDialog(top,msg,props,"",null);
		return d;
	}
	public String[] getDataAsDialog(String title,String[] fields,String[] defaults) {
		return getDataAsDialog(title,fields,defaults,null);
	}	
	public String[] getDataAsDialog(String title,String[] fields,String[] defaults,propBoxDialogListener pbdl) {
		Vector props = new Vector();
		int index = 0;
		
		statusCanvasProp csp;
		csp = new statusCanvasProp(" ",""); // simulates a blank line
		props.addElement(csp);

		for(int i=0;i<fields.length;i++) {
			if (defaults[i].indexOf(",") != -1) {
				TRACE("getDataAsDialog:"+fields[i]+":"+defaults[i],4);
				Vector v = supportFunctions.splitIntoTokens(defaults[i],",");
				String[] s = new String[v.size()];
				int sindex = 0;
				for (int ii=0;ii<v.size();ii++) {
					String tmp = (String)v.elementAt(ii);
					if (tmp.startsWith("##")) {
						try {
							index = Integer.parseInt(tmp.substring(2));
						} catch (Exception e) {}
					} else {
						s[sindex++] = tmp;						
					}
				}
				if (sindex != v.size()) { // #bug 63 09/08/17
					displayDialog("compacting array");
					String[] stmp = new String[v.size()-1]; // remove last element
					System.arraycopy(s, 0, stmp, 0, s.length-1);
					s = stmp;
				}
				if (index >= s.length) {index = 0;}
				csp = new statusCanvasProp(fields[i],s[index],s);				
			} else {
				csp = new statusCanvasProp(fields[i],defaults[i]);				
			}
			props.addElement(csp);
		}
		Frame top = getTopLevelParent(this);		
		propBoxDialog d = new propBoxDialog(top,title,props,"",pbdl);

		if(d.isOK()) {
			String[] data = new String[props.size()-1]; // ignore 1st property
			for(int i=1;i<props.size();i++) {
				statusCanvasProp prop = (statusCanvasProp)props.elementAt(i);
				data[i-1] = prop.getValue();
			}
			return data;
		}

		return null;
	}

	public String getPropValue(String title,String propName,String propDefault) {
		Vector props = new Vector();
		props.addElement(new statusCanvasProp(propName,propDefault));
		propBoxDialog d = displayPropBoxDialog(title,props);
		return d.getPropByName(propName);
	}
	public int getPropValue(String title,String propName,int propDefault) {
		Vector props = new Vector();
		props.addElement(new statusCanvasProp(propName,String.valueOf(propDefault)));
		propBoxDialog d = displayPropBoxDialog(title,props);
		return Integer.parseInt(d.getPropByName(propName));
	}

	public statusCanvasDialog displayModeless1StatusDialog(String msg,Vector props) {
		Frame top = getTopLevelParent(this);		
		statusCanvasDialog d = new statusCanvasDialog(top,msg,props);
		return d;
	}
	public class statusCanvasTableModel extends DefaultTableModel {
		   private Vector	props = new Vector();
		   
		   statusCanvasTableModel(String[][] data,String[] colNames) {
		      super(data,colNames);
		   }
		   public Class getColumnClass(int column) {
			return (getValueAt(0,column).getClass());
		   }
		   public boolean isCellEditable(int row,int column) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(row);
				if (tmp.getEnabled() == false) {return false;}
				if (column == 1) {return true;} else {return false;}
		   }
		   public void setProps(Vector v) {props=v;}
	}
	public interface statusCanvasDialogListener {
		public void propTableUpdated(String title,String propName,String propNewValue);
	}
	public class JTableExtra extends JTable {
		protected String[] columnToolTips; // element can be null if there is no tooltip text for a column
			
		public JTableExtra() {
			super();
			setTipTexts((String[])null);
		}
		public JTableExtra(String[] tips) {
			super();
			setTipTexts(tips);
		}
		public JTableExtra(int rows,int cols) {
			super(rows,cols);
			setTipTexts((String[])null);
		}
		public JTableExtra(int rows,int cols,String[] tips) {
			super(rows,cols);
			setTipTexts(tips);
		}
		public JTableExtra(Vector data,Vector colnames) {
			super(data,colnames);
			setTipTexts((String[])null);
		}
		public JTableExtra(Vector data,Vector colnames,String[] tips) {
			super(data,colnames);
			setTipTexts(tips);
		}
		public JTableExtra(Object[][] data,Object[] colnames) {
			super(data,colnames);
			setTipTexts((String[])null);
		}
		public JTableExtra(Object[][] data,Object[] colnames,String[] tips) {
			super(data,colnames);
			setTipTexts(tips);
		}
		public JTableExtra(DefaultTableModel m) {
			super(m); // call normal JTable class constructor with a table model parameter
			setTipTexts(null);
		}
		public JTableExtra(DefaultTableModel m,String[] tips) {
			super(m); // call normal JTable class constructor with a table model parameter
			setTipTexts(tips);
		}
		
		public void createComboBoxRender(String[] options,int colNumber) {
			JComboBox cb = new JComboBox();
			TableColumn tc = getColumnModel().getColumn(colNumber);
			
			for (int i=0;i<options.length;i++) {
				cb.addItem(options[i]);
			}
			tc.setCellEditor(new DefaultCellEditor(cb));
		}
		
		public void removeTipTexts() {
			setTipTexts(null);
		}
		public void setTipTexts(String[] tips) {
			columnToolTips = tips;
		}
		//implement table cell tool tips
		public String getToolTipText(MouseEvent e) {
			String tip = null;
			java.awt.Point p = e.getPoint();
			int rowindex = rowAtPoint(p);
			int colindex = columnAtPoint(p);
			// user could have changed the order of the columns
			int realIndex = convertColumnIndexToModel(colindex);
			tip = getCellToolTipText(rowindex,realIndex);
			if (tip == null) {tip = super.getToolTipText(e);}
			return tip;
		}
		// override following function to return text of cell's tool tip or null if no tool tip text
		public String getCellToolTipText(int row,int column) {
			return null;
		}	
		//Implement table header tool tips.
		protected JTableHeader createDefaultTableHeader() {
			return new JTableHeader(columnModel) {
				public String getToolTipText(MouseEvent e) {
					String tip = null;
					java.awt.Point p = e.getPoint();
					int index = columnModel.getColumnIndexAtX(p.x);
					// user could have changed the order of the columns
					int realIndex = columnModel.getColumn(index).getModelIndex();
					if (columnToolTips == null) {return "";}
					return columnToolTips[realIndex];
				}
			};
		}		
   	}
		
	public class statusCanvasDialog extends positionDialog implements TableModelListener {

		// this is an inner classs so it has access to the 'props' variable ...
		public class statusCanvasTableCellRenderer extends DefaultTableCellRenderer {
			public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,
                                                 boolean hasFocus,int row,int column) {
				Component c = super.getTableCellRendererComponent(table, value,isSelected, hasFocus,row, column);
			
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(row);
				if (tmp.getComboOpts() != null) {
					JComboBox cb = new JComboBox();
					String[] opts = tmp.getComboOpts();
					String propValue = tmp.getValue();
					cb.addItem(propValue);
					for (int i=0;i<opts.length;i++) {
						if (!propValue.equals(opts[i])) {cb.addItem(opts[i]);}
					}
					c = cb;
				}
			
				return c;
			}
		}
		// this is an inner classs so it has access to the 'props' variable ...
		public class JTableStatusCanvas extends JTableExtra {
		
			public JTableStatusCanvas(DefaultTableModel m,String[] tips) {
				super(m,tips); 
			}
			public TableCellEditor getCellEditor(int row, int column)
			{	
				int modelColumn = convertColumnIndexToModel( column );
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(row);
				if (tmp.getComboOpts() != null) {
					JComboBox comboBox1 = new JComboBox( tmp.getComboOpts() );
					return new DefaultCellEditor( comboBox1 );
				}

				return super.getCellEditor(row, column);
			}
		}

		private JTableStatusCanvas statusTable;
		private statusCanvasTableModel statusTableM;
		private String[] colNames = {"Name","Value"};
		private Vector	props = new Vector();
		private	statusCanvasDialogListener target = null;
		private String title = "";
		
		public Vector getProps() {return props;}
		public void addStatusCanvasDialogListener(statusCanvasDialogListener dcu) {target = dcu;}
		public void removeStatusCanvasDialogListener() {target = null;}
		public void tableChanged(TableModelEvent evt) {
			int row = evt.getFirstRow();
			int column = evt.getColumn();
			TableModel model = (TableModel)evt.getSource();
			if (row == -1 || column == -1) {return;}
			//TRACE("tableChanged: row="+String.valueOf(row)+", column="+String.valueOf(column),4);
			// get and set table data using getValueAt(row,column) and setValueAt(row,column)
			// we need to cast them to the appropriate data types as stored as type Object
			statusCanvasProp tmp = (statusCanvasProp)props.elementAt(row);
			Object o =  statusTable.getValueAt(row,column);
			tmp.setValue((String)o);
			
			if (target != null) {
				target.propTableUpdated(title,(String)statusTable.getValueAt(row,0),(String)(o));
			}
		}
		public void setComboOptsByName(String name,String[] opts) {
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				if (name.equals(tmp.getName())) {tmp.setComboOpts(opts);}
			}
			statusTableM.setProps(props);
		}
		public void setEnabledPropByName(String name,boolean enable) {
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				if (name.equals(tmp.getName())) {tmp.setEnabled(enable);}
			}
			statusTableM.setProps(props);
		}
		public String getPropByName(String name) {
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				if (name.equals(tmp.getName())) {return tmp.getValue();}
			}
			return "";
		}
		public void setPropByName(String name,String value) {
			int tableRow = -1;
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				if (name.equals(tmp.getName())) {tmp.setValue(value);tableRow = j;}
			}
			if (tableRow != -1) {
				statusTableM.setProps(props);
				statusTableM.setValueAt((Object)value,tableRow,1);
				statusTableM.fireTableDataChanged();
			}
		}
		public String[][] buildStatusCanvasTableCells() {
			int columns = colNames.length;
			String[][] cells = new String[props.size()][columns];
			int i = 0;
			for (int j=0;j<props.size();j++) {
				statusCanvasProp tmp = (statusCanvasProp)props.elementAt(j);
				cells[i][0] = tmp.getName();  
				cells[i][1] = tmp.getValue(); 
				i++;
			}
			return(cells);
		}
		
		public statusCanvasDialog(Frame parent,String msg,Vector p1) {
			super(parent,msg,false);
			
			title = msg;
			
			String[] columnToolTips = {
				"The name of the property",
				"The value of the property"};

			target = null;
			props = p1;
			String[][]data = buildStatusCanvasTableCells();
			statusTableM = new statusCanvasTableModel(data,colNames);
			statusTableM.addTableModelListener(this);
			statusTableM.setProps(props);
			statusTable = new JTableStatusCanvas(statusTableM,columnToolTips);

			// 1 because thats the value column
			TableColumn tc1 = statusTable.getColumnModel().getColumn(1);
			tc1.setCellRenderer(new statusCanvasTableCellRenderer());
	
			TableColumn tc = statusTable.getColumn(colNames[0]);
			tc.setPreferredWidth(50); // set all three widths to get a fixed size column
			tc.setMaxWidth(50);
			tc.setMinWidth(50);
			statusTable.sizeColumnsToFit(JTable.AUTO_RESIZE_OFF); // needed because bug in JVM
			statusTable.setPreferredScrollableViewportSize(new Dimension(200,160));
			JScrollPane statusTablePane = new JScrollPane(statusTable);
			
			JPanel p = new JPanel();
			p.add(statusTablePane);
			add(p);
	   	    addComponentListener(new ComponentAdapter() {
				public void componentMoved(ComponentEvent evt) {
					savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "stc");
				}
			});
			pack();
			setVisible(true);
		}
		
		public void destory() {
			dispose();
		}
	}
	
	public class statusCanvasProp {
		private String name;
		private String value;
		private	String intValue;
		private boolean enabled;
		private String[] options;
		
		statusCanvasProp(String n,String v,String[] opts) {
			name = n;
			value = v;
			intValue = v;
			enabled = true;
			options = opts;
		}
		statusCanvasProp(String n,String v) {
			name = n;
			value = v;
			intValue = v;
			enabled = true;
			options = null;
		}
		statusCanvasProp() {
			name = "";
			value = "";
			enabled = true;
			options = null;
		}
		public Class getPropClass() {
			String tmp = "";
			return tmp.getClass();
		}
		public boolean isCombo() {if (options==null) {return false;} else {return true;}}
		public String[] getComboOpts() {return options;}
		public void setComboOpts(String[] opts) {options = opts;}
		public boolean getEnabled() {return enabled;}
		public void setEnabled(boolean b) {enabled = b;}
		public String getName() {return name;}
		public String getValue() {return value;}
		public String getIntValue() {return intValue;}
		public int getValueAsInt() {
			return Integer.parseInt(value);
		}
		public void setValueAsInt(int i) {
			value = String.valueOf(i);
		}
		public void setValue(String s) {value = s;}
	}

	public class statusCanvas {
		private	statusCanvasDialog	dialog;
		private String		title;
		private	Vector 		props = new Vector();
		
		public statusCanvas(String t) {
			title = t;
			dialog = null;
			props.removeAllElements();
		}
		public statusCanvasDialog getDialog() {return dialog;}
		public String getPropByName(String name) {return dialog.getPropByName(name);}
		public void setComboOptsByName(String name,String[] opts) {
			if (dialog == null) {TRACE("Props dialog not yet created",3);return;}
			dialog.setComboOptsByName(name,opts);
		}
		public void setEnabledPropByName(String name,boolean enable) {
			if (dialog == null) {TRACE("Props dialog not yet created",3);return;}
			dialog.setEnabledPropByName(name,enable);
		}
		public void setPropByName(String name,String value) {
			if (dialog == null) {TRACE("Props dialog not yet created",3);return;}
			dialog.setPropByName(name,value);
		}
		public void setPropByName(String name,int value) {
			if (dialog == null) {TRACE("Props dialog not yet created",3);return;}
			dialog.setPropByName(name,String.valueOf(value));
		}
		public void setProps(Vector v) {props = v;}
		public void statusCanvasShow() {
			if (dialog == null) {
				dialog = displayModeless1StatusDialog(title,props);
				dialog.loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "stc");
			}
		}
		public void statusCanvasSave() {
			if (dialog != null) {
				dialog.savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "stc");
			}
		}
		public void statusCanvasHide() {
			if (dialog != null) {
				dialog.destory();
				dialog.dispose();
				dialog = null;
			}
		}
		protected void finalize() throws Throwable {
			statusCanvasHide();
			super.finalize();
		}
	}
	
	public void multiColumnCanvasTest() {
		multiColumnCanvasComponent c = new multiColumnCanvasComponent();
		String[] colData1 = {"aaa","bbb"};
		String[] colData2 = {"ccc","ddd"};
		String[] colData3 = {"Yes","No"};
		String[] options = {"Yes","No"};
		c.addColumn("Title 1",true,colData1);
		c.addColumn("Title 2",true,colData2);
		c.addComboColumn("Title 3",true,colData3,options);
		multiColumnCanvasDialog d = new multiColumnCanvasDialog(null,"Test MCD",c);
	}
	public class multiColumnCanvasCol {
		private String 		title;
		private boolean 	bEnabled;
		private String[] 	data;
		private boolean 	bComboCol;
		private boolean 	bUpdateDB;
		private String[] 	options;
		private String 		tooltipText;
		private	String 		tableName;
		private	String		colName;
		private String		unqColName;
		private Vector		unqColData = new Vector();
		
		multiColumnCanvasCol() {
			title = "Untitled";
			bEnabled = true;
			data = null;
			options = null;
			tooltipText = null;
			bComboCol = false;
			bUpdateDB = false;
			tableName = null;
			colName = null;
			unqColName = null;
		}
		multiColumnCanvasCol(String title,boolean bEnabled,String[] data) {
			this.title = title;
			this.bEnabled = bEnabled;
			this.data = data;
			this.bComboCol = false;
			this.tooltipText = null;
			this.options = null;
			this.bUpdateDB = false;
			this.tableName = null;
			this.colName = null;
			this.unqColName = null;
		}
		multiColumnCanvasCol(String title,boolean bEnabled,String[] data,String[] options) {
			this.title = title;
			this.bEnabled = bEnabled;
			this.data = data;
			this.bComboCol = true;
			this.tooltipText = null;
			this.options = options;
			this.bUpdateDB = false;
			this.tableName = null;
			this.colName = null;
			this.unqColName = null;
		}
		multiColumnCanvasCol(String title,boolean bEnabled,String tableName,String colName,String unqColName) {
			this.title = title;
			this.bEnabled = bEnabled;
			this.data = getDBFieldData();
			this.bComboCol = false;
			this.tooltipText = null;
			this.options = null;
			this.bUpdateDB = true;
			this.tableName = tableName;
			this.colName = colName;
			this.unqColName = unqColName;
		}
		multiColumnCanvasCol(String title,boolean bEnabled,String tableName,String colName,String unqColName,String[] options) {
			this.title = title;
			this.bEnabled = bEnabled;
			this.data = getDBFieldData();
			this.bComboCol = true;
			this.tooltipText = null;
			this.options = options;
			this.bUpdateDB = true;
			this.tableName = tableName;
			this.colName = colName;
			this.unqColName = unqColName;
	}
		public boolean isUpdateDB() {return bUpdateDB;}
		protected void finalize() throws Throwable {
			if (bUpdateDB) {setDBFieldData();}
			super.finalize();
		}
		void setDBFieldData() {
			String query = "";
			
			for (int i=0;i<data.length;i++) {
				query = "UPDATE " + tableName + " SET " + colName + "='" + 
						data[i] + "' WHERE " + unqColName + "=" + 
						(String)unqColData.elementAt(i);
				systemMysql.executeSQLQuery(query,"");
			}
		}
		String[] getDBFieldData() {
			String query = "SELECT " + unqColName + " FROM " + tableName;
			String data = systemMysql.executeSQLQuery(query,"");
			unqColData = supportFunctions.splitIntoTokens(data,",");

			query = "SELECT " + colName + " FROM " + tableName;
			data = systemMysql.executeSQLQuery(query,"");
			Vector v = supportFunctions.splitIntoTokens(data,",");
			String[] tmp = new String[v.size()];
			v.copyInto(tmp);
			return tmp;
		}
		public String getTitle() {return title;}
		public void setTitle(String s) {title = s;}
		public boolean getEnabled() {return bEnabled;}
		public void setEnabled(boolean b) {bEnabled = b;}
		public String[] getData() {return data;}
		public void setData(String[] data) {this.data = data;}
		public void setData(int index,String value) {
			if ((data.length-1) < index) {return;}
			data[index] = value;
		}
		public String getData(int index) {
			if ((data.length-1) < index) {return null;}
			return data[index];
		}
		public int getNumDataItems() {return data.length;}
		public boolean isComboCol() {return bComboCol;}
		public String[] getComboOpts() {return options;}
		public void addDataItem(String s,int index) {
			if (isUpdateDB()) {displayDialog("Operation not allowed for a DB column");return;}
			String[] newData = new String[data.length + 1];
			for (int i=0;i<data.length;i++) {newData[i] = data[i];}
			newData[data.length] = s;
			data = newData;
		}
		public void deleteDataItem(int index) {
			if (isUpdateDB()) {displayDialog("Operation not allowed for a DB column");return;}
			if ((data.length-1) < index) {return;}
			String[] newData = new String[data.length - 1];
			int j = 0;
			for (int i=0;i<data.length;i++) {if (i == index) {} else {newData[j++] = data[i];}}
			data = newData;
		}
	}

	public class multiColumnCanvasTableModel extends DefaultTableModel {
		   private Vector cols = new Vector();
		   
		   multiColumnCanvasTableModel(String[][] data,String[] colNames) {
		      super(data,colNames);
		   }
		   public Class getColumnClass(int column) {
			return (getValueAt(0,column).getClass());
		   }
		   public boolean isCellEditable(int row,int column) {
				multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(column);
				return tmp.getEnabled();
		   }
		   public void setColumns(Vector v) {cols = v;}
	}
	public interface multiColumnCanvasDialogListener {
		public void multiColumnCanvasUpdated(String propNewValue,int row,int column);
	}
	public class multiColumnCanvasComponent implements TableModelListener {
		private JTableExtra table;
		private multiColumnCanvasTableModel model;
		private Vector cols = new Vector();
		private JScrollPane spane;
		private	multiColumnCanvasDialogListener target = null;
		
		public void addmultiColumnCanvasDialogListener(multiColumnCanvasDialogListener dcu) {target = dcu;}
		public void removemultiColumnCanvasDialogListener() {target = null;}
		public void tableChanged(TableModelEvent evt) {
			int row = evt.getFirstRow();
			int column = evt.getColumn();
			TableModel model = (TableModel)evt.getSource();
			if (row == -1 || column == -1) {return;}
			column = table.convertColumnIndexToModel(column);
			TRACE("tableChanged: row="+String.valueOf(row)+", column="+String.valueOf(column),4);
			// get and set table data using getValueAt(row,column) and setValueAt(row,column)
			// we need to cast them to the apporiate data types as stored as type Object
			Object o =  table.getValueAt(row,column);
			setDataCell(row,column,(String)o);
			
			TRACE("MCCD: Target NOT NULL: " + (String)(o),4);
			if (target != null) {
				target.multiColumnCanvasUpdated((String)(o),row,column);
			}
		}
		public multiColumnCanvasTableModel getModel() {return model;}
		public JTableExtra getTable() {return table;}
		public void addDBColumn(String title,boolean enabled,String tableName,String colName,String unqColName) {
			cols.addElement(new multiColumnCanvasCol(title,enabled,tableName,colName,unqColName));
		}
		public void addColumn(String title,boolean enabled,String[] data) {
			cols.addElement(new multiColumnCanvasCol(title,enabled,data));
		}
		public void addComboColumn(String title,boolean enabled,String[] data,String[] options) {
			cols.addElement(new multiColumnCanvasCol(title,enabled,data,options));
		}
		public multiColumnCanvasCol getColumn(int index) {
			if (index > cols.size()) {return null;}
			return (multiColumnCanvasCol) cols.elementAt(index);
		}
		public int getNumColumns() {return cols.size();}
		public int getNumRows() {
			if (cols.size() == 0) {return 0;}
			multiColumnCanvasCol col = (multiColumnCanvasCol)cols.elementAt(0); // assume all columns have the same number of data items in
			return col.getNumDataItems();
		}
		public JScrollPane getComponent() {return spane;}
		public String[] getColumnNames() {
			String[] tmp = new String[cols.size()];
			for (int i=0;i<cols.size();i++) {
				multiColumnCanvasCol col = (multiColumnCanvasCol)cols.elementAt(i);
				tmp[i] = col.getTitle();
			}
			
			return tmp;
		}
		public String[][] buildComponentData() {
			int numCols = cols.size();
			multiColumnCanvasCol col = (multiColumnCanvasCol)cols.elementAt(0);
			int numRows = col.getNumDataItems();
			
			// fill up the column names and table data
			String[][] data = new String[numRows][numCols];
			for (int i=0;i<numCols;i++) {
			multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(i);
			String[] s = tmp.getData();
				for (int j=0;j<s.length;j++) {
					data[j][i] = s[j];
				}
			}
			
			return data;
		}
		public void create() {
			model = new multiColumnCanvasTableModel(buildComponentData(),getColumnNames());
			model.setColumns(cols); // is there a better way ?!?
			table = new JTableExtra(model);

			for (int i=0;i<cols.size();i++) {
				multiColumnCanvasCol col = (multiColumnCanvasCol)cols.elementAt(i);			
				if (col.isComboCol()) {
					table.createComboBoxRender(col.getComboOpts(),i);
				}
			}
			
			table.sizeColumnsToFit(JTable.AUTO_RESIZE_OFF); // needed because bug in JVM
			model.addTableModelListener(this);
			spane = new JScrollPane(table);			
		}
		public void setDataCell(int row,int col,String data) {
			if (col >= cols.size()) {return;}
			multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(col);
			tmp.setData(row,data);
			model.setColumns(cols); // is there a better way ?!? update model data set
		}
		public String getDataCell(int row,int col) {
			if (col >= cols.size()) {return null;}
			multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(col);
			return tmp.getData(row);
		}
		public String[] getDataCol(int col) {
			if (col >= cols.size()) {return null;}
			multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(col);
			return tmp.getData();
		}
		public String[] getDataRow(int row) {
			if (cols.size() == 0) {return null;}
			multiColumnCanvasCol col = (multiColumnCanvasCol)cols.elementAt(0);
			int numRows = col.getNumDataItems();
			if (row >= numRows) {return null;}
			String[] data = new String[cols.size()];
			for (int i=0;i<cols.size();i++) {
				data[i] = getDataCell(row,i);
			}
			
			return data;
		}
		public void setRowData(int row,String[] data) {
			if (cols.size() == 0) {return;}
			multiColumnCanvasCol col = (multiColumnCanvasCol)cols.elementAt(0);
			int numRows = col.getNumDataItems();
			if (row >= numRows) {return;}
			for (int i=0;i<cols.size();i++) {
				setDataCell(row,i,data[i]);
			}
			model.setColumns(cols); // is there a better way ?!? update model data set
			model.fireTableDataChanged();
		}
		public void setColData(int col,String[] data) {
			if (col >= cols.size()) {return;}
			multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(col);
			tmp.setData(data);
			model.setColumns(cols); // is there a better way ?!? update model data set
			model.fireTableDataChanged();
		}
		public void addRowDataItem(String s,int col,int index) {
			if (col >= cols.size()) {return;}
			multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(col);
			tmp.addDataItem(s,index); // add index in latter!!! at moment only adds to end of list
			model.setColumns(cols); // is there a better way ?!? update model data set
			model.fireTableDataChanged();
		}
		public void deleteRowDataItem(int col,int index) {
			if (col >= cols.size()) {return;}
			multiColumnCanvasCol tmp = (multiColumnCanvasCol)cols.elementAt(col);
			tmp.deleteDataItem(index);
			model.setColumns(cols); // is there a better way ?!? update model data set
			model.fireTableDataChanged();
		}
	}
	public class multiColumnCanvasDialog extends positionDialog implements ActionListener {
		private JButton 	closeBut;
		private	multiColumnCanvasComponent comp = null;
		
		// forwarding functions to the component
		public void addmultiColumnCanvasDialogListener(multiColumnCanvasDialogListener dcu) {
			comp.addmultiColumnCanvasDialogListener(dcu);
		}
		public void removemultiColumnCanvasDialogListener() {comp.removemultiColumnCanvasDialogListener();}

		public multiColumnCanvasDialog(Frame parent,String msg,multiColumnCanvasComponent c) {
			super(parent,msg,true);
			
			comp = c;
			comp.create();
			
			JPanel p = new JPanel();
			p.add(c.getComponent());
		    closeBut = new JButton("Close");
		    closeBut.addActionListener(this);
		    p.add(closeBut);
			add(p);
			
			addComponentListener(new ComponentAdapter() {
				public void componentMoved(ComponentEvent evt) {
					savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "mcc");
				}
			});
			
			pack();
			loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "mcc");
			setVisible(true);
		}
		
		public void destory() {
			savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "mcc");
			dispose();
		}
		public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == closeBut) {
			   dispose();
		   }
	    }
	}
	
	public class drawingCanvasLayer {
		private	String		layerName;
		private	boolean		layerVisable;
		
		public drawingCanvasLayer() {
			layerName = "Layer 1";
			layerVisable = true;
		}
		public drawingCanvasLayer(String name) {
			layerName = name;
			layerVisable = true;
		}
		public drawingCanvasLayer(String name,boolean bEnabled) {
			layerName = name;
			layerVisable = bEnabled;
		}
		public String getLayerName() {return layerName;}
		public void setLayerName(String name) {layerName = name;}
		public boolean getLayerVisable() {return layerVisable;}
		public void setLayerVisable(boolean visable) {layerVisable = visable;}
		public String getAsXML() {return "<layer name=\""+layerName+"\"visable=1\""+String.valueOf(layerVisable)+"\"";}
	}
	public class layerManager {
		private	Vector layers = new Vector();
		private int nextLayerNumber = 1;
		
		public int getNumLayers() {return layers.size();}
		public int getNextLayerNumber() {return nextLayerNumber++;}
		public void addNewLayer() {
			layers.addElement(new drawingCanvasLayer());
			nextLayerNumber++;
		}
		public void addNewLayer(String name) {
			layers.addElement(new drawingCanvasLayer(name));
			nextLayerNumber++;
		}
		public void addNewLayer(String name,boolean bEnabled) {
			layers.addElement(new drawingCanvasLayer(name,bEnabled));
			nextLayerNumber++;
		}
		public void removeAllLayers() {layers.removeAllElements();nextLayerNumber = 1;}
		public drawingCanvasLayer getLayer(int layerIndex) {
			if (layerIndex >= layers.size()) {return (drawingCanvasLayer)null;}
			return (drawingCanvasLayer)layers.elementAt(layerIndex);
		}
		public boolean layerDisplayed(String name) {
			for (int i=0;i<layers.size();i++) {
				drawingCanvasLayer tmp = (drawingCanvasLayer)layers.elementAt(i);
				if (name.equals(tmp.getLayerName())) {return tmp.getLayerVisable();}
			}
		
			return true;
		}
		public drawingCanvasLayer getLayer(String name) {
			for (int i=0;i<layers.size();i++) {
				drawingCanvasLayer tmp = (drawingCanvasLayer)layers.elementAt(i);
				if (name.equals(tmp.getLayerName())) {return tmp;}
			}
			
			return (drawingCanvasLayer)null;
		}
		public String[] getLayerNames() {
			String[] names = new String[getNumLayers()];

			for (int i=0;i<getNumLayers();i++) {
				drawingCanvasLayer tmp = getLayer(i);
				names[i] = tmp.getLayerName();
			}
			
			return names;
		}
	}
	
	public class layerDialog extends positionDialog  implements ActionListener {
		private JButton	butDelete,butAdd,butOK,butCancel;
		private	multiColumnCanvasComponent listLayers = null;
		private layerManager layerMan = null;

		// forwarding functions to the component
		public void addmultiColumnCanvasDialogListener(multiColumnCanvasDialogListener dcu) {
			listLayers.addmultiColumnCanvasDialogListener(dcu);
		}
		public void removemultiColumnCanvasDialogListener() {listLayers.removemultiColumnCanvasDialogListener();}
		
		layerDialog (Frame f,layerManager layerMan) {
			super(f,"Layers",true);
				  
			addWindowListener(new WindowAdapter() {
				public void WindowClosing(WindowEvent evt) {
					destroy();
				}
			});

			this.layerMan = layerMan;
			int numLayers = layerMan.getNumLayers();
			listLayers = new multiColumnCanvasComponent();
			String[] options = {"Yes","No"};
			String[] colLayerNames = new String[numLayers];
			String[] colLayerVisables = new String[numLayers];
			
			for (int i=0;i<numLayers;i++) {
				drawingCanvasLayer tmp = layerMan.getLayer(i);
				colLayerNames[i] = tmp.getLayerName();
				if (tmp.getLayerVisable()) {colLayerVisables[i] = "Yes";} else {colLayerVisables[i] = "No";}
			}
			
			listLayers.addColumn("Name",false,colLayerNames);
			listLayers.addComboColumn("Visible",true,colLayerVisables,options);
			listLayers.create();
			listLayers.getTable().setColumnSelectionAllowed(false);
			listLayers.getTable().setRowSelectionAllowed(true);
			listLayers.getTable().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			
			butAdd = new JButton("Add");
			butDelete = new JButton("Delete");
			butOK = new JButton("OK");
		    butCancel = new JButton("Cancel");
		    butAdd.addActionListener(this);
		    butDelete.addActionListener(this);
		    butOK.addActionListener(this);
		    butCancel.addActionListener(this);
		   
			JPanel butPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		    butPanel.add(butAdd);
		    butPanel.add(butDelete);
		    butPanel.add(butOK);
		    //butPanel.add(butCancel);

		    JPanel p = new JPanel();
		    p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));		   
			JScrollPane sp = listLayers.getComponent();
			sp.setPreferredSize(new Dimension(50*charWidth,10*charHeight));
 			p.add(sp);
			p.add(butPanel);

		    add(p,"Center");
		   		
		    pack();
			loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "layers");
		    setVisible(true);
		}		
	    
		public void destroy() {
			savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + "layers");
			setVisible(false);
			dispose();
		}
		public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == butOK) {
			   int numRows = listLayers.getNumRows();
			   layerMan.removeAllLayers();
			   for(int i=0;i<numRows;i++) {
				String[] tmp = listLayers.getDataRow(i);
				TRACE("Row:"+String.valueOf(i)+" Name:" + tmp[0] + " Enabled:" + tmp[1],4);
				boolean bEnabled = true;
				if (tmp[1].equals("No")) {bEnabled = false;}
				layerMan.addNewLayer(tmp[0],bEnabled);
			   }
			   destroy();
		   }
		   if (evt.getSource() == butCancel) {
			   destroy();
		   }
		   if (evt.getSource() == butAdd) {
			String[] tmp = new String[2];
			tmp[0] = "Layer " + String.valueOf(layerMan.getNextLayerNumber());
			tmp[1] = "Yes";
			listLayers.getModel().addRow(tmp);
			listLayers.addRowDataItem(tmp[0],0,0);
			listLayers.addRowDataItem(tmp[1],1,0);
		   }
		   if (evt.getSource() == butDelete) {
			int[] rows = listLayers.getTable().getSelectedRows();
			if (rows.length == 0) {displayDialog("Select Row(s) First");return;}
			for (int i=0;i<rows.length;i++) {
				if(rows[i] != 0) {
					int index = rows[i]; //listLayers.getTable().ConvertRowIndexToModel(rows[i]);
					listLayers.getModel().removeRow(index);
					// remove layer name (0) and visible (1) data items
					listLayers.deleteRowDataItem(0,index);
					listLayers.deleteRowDataItem(1,index);
				} else {
					displayDialog("Can't delete this layer");
				}
			}
		   }
	    }
	}
	
	public class gridDialog extends positionDialog  implements ActionListener {
		private JButton	butDelete,butAdd,butOK,butCancel;
		protected	multiColumnCanvasComponent choice = null;
		private String dialogTitle;
		private boolean bAllowEdits = false;
		private String[] colTitles;
		private String[][] colOptions;
		private boolean bOk = false;

		// forwarding functions to the component
		public void addmultiColumnCanvasDialogListener(multiColumnCanvasDialogListener dcu) {
			choice.addmultiColumnCanvasDialogListener(dcu);
		}
		public void removemultiColumnCanvasDialogListener() {choice.removemultiColumnCanvasDialogListener();}
		
		gridDialog (Frame f,String dialogTitle,String[] colTitles,String dialogData,String[][] colOptions,boolean bAllowEdits) {
			super(f,dialogTitle,true);
			this.dialogTitle = dialogTitle;
			this.colTitles = colTitles;
			this.colOptions = colOptions;
			this.bAllowEdits = bAllowEdits;
				  
			addWindowListener(new WindowAdapter() {
				public void WindowClosing(WindowEvent evt) {
					destroy();
				}
			});

			Vector v = supportFunctions.splitIntoTokens(dialogData,",");
			choice = new multiColumnCanvasComponent();
			
			int cols = colTitles.length;
			int rows = dialogData.length() / cols;
			String[][] cellData = new String[rows][cols];
			int index = 0;
			for (int i=0;i<rows;i++) {
				for (int j=0;j<cols;j++) {
					cellData[i][j] = (String)v.elementAt(index++);
				}
			}
			String[] colData = new String[rows];
			for (int j=0;j<cols;j++) {
				for (int i=0;i<rows;i++) {
					colData[i] = cellData[i][j];
				}
				if (colOptions[j] == null) {
					choice.addColumn(colTitles[j], true, colData);
				}else {
					choice.addComboColumn(colTitles[j], true, colData, colOptions[j]);
				}
			}
			
			choice.create();
			choice.getTable().setColumnSelectionAllowed(false);
			choice.getTable().setRowSelectionAllowed(true);
			choice.getTable().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			
			butAdd = new JButton("Add");
			butDelete = new JButton("Delete");
			butOK = new JButton("OK");
		    butCancel = new JButton("Cancel");
		    butAdd.addActionListener(this);
		    butDelete.addActionListener(this);
		    butOK.addActionListener(this);
		    butCancel.addActionListener(this);
		   
			JPanel butPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		    if (bAllowEdits) {
				butPanel.add(butAdd);
				butPanel.add(butDelete);
		    }
			butPanel.add(butOK);
		    butPanel.add(butCancel);

		    JPanel p = new JPanel();
		    p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));		   
			JScrollPane sp = choice.getComponent();
			sp.setPreferredSize(new Dimension(50*charWidth,10*charHeight));
 			p.add(sp);
			p.add(butPanel);

		    add(p,"Center");
		   		
		    pack();
			loadPosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + dialogTitle);
		    setVisible(true);
		}		
	    
		public String getData() {
			String tmp = "";
			int numRows = choice.getNumRows();
		    for(int i=0;i<numRows;i++) {
				String[] tmp1 = choice.getDataRow(i);
				tmp = tmp + tmp1[0] + "," + tmp1[1] + ",";
			}
			
			tmp = tmp.substring(0,tmp.length()-1); // remove last , character
			return tmp;
		}

		public void destroy() {
			savePosition(systemUserReg.getAppSerialBase() + systemUserReg.getUserName() + dialogTitle);
			setVisible(false);
			dispose();
		}
		public boolean getOK() {return bOk;}
		public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == butOK) {
				bOk = true;
				destroy();
		   }
		   if (evt.getSource() == butCancel) {
				bOk = false;
				destroy();
		   }
		   if (evt.getSource() == butAdd) {
			String[] tmp = new String[choice.getNumColumns()];
			for (int i=0;i<choice.getNumColumns();i++) {
				tmp[i] = "xxx";
			}
			choice.getModel().addRow(tmp);
			for (int i=0;i<choice.getNumColumns();i++) {
				choice.addRowDataItem(tmp[0],i,0);				
			}
		   }
		   if (evt.getSource() == butDelete) {
			int[] rows = choice.getTable().getSelectedRows();
			if (rows.length == 0) {displayDialog("Select Row(s) First");return;}
			for (int i=0;i<rows.length;i++) {
				if(rows[i] != 0) {
					int index = rows[i]; //choice.getTable().ConvertRowIndexToModel(rows[i]);
					choice.getModel().removeRow(index);
					for (int ii=0;ii<choice.getNumColumns();ii++) {
						choice.deleteRowDataItem(ii,index);
					}
				} else {
					displayDialog("Can't delete this row");
				}
			}
		   }
	    }
	}

	public class spreadsheetRule {
		private String 	rule = "";
		private String	cellRef = "";
		
		spreadsheetRule(String cellRef,String rule) {
			this.rule = rule;
			this.cellRef = cellRef;
		}
		public String rule() {return rule;}
		public String cellRef() {return cellRef;}
	}
	public String eval(String formula) {
		Object result = null;
		
		try {
			ScriptEngineManager manager = new ScriptEngineManager();
			ScriptEngine engine = manager.getEngineByName("js");   
			result = engine.eval(formula);
		} catch (Exception e) {;}
        return String.valueOf(result);			
	}
	public class spreadsheetDialog extends gridDialog implements multiColumnCanvasDialogListener {
		private	ArrayList<spreadsheetRule> rules = null;
		
		spreadsheetDialog (Frame f,String dialogTitle,String[] colTitles,String dialogData,String[][] colOptions,boolean bAllowEdits) {
			super(f,dialogTitle,colTitles,dialogData,colOptions,bAllowEdits);
			
			rules = new ArrayList<spreadsheetRule>();
			addmultiColumnCanvasDialogListener(this);
		}
		public void multiColumnCanvasUpdated(String propNewValue,int row,int column) {
			processSpreadsheetRules();
		}
		public void processSpreadsheetRules() {
			String data = "";
			
			for (spreadsheetRule rule : rules) {
				data = processCellReferences(rule.rule());
				data = eval(data);
				choice.setDataCell(row(rule.cellRef()), col(rule.cellRef()), data);
			}
		}
		public void removeAllRules() {
			rules.clear();
		}
		public boolean checkRule(String formula) {return true;}
		public void addRule(String cellRef,String formula) {
			if (checkRule(formula)) {rules.add(new spreadsheetRule(cellRef,formula));}
		}
		public void deleteRule(String cellRef) {
			for (spreadsheetRule rule : rules) {
				if (cellRef.equals(cellRef)) {
					rules.remove(rule);break;
				}
			}
		}
		public String cellReference(int row,int col) {
			// Top left cell is (0,0) and is A1 and max column is ZZ
			StringBuffer buf = new StringBuffer("  ");
			
			int whole = (col / 27) - 1;
			int part = col % 27;
			if (whole >= 0) {
				int ch = 'A' + whole;
				buf.setCharAt(0,(char)ch);
			}
			int ch = 'A' + part;
			buf.setCharAt(1,(char)ch);
			
			return buf.toString().trim() + String.valueOf(row + 1);
		}
		public String processCellReferences(String formula) {
			ehsRegExp p = new ehsRegExp();
			p.regExpMatch(formula, "#(.*)#");
			String[] tokens = p.getFoundStringsArray();
			for (int i=0;i<tokens.length;i++) {
				String cellRef = tokens[i].substring(1, tokens[i].length()-1);
				formula = formula.replaceAll(tokens[i],
						choice.getDataCell(row(cellRef),col(cellRef)));
			}
			
			return formula;
		}
		public int col(String cellRef) {
			// 1st col has an index of 0
			int rowIndex = -1;
			cellRef = cellRef.toUpperCase();
			for (int i=0;i<cellRef.length();i++) {
				if (Character.isDigit(cellRef.charAt(i))) {
					rowIndex = i;break;
				}
			}
			if (rowIndex == -1 || rowIndex == 0) {return -1;} //error!!!
			String colReference = cellRef.substring(0,rowIndex);
			int col = 0;
			for (int i=0;i<colReference.length();i++) {
				char ch = colReference.charAt(i);
				col = col + (((ch - 'A' + 1) * 26) * i);
			}
			return col;
		}
		public int row(String cellRef) {
			// 1st row has an index of 0
			int rowIndex = -1;
			cellRef = cellRef.toUpperCase();
			for (int i=0;i<cellRef.length();i++) {
				if (Character.isDigit(cellRef.charAt(i))) {
					rowIndex = i;break;
				}
			}
			if (rowIndex == -1 || rowIndex == 0) {return -1;} //error!!!
			return Integer.parseInt(cellRef.substring(rowIndex)) - 1;			
		}
	}

	public String displayLogonDialog() {
		logonDialog d = new logonDialog(null);
		return d.getUserName() + "," + d.getPassword();
	}
	public class logonDialog extends positionDialog  implements ActionListener {
		private JButton	butOK,butCancel;
		private String username,password;
		private	TextField usernameTF,passwordTF;

		public logonDialog (Frame f) {
			super(f,"User Logon",true);
				  
			username = "";
			password = "";			
				  
		    JPanel butPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		    butOK = new JButton("Ok");
		    butCancel = new JButton("Cancel");
		    butOK.addActionListener(this);
		    butCancel.addActionListener(this);
		    butOK.setMinimumSize(new Dimension(10*charWidth,charHeight));
		    butCancel.setMinimumSize(new Dimension(10*charWidth,charHeight));
		    butPanel.add(butOK);
		    butPanel.add(butCancel);
		   
			JPanel propSheetPanel = new JPanel();
			propSheetPanel.setLayout(new GridLayout(0,2));
			propSheetPanel.add(new JLabel("Username:"));
			usernameTF = new TextField("",10);
			propSheetPanel.add(usernameTF);			
			propSheetPanel.add(new JLabel("Password:"));
			passwordTF = new TextField("",10);
			propSheetPanel.add(passwordTF);			
			add(propSheetPanel,"Center");
			add(butPanel,"South");
		    
			addWindowListener(new WindowAdapter() {
				public void WindowClosing(WindowEvent evt) {
					dispose();
				}
		    });
		
		    pack();
		    setVisible(true);
		}		
	    public String getUserName() {return username;}
		public String getPassword() {return password;}
	    public void destroy() {
	   		  dispose();
	    }
		public void actionPerformed(ActionEvent evt) {
		   if (evt.getSource() == butOK) {
				username = usernameTF.getText();
				password = passwordTF.getText();
				dispose();
		   }
		   if (evt.getSource() == butCancel) {
				username = "";
				password = "";			
			    dispose();
		   }
	    }
	}

	public MenuItem getMenuItem(Menu m,String label) {
		for (int i=0;i<m.getItemCount();i++) {
			if (label.equalsIgnoreCase(m.getItem(i).getLabel())) {return m.getItem(i);}
		}
		return (MenuItem)null;
	}
	
	public Color colorCommonDialog(Color c) {
		return JColorChooser.showDialog(this,"Choose Color",c);
	}
	public void setCustomColor1() {
		Color c = colorCommonDialog(colorCodes[colorCodes.length-1]);
		if (c != null) {
			colorCodes[colorCodes.length-1] = c;			
			systemUserReg.getConfigurationSettings().setConfigurationSetting("customcolor1",String.valueOf(c.getRed())+","+String.valueOf(c.getGreen())+","+String.valueOf(c.getBlue()));
			if (getDrawingCanvas() != null) {getDrawingCanvas().refreshColorToolWindow();}
		}
	}
	public void setCustomColor2() {
		Color c = colorCommonDialog(colorCodes[colorCodes.length-2]);
		if (c != null) {
			colorCodes[colorCodes.length-2] = c;			
			systemUserReg.getConfigurationSettings().setConfigurationSetting("customcolor2",String.valueOf(c.getRed())+","+String.valueOf(c.getGreen())+","+String.valueOf(c.getBlue()));
			if (getDrawingCanvas() != null) {getDrawingCanvas().refreshColorToolWindow();}
		}
	}
	public class DCOutOfBoundsException extends Exception {
			public DCOutOfBoundsException() { }
			public DCOutOfBoundsException(String msg) {super(msg);}
	}
	
	// when a drawing item is added a unique Id is added of hashcode(macheId+ddMMyyyyHHmmss);
	// call setMultiUser(true) to write out a virtual refresh message every time a drawing item is added
	public class drawingCanvas extends printableCanvas implements MouseListener,MouseMotionListener,KeyListener,ChangeListener,ActionListener,ItemListener,ListSelectionListener,Printable,buttonCanvasUtils,statusCanvasDialogListener {
		private	float	fScalingFactor = 1;
		   private JList 	GCSheets = null;
		   protected int	canvasMaxX,canvasMaxY;
		   private boolean	gridVisible,dcFilled,dcOutline,dcMultiUser;
		   private int 		gridSpaceX,gridSpaceY;
		   private int		dcSelIndex;
		   private Cursor	normalCursor,handCursor,moveCursor,crosshairCursor,waitCursor;
		   private Cursor	eresizeCursor,wresizeCursor,nresizeCursor,sresizeCursor,rotateCursor;
		   private Cursor	neresizeCursor,nwresizeCursor,seresizeCursor,swresizeCursor;
		   private int		xCord,yCord;
		   protected Vector	drawingItems,selectedDrawingItems,clipboardDrawingItems,connectors,undoDrawingItems;
		   private String	dcEntity,dcSubEntity;
		   private int		dcMode,dcNum;
		   private int		dcLastX,dcLastY;
		   private int		dcStrokeWidth;
		   private int		dcLayer;
		   private Color	dcColor;
		   protected int		undoIndex;
		   private PopupMenu	dcMenu,dcConnectorMenu;
		   private CheckboxMenuItem	cbItem,cbGrid,cbPictureFrame;
		   private String[] optLabs = {"Line","Rectangle","Elipse","Image","Text","Select","Clear","Print","Properties"};
		   //private String[] colorLabs = {"White","Black","Green","Blue","Yellow","Red"};
		   private statusCanvas			statusPanel;
		   private colorButtonCanvas	colorPanel;
		   private diControlCanvas    	controlPanel;
		   private boolean	loading = false;
		   private drawingCanvasUtils	target = null;
		   private Thread	dcThread = null;
		   private boolean	dcThreadRunning = false;
		   private int		dcLastMsgID = 0;
		   private boolean	printing = false;
		   private drawingItem	dragDI = null;
		   private int		dragFH = -1;
		   private boolean	stickyTools = true;
		   private drawingItem	dragFHDI = null;
		   private boolean readonly = false;
		   private drawingItemConnector	menuSelectedConnector = null;
		   private drawingItem	menuSelectedDI = null;
		   private boolean displayStatus = true;
		   private Color	backgroundColor = Color.white;
		   private	boolean	dragBoundingBox = false;
		   private	Rectangle rcBoundingBox = null;
		   private	Point ptBoundingBox = null;
		   private	boolean bUseDatabase = true;
		   private 	boolean bVirtualMsgProcessing = false;
		   private	boolean bUpdateDC = true;
		   private	layerManager layerMan = new layerManager();
		   private	int loadMode = DCLoadFromDB;
		   private	boolean clipboardActive = false;
		   
		   private	int	defaultImageWidth = 50;
		   private	int	defaultImageHeight = 50;

		   private	boolean bDrawPictureFrame = false;
		   private	msg3Dialog GCSheetsDialog = null;
		   private	ArrayList arrGCSheets = new ArrayList();
		   
		   private	Image currentCanvasImage = null;
		   public 	Image getCurrentCanvasImage() {return currentCanvasImage;}
		  
		   public boolean bDrawFocusHandles = true;
		   public boolean getDrawFocusHandles() {return bDrawFocusHandles;}
		   public void setDrawFocusHandles(boolean b) {bDrawFocusHandles = b;}
		   
		   private float defaultZoomStep = 0.1f;
		   public void setDefaultZoomStep(float f) {defaultZoomStep = f;}
		   public float getDefaultZoomStep() {return defaultZoomStep;}
		   public void zoomNormalise() {fScalingFactor = 1;}
		   public void zoomIn(float step){fScalingFactor = fScalingFactor + step;}
		   public void zoomOut(float step){fScalingFactor = fScalingFactor - step;}
		   public float zoomFactor() {return fScalingFactor;}

		   public String[] getUserDefinedIDs(Vector drawingItems) {
				  String[] data = new String[drawingItems.size()];
				  for (int i=0;i<drawingItems.size();i++) {
					  drawingItem tmp = (drawingItem)drawingItems.elementAt(i);
					  data[i] = tmp.getUserDefinedName();
				  }
				  return data;
			  }
		   //public Rectangle getBoundingRect() {return new Rectangle(0,0,canvasMaxX,canvasMaxY);}
		   public void drawnOutOfBounds(drawingItem d) {;}
		   public boolean checkRectBounds(drawingItem d,Rectangle rc) {
			   try {
				   if (rectContainsRect(getDCBoundingRect(),d.getBoundingRect())) {throw new DCOutOfBoundsException();}
		   		} catch (DCOutOfBoundsException e) {drawnOutOfBounds(d);return false;}
			   return true;
		   }
		   
		   public String getPictureFrameText() {
				return systemUserReg.getAppName();
		   }
			public void drawPictureFrame(Graphics2D g2d) {
				TRACE("drawPictureFrame:entered",4);
				Color topColor = new Color(181,162,195);
				if (!bDrawPictureFrame) {return;}
				
				TRACE("drawing picture frame",4);
				g2d.setStroke(new BasicStroke(3));
				g2d.drawRoundRect(charWidth,charHeight*3,dcMaxX-charWidth,dcMaxY-charHeight,30,30);
				g2d.setStroke(new BasicStroke(1));
				String text = getPictureFrameText();
				if (text.length()  != 0) {
					FontMetrics fm = getFontMetrics(g2d.getFont());
					int width = fm.stringWidth(text + "OO");
					int width1 = fm.stringWidth("O");
					int height = fm.getHeight();
					int ascent = fm.getAscent();
					g2d.fillRect(50,charHeight,width,height+(height/2));
					g2d.drawString(text,50+width1,charHeight*2);
				}
			}
			public int getNumberOfGCSheets() {
				return arrGCSheets.size();
			}
			public void addGCSheet(String name) {
				if (!arrGCSheets.contains(name)) {
					arrGCSheets.add(name);
				}
				if (GCSheetsDialog != null) {
					GCSheetsDialog.destory();
					GCSheetsDialog.dispose();
					GCSheetsDialog = displayPanelDialog(createGCSheetPanel(),"Switch GC Sheet");
				}
			}
			public void replaceGCSheet(String newname,String oldname) {
				deleteGCSheet(oldname);	
				addGCSheet(newname);	
			}
			public void deleteGCSheet(String name) {
				arrGCSheets.remove(name);
			}
			public void deleteAllGCSheets() {
				arrGCSheets.clear();
			}
		   public boolean switchGCSheet(String newentity) {
				closeDrawingCanvas();
				return openDrawingCanvas(newentity,loadMode);
		   }
		   public String[] getGCSheets() {
				String []tmp = new String[arrGCSheets.size()];
				arrGCSheets.toArray(tmp);
				return tmp;
		   }
		   public Point centerPoint(Rectangle r) {
			float cx = (float)r.getWidth() / (float)2.00;
			float cy = (float)r.getHeight() / (float)2.00;
			cx = cx + (float)r.getX();
			cy = cy + (float)r.getY();
			return new Point((int)cx,(int)cy);
		  }
		   public drawingItem getDIWithUserDefinedName(String name) {
			for (int i=0;i<drawingItems.size();i++) {
				drawingItem d = (drawingItem)drawingItems.elementAt(i);
				if (name.equals(d.getUserDefinedName())) {return d;}
			}
			
			return (drawingItem)null;
		   }
		   public boolean isClipboardActive() {return clipboardActive;}
		   public boolean openDrawingCanvas(String name,int lm) {
				//clearDrawingCanvas(); // not needed as called from loadDrawingItems() and loadAsXML(...)
				dcEntity = name; // do not use setEntity(...) as we do not want to call replaceGCSheet(...)
				dcSubEntity = "subentity"; // default value
				addGCSheet(dcEntity);
				if (lm > DCLoadFromXML) {lm = DCLoadFromDB;}
				loadMode = lm;
				switch (loadMode) {
					case DCLoadFromDB:
						loadDrawingItems();
						break;
					
					case DCLoadFromXML:
						loadAsXML(name);
						break;
				}
				String tmp = getSystemVar(getEntity() + "_dcbackcolor","white");
				setBackgroundColor(getColorCode(tmp));
				
				return true;
		   }
		   public void closeDrawingCanvas() {
				setSystemVar(getEntity() + "_dcbackcolor",getColorName(getBackgroundColor()));
				if (loadMode == DCLoadFromXML) {saveAsXML(getEntity());} else {saveDrawingItems();}
				clearDrawingCanvas();
				dcEntity = "entity"; // default value
				dcSubEntity = "subentity"; // default value
		   }
		   
		   public drawingItem createCustomDrawingItem(String entity,int type,String id,int x,int y,String p1,String p2,String p3,String p4,boolean fill,Color c) {
			return (drawingItem)null;
		   }
		   public String getUniqueID() {
				Date d = new java.util.Date();
				SimpleDateFormat f = new SimpleDateFormat("ddMMyyyyHHmmss");
				String tmp = f.format(d);
				return String.valueOf(ehsHashCode(machineID + tmp));
		   }
		   public void createConnector(drawingItem start,drawingItem end,String textStart,String textEnd,String id,int symStart,int symEnd,int layer,boolean writeDB) {
				if (textStart == null) {textStart = "";}
				if (textEnd == null) {textEnd = "";}
				if (writeDB) {
					systemMysql.executeSQLQuery("INSERT INTO sdcdrawingitems (sdcDIID,sdcDIEntity,sdcDIType,sdcDIName,sdcDIOriginX,sdcDIOriginY,sdcDIParam1,sdcDIParam2,sdcDIFilled,sdcDIColor,sdcDIParam3,sdcDIUnique,sdcDILayer,sdcDIParam4) VALUES (null,'"+dcEntity+"',"+String.valueOf(dcTypeConnector)+",'"+id+"',0,0,'"+start.getUnique()+"','"+end.getUnique()+"',0,'black','"+textStart+","+textEnd+"','"+getUniqueID()+"',"+String.valueOf(layer)+",'"+String.valueOf(symStart)+","+String.valueOf(symEnd)+"'","");
				}
			drawingItemConnector conn = new drawingItemConnector(start,end,textStart,textEnd,symStart,symEnd,id,dcLayer);
			connectors.addElement(conn);
		   }
		   public boolean getUpdate() {return bUpdateDC;}
		   public void setUpdate(boolean b) {bUpdateDC = b;if(b) {paint();}}
		   public boolean getUseDatabase() {return bUseDatabase;}
		   public void setUseDatabase(boolean b) {bUseDatabase = b;}
		   public void setStickyTools(boolean b) {stickyTools = b;}
		   public boolean getStickyTools() {return stickyTools;}
		   public void setReadOnly(boolean b) {readonly = b;}
		   public boolean getReadOnly() {return readonly;}
		   public void addDrawingCanvasListener(drawingCanvasUtils dcu) {target = dcu;}
		   public void removeDrawingCanvasListener() {target = null;}
		   public drawingCanvas() {
			   createDrawingCanvas("",dcMaxX,dcMaxY,dcGridSpaceX,dcGridSpaceY,true);
		   }
		   public drawingCanvas(String entity,int maxX,int maxY,int spaceX,int spaceY,boolean gVisible) {
			   createDrawingCanvas(entity,maxX,maxY,spaceX,spaceY,gVisible);
		   }
		   public Rectangle getDCBoundingRect() {return new Rectangle(0,0,canvasMaxX,canvasMaxY);}
		   public void createDrawingCanvas(String entity,int maxX,int maxY,int spaceX,int spaceY,boolean gVisible) {
			   drawingItems = new Vector();
			   selectedDrawingItems = new Vector();
			   clipboardDrawingItems = new Vector();
			   undoDrawingItems = new Vector();
			   connectors = new Vector();
			   
			   layerMan.removeAllLayers();
			   layerMan.addNewLayer(); // add default layer
			   
			   undoIndex = -1;
			   dcLastMsgID = 0;
			   dcSelIndex = -1;
			   canvasMaxX = maxX;
			   canvasMaxY = maxY;
			   gridSpaceX = spaceX;
			   gridSpaceY = spaceY;
			   gridVisible = gVisible;
			   dcFilled = false;
			   dcNum = 0;
			   dcEntity = entity;
			   dcSubEntity = "subentity";
			   dcLastX = 0;
			   dcLastY = 0;
			   xCord = 0;
			   yCord = 0;
			   dcMode = dcTypeSelect;
			   dcOutline = false;
			   loading = false;
			   target = null;
			   dcThread = null;
			   dcThreadRunning = false;
			   printing = false;
			   dragDI = null;
			   dragFH = -1;
			   stickyTools = true;
			   dragFHDI = null;
			   dcMultiUser = false;
			   readonly = false;
			   menuSelectedConnector = null;
			   menuSelectedDI = null;
			   dcStrokeWidth = 1;
			   dcLayer = 1;
			   displayStatus = true;
			   dragBoundingBox = false;
			   rcBoundingBox = null;
			   ptBoundingBox = null;
			   bUseDatabase = true;
			   bVirtualMsgProcessing = false;
			   backgroundColor = Color.white;
			   bUpdateDC = true;
			   clipboardActive = false;
			   
			   createMenu();
			   setSize(maxX,maxY);
			   dcColor = Color.black;
			   
			   addGCSheet(entity);

			   Toolkit toolkit = Toolkit.getDefaultToolkit();
			   MediaTracker picTracker = new MediaTracker(this);
			   Image picImage = toolkit.getImage(rotateJPG);
			   picTracker.addImage(picImage,0);
			   try {picTracker.waitForID(0);} catch (InterruptedException e) {}
				if (picTracker.isErrorAny()) {
					TRACE("Error in loading image " + rotateJPG,4);
				}
			   
			   loadMode = DCLoadFromDB;
			   
			   normalCursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
			   handCursor = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);
			   crosshairCursor = Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR);
			   moveCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
			   waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			   nresizeCursor = Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR);
			   sresizeCursor = Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR);
			   eresizeCursor = Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR);
			   wresizeCursor = Cursor.getPredefinedCursor(Cursor.W_RESIZE_CURSOR);
			   neresizeCursor = Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR);
			   nwresizeCursor = Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR);
			   seresizeCursor = Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR);
			   swresizeCursor = Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR);
			   Toolkit tk = Toolkit.getDefaultToolkit();
			   rotateCursor = tk.createCustomCursor(picImage,new Point(0,0),"rotate");
			   
			   addMouseListener(this);
			   addMouseMotionListener(this);
			   addKeyListener(this);
			   add(dcMenu);
			   add(dcConnectorMenu);
			   //add(umlDiagram.getMenuUMLDI());
			   
			   colorPanel = new colorButtonCanvas();
			   colorPanel.colorButtonCanvas().addButtonCanvasListener(this);
			   controlPanel = new diControlCanvas();
			   controlPanel.diControlCanvas().addButtonCanvasListener(this);

			   statusPanel = new statusCanvas("Drawing Properties");
			   Vector props = new Vector();
			   props.addElement(new statusCanvasProp("Name",dcEntity));
			   props.addElement(new statusCanvasProp("SubName",dcSubEntity));
			   props.addElement(new statusCanvasProp("BackColor",getColorName(backgroundColor)));
			   props.addElement(new statusCanvasProp("Width",String.valueOf(dcStrokeWidth)));
			   props.addElement(new statusCanvasProp("XCord",String.valueOf(xCord)));
			   props.addElement(new statusCanvasProp("YCord",String.valueOf(yCord)));
			   props.addElement(new statusCanvasProp("Layer","Layer " + String.valueOf(dcLayer),layerMan.getLayerNames()));
			   props.addElement(new statusCanvasProp("ForeColor",getColorName(dcColor)));
			   props.addElement(new statusCanvasProp("Mode",optLabs[dcMode]));
			   String tmp = "False";
			   if (dcFilled) {tmp = "True";}
			   props.addElement(new statusCanvasProp("Filled",tmp));
			   statusPanel.setProps(props);
			   
			   dcThread = new Thread(new Runnable() {
				public void run() {
					while(dcThreadRunning) {
					   if (dcMultiUser) {
						try {
							readVirtualMsg();
							Thread.sleep(3000);
						} catch (Exception e) {;}
					   }
					}
				}
			   });
			   dcThreadRunning = true;
			   dcThread.setPriority(5);
			   dcThread.setName("Drawing canvas thread");
			   dcThread.start();
		   }
		   public void destroyDrawingCanvas() {
			   if (dcThreadRunning) {
				   dcThreadRunning = false;
			   }
				if (GCSheetsDialog != null) {
					GCSheetsDialog.destory();
					GCSheetsDialog.dispose();
				}
			   TRACE("Drawing Canvas Destroyed",4);
		   }
		   protected void finalize() throws Throwable {
			   destroyDrawingCanvas();
			   super.finalize();
		   }
		   public void saveAsXML(String filename) {
				xmlDataFile f = new xmlDataFile();
				f.openXMLDataFile(filename,"gcanvas");
				org.w3c.dom.Element root = f.getRootElement();
				org.w3c.dom.Document doc = f.getXMLDocument();
				for (int k=0;k<drawingItems.size();k++) {
				   drawingItem d = (drawingItem)drawingItems.elementAt(k);
				   d.getDrawingItemAsXML(doc,root);
				}
				// save connectors
				for (int i=0;i<connectors.size();i++) {
					drawingItemConnector c = (drawingItemConnector)connectors.elementAt(i);
					org.w3c.dom.Element setting = doc.createElement("connector");
					setting.setAttribute("start",c.getStart().getUnique());
					setting.setAttribute("end",c.getEnd().getUnique());
					setting.setAttribute("textstart",c.getTextStart());
					setting.setAttribute("textend",c.getTextEnd());
					setting.setAttribute("id",c.getID());
					setting.setAttribute("symstart",String.valueOf(c.getSymStart()));
					setting.setAttribute("symend",String.valueOf(c.getSymEnd()));
					setting.setAttribute("layer",String.valueOf(c.getLayer()));
					root.appendChild(setting);
				}
				f.closeXMLDataFile();
		   }
		   public void loadAsXML(String filename) {
				clearDrawingCanvas();
				xmlDataFile f = new xmlDataFile();
				f.openXMLDataFile(filename,"gcanvas");
				loading = true;
				NodeList nl = f.buildNodeList("drawingitem");
				for (int i=0;i<nl.getLength();i++) {
					org.w3c.dom.Node n = nl.item(i);
					String name = n.getNodeName();
					org.w3c.dom.Element e = (org.w3c.dom.Element)n;
					// got to get attributes in right order for code below to work !!!
					String nodeAttribs = "";
					nodeAttribs = e.getAttribute("type");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("name");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("originx");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("originy");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("color");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("fill");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("param1");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("param2");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("param3");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("unique");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("width");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("layer");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("param4");
					nodeAttribs = nodeAttribs + "," + e.getAttribute("rotangle");
						
				  Vector v1 = supportFunctions.splitIntoTokens(nodeAttribs);
  				  String[] tokens = new String[v1.size()];
				  v1.copyInto(tokens);
				  boolean fill = false;
				  if (tokens[5].equals("1")) {fill = true;}
				  drawingItem d = addDrawingItem(getEntity(),Integer.parseInt(tokens[0]),Integer.parseInt(tokens[2]),Integer.parseInt(tokens[3]),tokens[6],tokens[7],fill,getColorCode(tokens[4]));
				  d.setID(tokens[1]);
				  d.setUnique(tokens[9]);
				  d.setStrokeWidth(Integer.parseInt(tokens[10]));
				  d.setRotAngle(Integer.parseInt(tokens[13]));
				  d.setTransformBoundingBox(getDCBoundingRect());
				  int layer = Integer.parseInt(tokens[11]);
				  d.setLayer(layer);
				  if (layerMan.getLayer("Layer " + String.valueOf(layer)) == null) {
					layerMan.addNewLayer("Layer " + String.valueOf(layer));
				  }
				}
				// load connectors		
				NodeList n2 = f.buildNodeList("connector");
				for (int i=0;i<n2.getLength();i++) {
					org.w3c.dom.Node n = n2.item(i);
					String name = n.getNodeName();
					org.w3c.dom.Element e = (org.w3c.dom.Element)n;
					String startU = e.getAttribute("start");
					String endU = e.getAttribute("end");
					String textStart = e.getAttribute("textstart");
					String textEnd = e.getAttribute("textend");
					String id = e.getAttribute("id");
					String symStart = e.getAttribute("symstart");
					String symEnd = e.getAttribute("symend");
					int layer = Integer.parseInt(e.getAttribute("layer"));
					drawingItem start = getDIFromUnique(startU);
					drawingItem end = getDIFromUnique(endU);
					if (start != null && end != null) {
						createConnector(start,end,textStart,textEnd,id,Integer.parseInt(symStart),Integer.parseInt(symEnd),layer,false);
					} else {
						displayDialog("Invalid Connector");
					}
				}
				loading = false;
				dcNum = nl.getLength();
				f.closeXMLDataFile();
				paint();
		   }
		   
		  public void keyTyped(KeyEvent evt) {}	
		  public void keyReleased(KeyEvent evt) {}	
		  public void keyPressed(KeyEvent evt) {
			  doKeyPressed(evt);
		  }
		   public void drawConnectors(Graphics2D g2d) {
				g2d.setColor(Color.black); // connectors will always be drawn in black
				for (int i=0;i<connectors.size();i++) {
					drawingItemConnector c = (drawingItemConnector)connectors.elementAt(i);
					if (layerMan.layerDisplayed("Layer "+String.valueOf(c.getLayer()))) {c.drawConnector(g2d);}
				}
		   }
		   
		   public void setBackgroundColor(Color c) {backgroundColor = c;}
		   public Color getBackgroundColor() {return backgroundColor;}
		   public void setDisplayStatus(boolean b) {displayStatus = b;}
		   public boolean getDisplayStatus() {return displayStatus;}
		   public void setMultiUser(boolean b) {dcMultiUser = b;}
		   public boolean getMultiUser() {return dcMultiUser;}
		   public void setSubEntity(String s) {dcSubEntity = s;}
		   public String getSubEntity() {return dcSubEntity;}
		   public String getEntity() {return dcEntity;}
		   public void changeEntity(String s) {
				if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcDrawingItems SET sdcDIEntity='"+s+"' WHERE sdcDIEntity='"+dcEntity+"'","");}
				replaceGCSheet(s,dcEntity);
				dcEntity = s;
			}
		   public void setEntity(String s) {
				replaceGCSheet(s,dcEntity);
				dcEntity = s;
		   }
		   public boolean isMultipleSelected(drawingItem d) {
			   for (int i=0;i<selectedDrawingItems.size();i++) {
				   if (d == (drawingItem)selectedDrawingItems.elementAt(i)) {return true;}
			   }
			   return false;
		   }
		   public String getSelectedID() {
			   if (dcSelIndex == -1) {
				   return "None";
			   }
			   drawingItem d = (drawingItem)drawingItems.elementAt(dcSelIndex);
			   return d.getID();
		   }
		   
		   public void paint() {paint(getGraphics());}
		   public boolean doPaint(drawingItem d) {return true;}
		   public void paint(Graphics g) {
			   if (g == null) {return;} // getGraphics() called on a component not yet rendered will return null
			   Image offScreen = createImage(canvasMaxX,canvasMaxY);
			   Graphics offG = offScreen.getGraphics();
			  
			   Graphics2D g2d = (Graphics2D)offG;
			   
			   g2d.setColor(backgroundColor); // paint the backgound of the canvas
			   g2d.fillRect(0,0,canvasMaxX,canvasMaxY);
			   g2d.setColor(dcColor); // set back default DC color
			   
			   beforePainting(g2d);
			   
			   if (gridVisible) {
				   for (int i=0;i<canvasMaxX;i=i+gridSpaceX) {
					   for (int j=0;j<canvasMaxY;j=j+gridSpaceY) {
						   g2d.drawLine(i,j,i+1,j+1);
					   }
				   }
			   }
			   for (int k=0;k<drawingItems.size();k++) {
				   drawingItem d = (drawingItem)drawingItems.elementAt(k);
				   boolean focus = false;
				   if ((k == dcSelIndex || selectedDrawingItems.contains(d)) && !isPrinting()) {focus = true;}
				   focus = focus & getDrawFocusHandles();
				   checkRectBounds(d,d.getBoundingRect());
				   if (readonly) {focus = false;}
				   if (layerMan.layerDisplayed("Layer "+String.valueOf(d.getLayer()))) {if(doPaint(d)) {d.paint(g2d,focus);}}
			   }
			   
			   drawConnectors(g2d);
			   
			   if (dragBoundingBox) {
			    int xCordAdj = xCord;
				int yCordAdj = yCord;
			    if (xCordAdj < ptBoundingBox.x) {xCordAdj = ptBoundingBox.x;}
			    if (yCordAdj < ptBoundingBox.y) {yCordAdj = ptBoundingBox.y;}
			    int width = xCordAdj - ptBoundingBox.x;
				int height = yCordAdj - ptBoundingBox.y;
				g2d.drawRect(ptBoundingBox.x,ptBoundingBox.y,width,height);
				rcBoundingBox = new Rectangle(ptBoundingBox.x,ptBoundingBox.y,width,height);
			   }
			   
			   if (dcOutline) {
				  g2d.setStroke(new BasicStroke(1));
				  g2d.setColor(dcColor);
				  switch (dcMode) {
					  case dcTypeElispe:
					   	elispeDrawingItem di = new elispeDrawingItem();
					   	di.outlinePaint(g2d,dcLastX,dcLastY,xCord,yCord,dcFilled);
						break;
					  case dcTypeRect:
					   	rectDrawingItem di1 = new rectDrawingItem();
					   	di1.outlinePaint(g2d,dcLastX,dcLastY,xCord,yCord,dcFilled);
						break;
					   case dcTypeLine:
					   	lineDrawingItem di2 = new lineDrawingItem();
					   	di2.outlinePaint(g2d,dcLastX,dcLastY,xCord,yCord,dcFilled);
						break;
					   case dcTypeTextBox:
					    textboxDrawingItem di3 = new textboxDrawingItem();
						di3.outlinePaint(g2d,dcLastX,dcLastY,xCord,yCord,dcFilled);
					   break;
					   default:
					    customOutlineDrawingItem(g2d,dcMode);
				  }
			   }
			   
			   displayStatusText();
			   drawPictureFrame(g2d);
			   afterPainting(g2d);
			   if (bUpdateDC == true) {
				   Graphics2D g2dImage = (Graphics2D)g;
				   g2dImage.scale(fScalingFactor,fScalingFactor);
				   g2dImage.drawImage(offScreen,0,0,canvasMaxX,canvasMaxY,this);
				   currentCanvasImage=offScreen;
			   }
			   offG.dispose();
		   }
		   public void beforePainting(Graphics2D g2d) {;}
		   public void afterPainting(Graphics2D g2d) {;}

		   public void displayStatusText() {
			   updatePropTable();
		   }
		   public void propTableUpdated(String title,String propName,String propNewValue) {
				dcStrokeWidth = Integer.parseInt(statusPanel.getPropByName("Width"));
				if (propName.equals("Layer")) {
					dcLayer = Integer.parseInt(propNewValue.substring(6));
					TRACE("dcLayer:" + String.valueOf(dcLayer),4);
				}
		   }
		   public void updatePropTable() {
			   statusPanel.setPropByName("Name",dcEntity);
			   statusPanel.setPropByName("SubName",dcSubEntity);
			   statusPanel.setPropByName("Width",dcStrokeWidth);
			   statusPanel.setPropByName("XCord",xCord);
			   statusPanel.setPropByName("YCord",yCord);
			   statusPanel.setPropByName("Layer","Layer " + String.valueOf(dcLayer));
			   statusPanel.setPropByName("ForeColor",getColorName(dcColor));
			   statusPanel.setPropByName("BackColor",getColorName(backgroundColor));
			   statusPanel.setPropByName("Mode",optLabs[dcMode]);
			   String tmp = "False";
			   if (dcFilled) {tmp = "True";}
			   statusPanel.setPropByName("Filled",tmp);
		   }
		   
		   public void customOutlineDrawingItem(Graphics2D g2d,int type) {
		   }
		   
		   public void showToolWindows() {
			   colorPanel.colorButtonCanvasShow();
			   controlPanel.diControlCanvasShow();
			   statusPanel.statusCanvasShow();
			   statusPanel.getDialog().addStatusCanvasDialogListener(this);
			   statusPanel.setEnabledPropByName("Name",false);
			   statusPanel.setEnabledPropByName("SubName",false);
			   //statusPanel.setEnabledPropByName("Width",false);
			   statusPanel.setEnabledPropByName("XCord",false);
			   statusPanel.setEnabledPropByName("YCord",false);
			   //statusPanel.setEnabledPropByName("Layer",false);
			   statusPanel.setEnabledPropByName("Color",false);
			   statusPanel.setEnabledPropByName("Mode",false);
			   statusPanel.setEnabledPropByName("Filled",false);
		   }
		   public void hideToolWindows() {
			   colorPanel.colorButtonCanvasHide();
			   controlPanel.diControlCanvasHide();
			   statusPanel.statusCanvasHide();
		   }
		   public void refreshColorToolWindow() {
			   colorPanel.colorButtonCanvasHide();
			   colorPanel = new colorButtonCanvas();
			   colorPanel.colorButtonCanvas().addButtonCanvasListener(this);
			   colorPanel.colorButtonCanvasShow();
		   }
		   
		   public void focusDrawingItem(drawingItem d) {
			   dcSelIndex = drawingItems.indexOf(d);
			   selectedDrawingItems.addElement((drawingItem)drawingItems.elementAt(dcSelIndex));
		   }
		   
		   public void focusFirst() {
			   if (drawingItems.size() == 0) {
				   dcSelIndex = -1;
			   } else {
				   dcSelIndex = 0;
				   selectedDrawingItems.addElement((drawingItem)drawingItems.elementAt(dcSelIndex));
			   }
		   }
		   
		   public void focusNext() {
			   if (dcSelIndex == -1) {return;}
			   dcSelIndex++;
			   if (dcSelIndex > drawingItems.size()-1) {dcSelIndex = 0;}
			   selectedDrawingItems.addElement((drawingItem)drawingItems.elementAt(dcSelIndex));
		   }
		   
		   public void focusPrevious() {
			   if (dcSelIndex == -1) {return;}
			   dcSelIndex--;
			   if (dcSelIndex < 0) {dcSelIndex = drawingItems.size()-1;}
			   selectedDrawingItems.addElement((drawingItem)drawingItems.elementAt(dcSelIndex));
		   }
		   
		   public void clearDrawingCanvas() {			   
			   drawingItems.removeAllElements();
			   connectors.removeAllElements();
			   layerMan.removeAllLayers();
			   layerMan.addNewLayer(); // add default layer
			   dcSelIndex = -1;
			   dcLayer = 1;
			   dcStrokeWidth = 1;
			   dcColor = Color.black;
			   backgroundColor = Color.white;
			   connectors.removeAllElements();
			   selectedDrawingItems.removeAllElements();
			   clipboardDrawingItems.removeAllElements();
			   dcMode = dcTypeSelect;
			   bUpdateDC = true;
			   bVirtualMsgProcessing = false;
			   loadMode = DCLoadFromDB;
			   clipboardActive = false;
			   
			   if (dcMultiUser) {writeVirtualMsg(dcEntity,String.valueOf(DCRefresh),dcSubEntity,"");}
			   
			   paint(getGraphics());
		   }
		   
		   public void setGridVisible(boolean b) {gridVisible = b;}
		   public boolean getGridVisible() {return gridVisible;}
		   public int getGridSpaceX() {return gridSpaceX;}
		   public void setGridSpaceX(int i) {gridSpaceX = i;}
		   public int getGridSpaceY() {return gridSpaceY;}
		   public void setGridSpaceY(int i) {gridSpaceY = i;}
		   public drawingItemConnector getConnectorAtPoint(int x,int y) {
			   menuSelectedConnector = null;
			   for (int i=0;i<connectors.size();i++) {
				   drawingItemConnector c = (drawingItemConnector)connectors.elementAt(i);
				   if (c.hitTest(x,y)) {menuSelectedConnector = c;}
			   }
			   return menuSelectedConnector;
		   }
		   public boolean getDrawingItemAtPointFilter(drawingItem d) {
			   return true;
		   }
		   public Vector getDrawingItemAtPointInternal(int x,int y) {
			   Vector v = new Vector();
			   
			   for (int i=0;i<drawingItems.size();i++) {
				   drawingItem d = (drawingItem)drawingItems.elementAt(i);
				   if (d.hitTest(x,y)) {v.add(d);}
			   }
			   
			   return v;
		   }
		   public drawingItem getDrawingItemAtPoint(int x,int y) {
			   Vector v = getDrawingItemAtPointInternal(x,y);
			   for (int i=0;i<v.size();i++) {
				   drawingItem d = (drawingItem)v.elementAt(i);
				   if (getDrawingItemAtPointFilter(d)) {return d;}
			   }
			   return null;
		   }
		   public int getX() {return xCord;}
		   public int getY() {return yCord;}
		   public void record(int x,int y) {
			   dcLastX = x;
			   dcLastY = y;
		   }
		   public boolean printOverride(Graphics2D g2d) {return false;}
		// PrinterJob calls the print method to render the graphics
		// object, starting at pageIndex of 0
		// return PAGE_EXISTS if you have printed that page
		// return NO_SUCH_PAGE if there are no more pages left
		   public int print(Graphics g,PageFormat format,int pagenum) {
			   if (pagenum > 0) {return Printable.NO_SUCH_PAGE;}
			   Dimension size = new Dimension(dcMaxX,dcMaxY);
			   Graphics2D g2d = printPageSetup(g,format,size);
			   printing = true;
			   if (!printOverride(g2d)) {paint(g2d);}
			   printingOnly(g2d);
			   printing = false;
			   return Printable.PAGE_EXISTS;
		   }
		   public void printingOnly(Graphics2D g2d) {;}
		   public void setCanvasNumber(int i) {dcNum = i;}
		   public int getCanvasNumber() {return dcNum;}
		   public void update(Graphics g) {
			   paint(g);
		   }
		   public void dragHandleProcess(int x,int y,boolean bFinish) {
			int offsetX = 0;
			int offsetY = 0;
			Rectangle r_new;
			Rectangle r = dragFHDI.getTransformBoundingBox();
			
			switch (dragFH) {
				case 0:
					setCursor(nwresizeCursor);
					offsetX = (int)r.getX() - x;
					offsetY = (int)r.getY() - y;
					r_new = new Rectangle(x,y,(int)r.getWidth()+offsetX,(int)r.getHeight()+offsetY);
					break;
				case 1:
					setCursor(neresizeCursor);
					offsetX = x - ((int)r.getX()+(int)r.getWidth());
					offsetY = (int)r.getY() - y;
					r_new = new Rectangle((int)r.getX(),y,(int)r.getWidth()+offsetX,(int)r.getHeight()+offsetY);
					break;
				case 2:
					setCursor(swresizeCursor);
					offsetX = (int)r.getX() - x;
					offsetY = y - ((int)r.getY()+(int)r.getHeight());
					r_new = new Rectangle(x,(int)r.getY(),(int)r.getWidth()+offsetX,(int)r.getHeight()+offsetY);
					break;
				case 3:
					setCursor(seresizeCursor);
					offsetX = x - ((int)r.getX()+(int)r.getWidth());
					offsetY = y - ((int)r.getY()+(int)r.getHeight());
					r_new = new Rectangle((int)r.getX(),(int)r.getY(),(int)r.getWidth()+offsetX,(int)r.getHeight()+offsetY);
					break;
				case 4:
					setCursor(nresizeCursor);
					offsetY = (int)r.getY() - y;
					r_new = new Rectangle((int)r.getX(),y,(int)r.getWidth(),(int)r.getHeight()+offsetY);
					break;
				case 5:
					setCursor(sresizeCursor);
					offsetY = y - ((int)r.getY()+(int)r.getHeight());
					r_new = new Rectangle((int)r.getX(),(int)r.getY(),(int)r.getWidth(),(int)r.getHeight()+offsetY);
					break;
				case 6:
					setCursor(wresizeCursor);
					offsetX = (int)r.getX() - x;
					r_new = new Rectangle(x,(int)r.getY(),(int)r.getWidth()+offsetX,(int)r.getHeight());
					break;
				case 7:
					setCursor(eresizeCursor);
					offsetX = x - ((int)r.getX()+(int)r.getWidth());
					r_new = new Rectangle((int)r.getX(),(int)r.getY(),(int)r.getWidth()+offsetX,(int)r.getHeight());
					break;
				case 8:
					setCursor(rotateCursor);
					dragFHDI.setRotAngle(dragFHDI.getRotAngle() + (x - (int)r.getX()));
					dragFHDI.setTransformBoundingBox(getDCBoundingRect());
					//r_new = dragFHDI.getTransformBoundingBox();
					r_new = r; // drawing item is stored in the database as a un-rotated rectangle of 0 degrees
					break;
				default:
					r_new = r;
					break;
			}
			if (dragFH != 8) {dragFHDI.fitToRectangle(r_new);}
			if (bFinish) {
				dragFHDI.setTransformBoundingBox(getDCBoundingRect());
				if(dragFHDI instanceof imageDrawingItem || dragFHDI instanceof textDrawingItem) {
					if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIOriginX="+String.valueOf((int)r_new.getX())+",sdcDIOriginY="+String.valueOf((int)r_new.getY())+",sdcDIParam2='"+String.valueOf((int)r_new.getWidth())+","+String.valueOf((int)r_new.getHeight())+"',sdcDIRotAngle="+String.valueOf(dragFHDI.getRotAngle())+" WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+dragFHDI.getID()+"'","");}
				} else {
					if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIOriginX="+String.valueOf((int)r_new.getX())+",sdcDIOriginY="+String.valueOf((int)r_new.getY())+",sdcDIParam1='"+String.valueOf((int)r_new.getWidth())+"',sdcDIParam2='"+String.valueOf((int)r_new.getHeight())+"',sdcDIRotAngle="+String.valueOf(dragFHDI.getRotAngle())+" WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+dragFHDI.getID()+"'","");}
				}
				addUndoItem(dragFHDI.getUnique(),"Move",String.valueOf(dragFHDI.rcLastPos.x)+","+String.valueOf(dragFHDI.rcLastPos.y)+","+String.valueOf(dragFHDI.rcLastPos.width)+","+String.valueOf(dragFHDI.rcLastPos.height));
				dragFH = -1;
				dragFHDI = null;
				setCursor(normalCursor);
			}
			paint();
		   }
		   public void dragProcess(int x,int y,boolean bFinish) {
			  if (dragDI != null) {
				  setCursor(handCursor);
				  Vector items = new Vector();
				  if (isMultipleSelected(dragDI)) {
					  items = selectedDrawingItems;
				  } else {
					  items.addElement(dragDI);
				  }
				  
				  boolean bMultiple = true;
				  for (int i=0;i<items.size();i++) {
					if (i == items.size()-1) {bMultiple = false;}
					drawingItem d = (drawingItem)items.elementAt(i);
					Rectangle r = d.getTransformBoundingBox();
				  	d.fitToRectangle(new Rectangle(x-d.getOffsetX(),y-d.getOffsetY(),(int)r.getWidth(),(int)r.getHeight()));
				  	if (bFinish) {
						d.setTransformBoundingBox(getDCBoundingRect());
						addUndoItem(dragDI.getUnique(),"Move",String.valueOf(dragDI.rcLastPos.x)+","+String.valueOf(dragDI.rcLastPos.y)+","+String.valueOf(dragDI.rcLastPos.width)+","+String.valueOf(dragDI.rcLastPos.height),bMultiple);
					  	if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIOriginX="+String.valueOf(x-d.getOffsetX())+",sdcDIOriginY="+String.valueOf(y-d.getOffsetY())+" WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+d.getID()+"'","");}
				  	}
				  }
				  if (bFinish) {
					setCursor(normalCursor);
					dragDI = null;
				  }
				  paint();
			  }
		   }
		   public void mouseMoved(MouseEvent evt) {
			   xCord = evt.getX();
			   yCord = evt.getY();
			   drawingItem d = getDrawingItemAtPoint(xCord,yCord);
			   
			   if (d != null) {
				   int hoverFH = d.hitTestFocusHandles(xCord,yCord);
				   if (hoverFH != -1) {
						switch (hoverFH) {
						case 0:
							setCursor(nwresizeCursor);
							break;
						case 1:
							setCursor(neresizeCursor);
							break;
						case 2:
							setCursor(swresizeCursor);
							break;
						case 3:
							setCursor(seresizeCursor);
							break;
						case 4:
							setCursor(nresizeCursor);
							break;
						case 5:
							setCursor(sresizeCursor);
							break;
						case 6:
							setCursor(wresizeCursor);
							break;
						case 7:
							setCursor(wresizeCursor);
							break;
						case 8:
							setCursor(rotateCursor);
							break;
						}
						return;
				   }
			   }
			   setCursor(normalCursor);
			   if (target != null) {target.hoverAction(d,evt);}
			   paint();
		   }
		   public void mouseDragged(MouseEvent evt) {
			   if (readonly) {return;}
			   xCord = evt.getX();
			   yCord = evt.getY();
			   if (dragBoundingBox) {paint();return;}
			   if (dragFHDI != null) {dragHandleProcess(evt.getX(),evt.getY(),false);return;}
			   dragProcess(evt.getX(),evt.getY(),false);
			   paint();
		   }
		  public void stateChanged(ChangeEvent evt) {
		  }
		  public void mouseEntered(MouseEvent evt) {
			   xCord = evt.getX();
			   yCord = evt.getY();
			   paint();
		  }
		  public void mouseExited(MouseEvent evt) {
		  }	
		  public void mouseClicked(MouseEvent evt) {
				if (readonly) {return;}
				if (evt.getClickCount() == 2) {
					if (target != null) {if (target.canvasDoubleClickAction(evt)) {return;}}
				  	drawingItem d = getDrawingItemAtPoint(evt.getX(),evt.getY());
					if (d != null) {
						if (d.getType() == dcTypeSwitchGCSheet) {}
						if (target != null) {target.doubleClickAction(d,evt);}
					}
				}
		  }	
		  public void mousePressed(MouseEvent evt) {
			  int button=evt.getModifiers();
			  if ((button & MouseEvent.BUTTON3_MASK) != 0) {return;} // ignore right-button click
			  if (readonly) {return;}
    	      if (target != null) {if (target.canvasLeftClickAction(evt)) {return;}}

			  xCord = evt.getX();
			  yCord = evt.getY();
			  record(evt.getX(),evt.getY());
			  
			  for (int i=0;i<drawingItems.size();i++) {
				  drawingItem d = (drawingItem)drawingItems.elementAt(i);
				  Point org = d.getOrigin();
				  d.setOffsetX(evt.getX()-org.x); // used in dragProcess(...)
				  d.setOffsetY(evt.getY()-org.y);
			  }
			  
			  dcOutline = false;
			  drawingItem clickedOnDI = getDrawingItemAtPoint(evt.getX(),evt.getY());
			  if (clickedOnDI != null) {
				  dragFH = clickedOnDI.hitTestFocusHandles(evt.getX(),evt.getY());
				  if( dragFH != -1) {
					dragFHDI = clickedOnDI;
					dcMode = dcTypeSelect;
					return;
				  }
			  }

				switch(dcMode) {
				  case dcTypeSelect:  	
					if (clickedOnDI != null) {
						if (evt.isShiftDown()) {
							if (isMultipleSelected(clickedOnDI)) {
								selectedDrawingItems.remove(clickedOnDI);
							} else {
							    if (selectedDrawingItems.size() == 0) { // first multiple select item - do we need this now ??? (see e.g. FocusNext())
									drawingItem d1 = (drawingItem)drawingItems.elementAt(dcSelIndex);
									selectedDrawingItems.addElement(d1);
								}
								selectedDrawingItems.addElement(clickedOnDI);
								focusDrawingItem(clickedOnDI);
							}
							if (target != null) {target.leftClickSelectedAction(selectedDrawingItems,evt);}
							return;
						}
						
						clickedOnDI.rcLastPos = clickedOnDI.getTransformBoundingBox();
						dragDI = clickedOnDI;
						
						selectedDrawingItems.removeAllElements();
						focusDrawingItem(clickedOnDI);
					  
					} else {
						// clicked on empty part of canvas
						dragBoundingBox = true;
						ptBoundingBox = new Point(xCord,yCord);
					}
						if (target != null) {target.leftClickAction(clickedOnDI,evt);}						
					paint();
				   break;
				   case dcTypeText:
				   	String data = JOptionPane.showInputDialog(null,"Enter Text","Canvas - " + getEntity(),JOptionPane.QUESTION_MESSAGE);
					if (data != null) {
						addDrawingItem(dcEntity,dcTypeText,evt.getX(),evt.getY(),data,String.valueOf(charWidth*data.length())+","+String.valueOf(charHeight),false,dcColor);
					}
					break;
				   case dcTypeSwitchGCSheet:
					   	String data1 = JOptionPane.showInputDialog(null,"Enter GC Sheet Name","Canvas - " + getEntity(),JOptionPane.QUESTION_MESSAGE);
						if (data1 != null) {
							addDrawingItem(dcEntity,dcTypeSwitchGCSheet,evt.getX(),evt.getY(),data1,"",false,dcColor);
						}					   
					   break;
				   case dcTypeImage:
				   	data = fileOpenDialog("","");
					if (data != null) {
						addDrawingItem(dcEntity,dcTypeImage,evt.getX(),evt.getY(),data,String.valueOf(defaultImageWidth) + "," + String.valueOf(defaultImageHeight),false,dcColor);
					}
					break;
				    default:
				    	dcOutline = true;
					break;
			  }
		  }	
		  public Vector drawingItemsInRect(Rectangle r) {
			Vector v = new Vector();
			
			for (int i=0;i<drawingItems.size();i++) {
				drawingItem d = (drawingItem)drawingItems.elementAt(i);
				if(r.intersects(d.getTransformBoundingBox())) {
					v.addElement(d);
				}
			}
			
			return v;
		  }
		  public void mouseReleased(MouseEvent evt) {
			  menuSelectedDI = getDrawingItemAtPoint(evt.getX(),evt.getY());
			  menuSelectedConnector = getConnectorAtPoint(evt.getX(),evt.getY());
			  
			  if (evt.isPopupTrigger()) {
				  if (menuSelectedDI != null) { // Have we right-clicked on a drawing item?
					  if (target != null) {
						  if (isMultipleSelected(menuSelectedDI)) {
							  target.rightClickAction(selectedDrawingItems,evt);
						  } else {
							  Vector v = new Vector();
							  v.addElement(menuSelectedDI);
							  target.rightClickAction(v,evt);
						  }
					  }
					  return;
				  }
			  if (readonly) {return;}
				  if (menuSelectedConnector != null) {
				  	dcConnectorMenu.show(this,evt.getX(),evt.getY());
				  } else {
					customUpdateMenu(dcMenu);
					dcMenu.show(this,evt.getX(),evt.getY());
				  }

				  return;
			  }
     		  
			  if (dragBoundingBox) {
				Vector v = drawingItemsInRect(rcBoundingBox);
				if (v.size() == 0) {
					selectedDrawingItems.removeAllElements();
					focusFirst();					
				} else {
					focusDrawingItemsInBoundingBox(rcBoundingBox);
				}

				dragBoundingBox = false;
				rcBoundingBox = null;
				ptBoundingBox = null;
				return;
			  }
			  
			  if (dragFHDI != null) {dragHandleProcess(evt.getX(),evt.getY(),true);return;}
			  if (dragDI != null) {dragProcess(evt.getX(),evt.getY(),true);return;}
			  
			  if(dcMode == dcTypeTextBox) {
				   	String data = JOptionPane.showInputDialog(null,"Enter Text","Canvas - " + getEntity(),JOptionPane.QUESTION_MESSAGE);
					if (data != null) {
						addDrawingItem(getEntity(),dcTypeTextBox,evt.getX(),evt.getY(),data,"",false,dcColor);
					}
			  }
			  if (dcOutline == true && dcMode != dcTypeTextBox) {
				  addDrawingItem(getEntity(),dcMode,dcLastX,dcLastY,String.valueOf(evt.getX()),String.valueOf(evt.getY()),dcFilled,dcColor);
			  }
			  dcOutline = false;
		  }

		  public void focusDrawingItemsInBoundingBox(Rectangle box) {
			  selectedDrawingItems.removeAllElements();
			  for (int i=0;i<drawingItems.size();i++) {
				  drawingItem tmp = (drawingItem)drawingItems.elementAt(i);
				  if (box.intersects(tmp.getTransformBoundingBox())) {
					  selectedDrawingItems.addElement(tmp);
				  }
			  }
			  paint();
		  }
		  public void addUndoItem(String id,String cmd,String params) {
			addUndoItem(id,cmd,params,false);
		  }
		  public void addUndoItem(String id,String cmd,String params,boolean bMultiple) {
			TRACE("AUI: "+id+"#"+cmd+"#"+params+"#"+valueOf(bMultiple),4);
			undoDrawingItems.insertElementAt(id+"#"+cmd+"#"+params+"#"+valueOf(bMultiple),++undoIndex);
		  }
		  public void undo() {
			if (undoIndex > -1) {
				String tmp = (String)undoDrawingItems.elementAt(undoIndex);
				Vector v = supportFunctions.splitIntoTokens(tmp,"#");
				if (v.size() != 4) {return;}
				String id = (String)v.elementAt(0);
				String cmd = (String)v.elementAt(1);
				String params = (String)v.elementAt(2);
				boolean bMultiple = valueOf((String)v.elementAt(3));
				undoIndex--;
				drawingItem d = getDIFromUnique(id);
				doCommand(cmd,params,d);
				if (bMultiple) {
					undo();
				}
			} else {
				displayDialog("Nothing to Undo");
			}
  		  }
		  public void redo() {
			if (undoIndex < undoDrawingItems.size()-1) {
				String tmp = (String)undoDrawingItems.elementAt(undoIndex);
				Vector v = supportFunctions.splitIntoTokens(tmp,"#");
				if (v.size() != 4) {return;}
				String id = (String)v.elementAt(0);
				String cmd = (String)v.elementAt(1);
				String params = (String)v.elementAt(2);
				boolean bMultiple = valueOf((String)v.elementAt(3));
				undoIndex++;
				drawingItem d = getDIFromUnique(id);
				doCommand(cmd,params,d);
				if (bMultiple) {
					redo();
				}
			} else {
				displayDialog("Nothing to Redo");
			}
		  }
		  public void selectAll() {
			  selectedDrawingItems = drawingItems;
			  paint();
		  }
		  public void paste() {
			  clipboardActive = true;
			  for (int i=0;i<clipboardDrawingItems.size();i++) {
				  if (i == clipboardDrawingItems.size() - 1) {clipboardActive = false;}
				  drawingItem d = (drawingItem)clipboardDrawingItems.elementAt(i);
				  if (doPaste(d)) {pasteItem(d);}		
			  }
			  selectedDrawingItems = clipboardDrawingItems;
			  clipboardActive = false;
			  paint();
		  }
		  public boolean doPaste(drawingItem d) {return true;}
		  public void pasteItem(drawingItem d) {
			  Point pt = d.getOrigin();
			  pt.x = pt.x + 10;
			  pt.y = pt.y + 10;
			  addDrawingItem(dcEntity,d.getType(),pt.x,pt.y,d.getParam1(),d.getParam2(),d.getParam3(),d.getParam4(),d.getFilled(),d.getColor());
		  }
		  public void copy() {
			  clipboardDrawingItems = selectedDrawingItems;
		  }
		  public void cut() {
			  clipboardActive = true;
			  copy();
			  for (int i=0;i<clipboardDrawingItems.size();i++) {
				if (i == clipboardDrawingItems.size() - 1) {clipboardActive = false;}
				deleteDrawingItem((drawingItem)clipboardDrawingItems.elementAt(i));
			  }
			  clipboardActive = false;
			  selectedDrawingItems.removeAllElements();
			  focusFirst();
		  }
		  public void group(String id) {
			  for (int i=0;i<selectedDrawingItems.size();i++) {
				  drawingItem d = (drawingItem)selectedDrawingItems.elementAt(i);
				  d.setGroupID(id);
			  }
			  if (dcMultiUser) {writeVirtualMsg(dcEntity,String.valueOf(DCRefresh),dcSubEntity,"");}
			  paint();
		  }
		  public void ungroup(String id) {
			  for (int i=0;i<drawingItems.size();i++) {
				  drawingItem d = (drawingItem)drawingItems.elementAt(i);
				  String tmp = d.getGroupID();
				  if (tmp.equals(id)) {d.setGroupID("");}
			  }
			  if (dcMultiUser) {writeVirtualMsg(dcEntity,String.valueOf(DCRefresh),dcSubEntity,"");}
			  paint();
		  }
		  public void renameEntityNameInDB(String oldEntityName,String newEntityName) {
			if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcDrawingItems SET sdcDIEntity='" + newEntityName + "' WHERE sdcDIEntity='" + oldEntityName + "'","");}
		  }
		  public void deleteDCFromDB(String entity) {
			if (bUseDatabase) {systemMysql.executeSQLQuery("DELETE FROM sdcDrawingItems WHERE sdcDIEntity='" + entity + "'","");}
		  }
		   public Rectangle getTotalBoundingRect() {
			   Rectangle rc = new Rectangle(0,0,0,0);
			   for (int i=0;i<drawingItems.size();i++) {
				   drawingItem d = (drawingItem)drawingItems.elementAt(i);
				   Rectangle r = d.getBoundingRect();
				   rc = rc.union(r);
			   }
			   
			   return rc;
		   }
		  public void doKeyPressed(KeyEvent evt) {
			  if (readonly) {return;}
			  int mods = evt.getModifiers();
			  int keyCode = evt.getKeyCode();
			  boolean shiftDown = false;
			  boolean ctrlDown = false;
			  if ((mods & InputEvent.SHIFT_MASK) != 0) {shiftDown = true;}
			  if ((mods & InputEvent.CTRL_MASK) != 0) {ctrlDown = true;}
			  if (keyCode == KeyEvent.VK_DELETE) {
				  if (dcSelIndex == -1) {return;}
				  drawingItem d = (drawingItem)drawingItems.elementAt(dcSelIndex);
				  if (isMultipleSelected(d)) {
					  for (int i=0;i<selectedDrawingItems.size();i++) {
						  deleteDrawingItem((drawingItem)selectedDrawingItems.elementAt(i));
					  }
				  } else {
					  deleteDrawingItem(d);
				  }
				  
				  selectedDrawingItems.removeAllElements();
				  focusFirst();
			  }
			  if (keyCode == KeyEvent.VK_T && ctrlDown) {
				  displayTransTableEditor();
			  }
			  if (keyCode == KeyEvent.VK_S && ctrlDown) {
				  String s = currentShortTime().replace(':','_');
				  saveAsJPG(getDCBoundingRect(),"clip" + s + ".jpg");
			  }
			  if (keyCode == KeyEvent.VK_N && shiftDown) {
				  selectedDrawingItems.removeAllElements();
				  focusNext();
			  }
			  if (keyCode == KeyEvent.VK_P && shiftDown) {
				  selectedDrawingItems.removeAllElements();
				  focusPrevious();
			  }
			  if (keyCode == KeyEvent.VK_A && ctrlDown) {
				  selectAll();
			  }
			  if (keyCode == KeyEvent.VK_C && ctrlDown) {
				  copy();
			  }
			  if (keyCode == KeyEvent.VK_V && ctrlDown) {
				  paste();
			  }
			  if (keyCode == KeyEvent.VK_X && ctrlDown) {
				  cut();
			  }
			  if (keyCode == KeyEvent.VK_Z && ctrlDown) {
				  undo();
			  }
			  if (keyCode == KeyEvent.VK_Y && ctrlDown) {
				  redo();
			  }
			  if (keyCode == KeyEvent.VK_J && ctrlDown) {
				  zoomIn(defaultZoomStep);
			  }
			  if (keyCode == KeyEvent.VK_K && ctrlDown) {
				  zoomOut(defaultZoomStep);
			  }
			  if (keyCode == KeyEvent.VK_L && ctrlDown) {
				  zoomNormalise();
			  }
			  if (keyCode == KeyEvent.VK_R && ctrlDown) {
				  // CTRL-R is manual refresh key
				  // note: any key will refresh as paint() is always called at end of this function!!!
			  }
			  if (keyCode == KeyEvent.VK_G && ctrlDown) {
				  String data = JOptionPane.showInputDialog(null,"Enter Group Name","Canvas - " + getEntity(),JOptionPane.QUESTION_MESSAGE);
				  if (data != null) {group(data);}
			  }
			  if (keyCode == KeyEvent.VK_U && ctrlDown) {
				  if (dcSelIndex == -1) {displayDialog("Nothing To Ungroup");return;}
				  drawingItem d = (drawingItem)drawingItems.elementAt(dcSelIndex);
				  ungroup(d.getGroupID());
			  }
			  paint();
		  }
		  
		  // called when button is pressed on a control panel 
		  public void buttonPressed(ActionEvent evt) {
			   //JButton b = (JButton)evt.getSource();
			   //String cmd = b.getToolTipText();
			   //doCommand(cmd);
		  }
		  public void buttonRightClicked(MouseEvent evt) {
			   JButton b = (JButton)evt.getSource();
			   String cmd = b.getToolTipText();
			   TRACE("Button right clicked",4);
			   doCommand(cmd,"back");
		  }
		  public void buttonLeftClicked(MouseEvent evt) {
			   JButton b = (JButton)evt.getSource();
			   String cmd = b.getToolTipText();
			   TRACE("Button left clicked",4);
			   doCommand(cmd,"fore");
		  } 
		  public void buttonDoubleClicked(MouseEvent evt) {
			   JButton b = (JButton)evt.getSource();
			   String cmd = b.getToolTipText();
			   if (cmd.equalsIgnoreCase("customcolor1")) {setCustomColor1();}
			   if (cmd.equalsIgnoreCase("customcolor2")) {setCustomColor2();}
		  }
	  
		  public void actionPerformed(ActionEvent evt) {
			  String cmd = evt.getActionCommand();
			  doCommand(cmd);
		  }
			public void deleteConnector(drawingItemConnector conn) {
				systemMysql.executeSQLQuery("DELETE FROM sdcdrawingitems WHERE sdcDIName='"+conn.getID()+"'","");
				connectors.remove(conn);
			}
			public void doCommand(String cmd) {
			  drawingItem d = null;
			  if (dcMode == dcTypeSelect && dcSelIndex != -1) {
				d = (drawingItem)drawingItems.elementAt(dcSelIndex);
			  }
			  doCommand(cmd,"",d);
			}
			public void doCommand(String cmd,String params) {
			  drawingItem d = null;
			  if (dcMode == dcTypeSelect && dcSelIndex != -1) {
				d = (drawingItem)drawingItems.elementAt(dcSelIndex);
			  }
			  doCommand(cmd,params,d);
			}
		  public void doCommand(String cmd,String params,drawingItem d) {			  
			  Color c = getColorCode(cmd);
			  if (c != null) {
				
				if (params.equalsIgnoreCase("back")) {
					addUndoItem("abc",getColorName(backgroundColor),"back");
					backgroundColor = c;
				} else {				
				  if (d != null) {
					if (selectedDrawingItems.size() != 0) { // multiple selection
					  boolean bMultiple = true;
					  for (int i=0;i<selectedDrawingItems.size();i++) {
						  if (i == selectedDrawingItems.size()-1) {bMultiple = false;}
						  drawingItem d1 =(drawingItem)selectedDrawingItems.elementAt(i);
					      addUndoItem(d.getUnique(),getColorName(d.getColor()),"fore",bMultiple);
						  d1.setColor(c);
						  if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIColor='"+getColorName(c)+"' WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+d1.getID()+"'","");}
					  }
					} else { // single selection
					  addUndoItem(d.getUnique(),getColorName(d.getColor()),"fore");
					  d.setColor(c);
					  if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIColor='"+getColorName(c)+"' WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+d.getID()+"'","");}
					}
				  } else {
					dcColor = c;
				  }
				 }
			  }
			  if (cmd.equalsIgnoreCase("Grid")) {
				  gridVisible = !gridVisible;
			  }
			  if (cmd.equalsIgnoreCase("Fill")) {
				  dcFilled = !dcFilled;
				  if (d != null) {
					if (selectedDrawingItems.size() != 0) { // multiple selection
					  for (int i=0;i<selectedDrawingItems.size();i++) {
						  drawingItem d1 =(drawingItem)selectedDrawingItems.elementAt(i);
						  d1.setFilled(dcFilled);
						  if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIFilled="+valueOf(dcFilled)+" WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+d1.getID()+"'","");}
					  }
					 } else { // single selection
						d.setFilled(dcFilled);
						if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIFilled="+valueOf(dcFilled)+" WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+d.getID()+"'","");}
					 }
				  } 
			  }
			  if (cmd.equalsIgnoreCase("Select")) {
				  dcMode = dcTypeSelect;
			  }
			  if (cmd.equalsIgnoreCase("Line")) {
				  dcMode = dcTypeLine;
			  }
			  if (cmd.equalsIgnoreCase("Rectangle")) {
				  dcMode = dcTypeRect;
			  }
			  if (cmd.equalsIgnoreCase("TextBox")) {
					dcMode = dcTypeTextBox;
			  }
			  if (cmd.equalsIgnoreCase("Elipse")) {
				  dcMode = dcTypeElispe;
			  }
			  if (cmd.equalsIgnoreCase("Image")) {
				  dcMode = dcTypeImage;
			  }
			  if (cmd.equalsIgnoreCase("Text")) {
				  dcMode = dcTypeText;
			  }
			  if (cmd.equalsIgnoreCase("Delete Connector")) {
				if (menuSelectedConnector != null) {
					deleteConnector(menuSelectedConnector);
					selectedDrawingItems.removeAllElements();
					focusFirst();
				}
			  }
			  if (cmd.equalsIgnoreCase("Connector Properties")) {
				if (menuSelectedConnector != null) {
					connectorPropsDialog d1 = new connectorPropsDialog(getTopLevelParent(this),menuSelectedConnector);
					if (d1.isOK()) {
						menuSelectedConnector.setTextStart(d1.getTextStart());
						menuSelectedConnector.setTextEnd(d1.getTextEnd());
						systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIParam3='" + d1.getTextStart()+","+d1.getTextEnd() + "' WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+menuSelectedConnector.getID()+"'","");
					} 
					d1.dispose();
				}
			  }
			  if (cmd.equalsIgnoreCase("Properties")) {
				if (selectedDrawingItems.size() == 0 && dcSelIndex != -1) {
					drawingItem d1 = (drawingItem)drawingItems.elementAt(dcSelIndex);
					d1.showPropsDialog(getEntity());
				} else {
					displayDialog("Select only one drawing item");
				}
			  }
			  if (cmd.equalsIgnoreCase("Print")) {
				printCanvas();
			  }
			  if (cmd.equalsIgnoreCase("Clear")) {
					if (JOptionPane.showConfirmDialog(null,"Clear drawing canvas","Canvas - " + getEntity(),JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
						clearDrawingCanvas();
						deleteDCFromDB(dcEntity);
					}
			  }
			  if (cmd.equalsIgnoreCase("Add Connector")) {
					if (selectedDrawingItems.size() == 2) {
						String textStart = JOptionPane.showInputDialog(null,"Enter Connector Start Label","Canvas - " + getEntity(),JOptionPane.QUESTION_MESSAGE);
						String textEnd = JOptionPane.showInputDialog(null,"Enter Connector End Label","Canvas - " + getEntity(),JOptionPane.QUESTION_MESSAGE);
						if (textStart != null && textEnd != null) 	{
							String 	id = getEntity()+ "-" + getSubEntity() + "-" + String.valueOf(dcNum++);
createConnector((drawingItem)selectedDrawingItems.elementAt(0),(drawingItem)selectedDrawingItems.elementAt(1),textStart,textEnd,id,0,0,dcLayer,true);
							//displayDialog("Add Connector:Added");
						}
					} else {
						displayDialog("Add Connector: Select 2 Items To Connect");
					}
			  }
			  if (cmd.equalsIgnoreCase("Virtual Message")) {
				  String text = JOptionPane.showInputDialog(null,"Enter Message","Canvas - " + getEntity(),JOptionPane.QUESTION_MESSAGE);
				  if (text != null) {
					  if (dcMultiUser) {writeVirtualMsg(dcEntity,String.valueOf(DCMsg),dcSubEntity,text);}
				  }
			  }
			  if (cmd.equalsIgnoreCase("Delete")) {
				deleteDrawingItem(d);
			  }
			  if (cmd.equalsIgnoreCase("Move")) {
				moveDrawingItem(d,params);
			  }
			  if (cmd.equalsIgnoreCase("Add")) {
				Vector v = supportFunctions.splitIntoTokens(params,",");
				d = addDrawingItem((String)v.elementAt(0),
						Integer.parseInt((String)v.elementAt(1)),
						Integer.parseInt((String)v.elementAt(2)),
						Integer.parseInt((String)v.elementAt(3)),
						(String)v.elementAt(4),
						(String)v.elementAt(5),
						(String)v.elementAt(6),
						(String)v.elementAt(7),
						valueOf((String)v.elementAt(8)),
						getColorCode((String)v.elementAt(9)));
			  }
			  if (cmd.equalsIgnoreCase("Width")) {
				dcStrokeWidth = getPropValue("Get Stroke Width","Stroke Width",dcStrokeWidth);
				displayStatusText();
			  }
			  if (cmd.equalsIgnoreCase("Copy")) {
				copy();
			  }
			  if (cmd.equalsIgnoreCase("Cut")) {
				cut();
			  }
			  if (cmd.equalsIgnoreCase("Paste")) {
				paste();
			  }
			  if (cmd.equalsIgnoreCase("Undo")) {
				undo();
			  }
			  if (cmd.equalsIgnoreCase("Redo")) {
				redo();
			  }
			  if (cmd.equalsIgnoreCase("Switch GC Sheet")) {
				GCSheetsDialog = displayPanelDialog(createGCSheetPanel(),"Switch GC Sheet");
			  }
			  if (cmd.equalsIgnoreCase("Layers")) {
				layerDialog layerDialog1 = new layerDialog(null,layerMan);
				String[] newOpts = layerMan.getLayerNames();
				statusPanel.setComboOptsByName("Layer",newOpts);
			  }
			  
			  if (target != null) {target.customDoCommand(cmd,params,d);}

			  paint();
		  }
		  
		  public JPanel createGCSheetPanel() {
				JPanel p = new JPanel();
				p.setLayout(new BoxLayout(p,BoxLayout.Y_AXIS));			
				p.add(new JLabel("Defined GC Sheets",JLabel.CENTER));
				String[] sheets = getGCSheets();
				GCSheets = new JList(sheets);
				GCSheets.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
				GCSheets.setVisibleRowCount(5);
				for (int i=0;i<sheets.length;i++) {
					if (sheets[i].equals(getEntity())) {GCSheets.setSelectedIndex(i);break;}
				}
				GCSheets.addListSelectionListener(this);
				JScrollPane pane = new JScrollPane(GCSheets);
				p.add(pane);
				
				return p;
		  }
		  public void valueChanged(ListSelectionEvent evt) {
			if (!evt.getValueIsAdjusting()) {
				String GCSheet = (String)GCSheets.getSelectedValue();
				switchGCSheet(GCSheet);
			}
		}
		  public void moveDrawingItem(drawingItem d,String params) {
			Vector v = supportFunctions.splitIntoTokens(params,",");
			Rectangle r_new = new Rectangle(Integer.parseInt((String)v.elementAt(0)),
				Integer.parseInt((String)v.elementAt(1)),
				Integer.parseInt((String)v.elementAt(2)),
				Integer.parseInt((String)v.elementAt(3)));
			d.fitToRectangle(r_new);
			if(d instanceof imageDrawingItem) {
				if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIOriginX="+String.valueOf((int)r_new.getX())+",sdcDIOriginY="+String.valueOf((int)r_new.getY())+",sdcDIParam2='"+String.valueOf((int)r_new.getWidth())+","+String.valueOf((int)r_new.getHeight())+"' WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+d.getID()+"'","");}
			} else {
				if (bUseDatabase) {systemMysql.executeSQLQuery("UPDATE sdcdrawingitems SET sdcDIOriginX="+String.valueOf((int)r_new.getX())+",sdcDIOriginY="+String.valueOf((int)r_new.getY())+",sdcDIParam1='"+String.valueOf((int)r_new.getWidth())+"',sdcDIParam2='"+String.valueOf((int)r_new.getHeight())+"' WHERE sdcDIEntity='"+getEntity()+"' AND sdcDIName='"+d.getID()+"'","");}
			}
		  }
		  public boolean isLoading() {return loading;}
		  public boolean isPrinting() {return printing;}
		  public drawingItem addDrawingItem(String entity,int type,int x,int y,String p1,String p2,boolean fill,Color c) {
			return addDrawingItem(entity,type,x,y,p1,p2,"","",fill,c);
		  }
		  public int countDrawingItemsOfType(int type) {
			return getDrawingItemsOfType(type).size();
		  }
		  public Vector getDrawingItemsOfType(int type) {
			Vector v = new Vector();
			
			for (int i=0;i<drawingItems.size();i++) {
				drawingItem d = (drawingItem)drawingItems.elementAt(i);
				if (d.getType() == type) {v.addElement(d);}
			}
			return v;
		  }
		  public drawingItem addDrawingItem(String entity,int type,int x,int y,String p1,String p2,String p3,String p4,boolean fill,Color c) {
			  String id;
			  if(!isLoading()) {
				id = getEntity()+ "-" + getSubEntity() + "-" + String.valueOf(dcNum++);
			  } else {
				id = ""; // we overwrite this value in loadDrawingItems(...)
			  }
			  drawingItem d = null;
			  
			  switch (type) {
				  case dcTypeTextBox:
					d = new textboxDrawingItem(id,x,y,p1,p2,fill,c);
				    break;
				  case dcTypeRect:
				  	d = new rectDrawingItem(id,x,y,p1,p2,fill,c);
					break;
				  case dcTypeLine:
				  	d = new lineDrawingItem(id,x,y,p1,p2,fill,c);
					break;
				  case dcTypeImage:
				  	d = new imageDrawingItem(id,x,y,p1,p2,fill,c);
					break;
				  case dcTypeText:
				  	d = new textDrawingItem(id,x,y,p1,p2,fill,c);
					break;
				  case dcTypeElispe:
				  	d = new elispeDrawingItem(id,x,y,p1,p2,fill,c);
					break;
					
				  default:
					d = createCustomDrawingItem(entity,type,id,x,y,p1,p2,p3,p4,fill,c);
					break;
			  }
			  
			  if (d == null) {return (drawingItem)null;}
			  
			  d.setStrokeWidth(dcStrokeWidth);
			  d.setLayer(dcLayer);
			  drawingItems.addElement(d);
			  dcSelIndex = drawingItems.size() - 1;
			  d.setRotAngle(0);
			  d.setTransformBoundingBox(getDCBoundingRect());
			  if(!isLoading()) {
				  d.setUnique(getUniqueID());
				  if (bUseDatabase) {systemMysql.executeSQLQuery("INSERT INTO sdcdrawingitems (sdcDIID,sdcDIEntity,sdcDIType,sdcDIName,sdcDIOriginX,sdcDIOriginY,sdcDIParam1,sdcDIParam2,sdcDIParam3,sdcDIParam4,sdcDIFilled,sdcDIColor,sdcDIUnique,sdcDIStrokeWidth,sdcDILayer,sdcDIRotAngle) VALUES (null,'"+entity+"',"+String.valueOf(type)+",'"+id+"',"+String.valueOf(x)+","+String.valueOf(y)+",'"+p1+"','"+p2+"','"+p3+"','"+p4+"',"+valueOf(fill)+",'"+getColorName(c)+"','"+d.getUnique()+"',"+String.valueOf(dcStrokeWidth)+","+String.valueOf(dcLayer)+",0)","");}
				  // notify users of this drawing canvas that it has changed
				  if (dcMultiUser) {writeVirtualMsg(dcEntity,String.valueOf(DCRefresh),dcSubEntity,"");}
				  if (!stickyTools) {dcMode = dcTypeSelect;}
				  addUndoItem(d.getUnique(),"Delete","",isClipboardActive());
				  paint();
			  }
			  
			  return d;
		  }	  
		  public void setMode(int m) {dcMode = m;}
		  public int getMode() {return dcMode;}
		  public void setColor(Color c) {dcColor = c;}
		  public Color getColor() {return dcColor;}
		  public void deleteDrawingItem(drawingItem d) {
			  if (d.canDelete()) {
			  d.delete();
			  // remove any connectors attached to drawingItem 'd'
			  for (int i=0;i<connectors.size();i++) {
				drawingItemConnector c = (drawingItemConnector)connectors.elementAt(i);
				if (c.getStart() == d || c.getEnd() == d) {
					deleteConnector(c);
				}
			  }
			  if (bUseDatabase) {systemMysql.executeSQLQuery("DELETE FROM sdcdrawingitems WHERE sdcDIName='"+d.getID()+"'","");}
			  addUndoItem("abc","Add",d.getParams(getEntity()),isClipboardActive());
			  drawingItems.remove(d);
			  } else {
				  displayDialog("Application denied delete request.");
			  }
		  }
		  public drawingItem getDIFromUnique(String u) {
			for (int i=0;i<drawingItems.size();i++) {
				drawingItem d = (drawingItem)drawingItems.elementAt(i);
				String tmp = d.getUnique();
				if (tmp.equals(u)) {return d;}
			}
		  
			return (drawingItem)null;
		  }
		  public void loadDrawingItems() {
			  loading = true;
			  clearDrawingCanvas();
			  
			  String ids = systemMysql.executeSQLQuery("SELECT sdcDIID FROM sdcdrawingitems WHERE sdcDIEntity='"+getEntity()+"'","");
			  if (ids.length() == 0) {return;}
			  Vector v = supportFunctions.splitIntoTokens(ids);
			  for(int i=0;i<v.size();i++) {
				  String data = systemMysql.executeSQLQuery("SELECT sdcDIType,sdcDIName,sdcDIOriginX,sdcDIOriginY,sdcDIColor,sdcDIFilled,sdcDIParam1,sdcDIParam2,sdcDIParam3,sdcDIUnique,sdcDIStrokeWidth,sdcDILayer,sdcDIParam4,sdcDIRotAngle FROM sdcdrawingitems WHERE sdcDIID="+(String)v.elementAt(i),"");
				  Vector v1 = supportFunctions.splitIntoTokens(data);
  				  String[] tokens = new String[v1.size()];
				  v1.copyInto(tokens);
				  boolean fill = false;
				  if (tokens[5].equals("1")) {fill = true;}
				  if (Integer.parseInt(tokens[0]) == dcTypeConnector) {
					drawingItem start = getDIFromUnique(tokens[6]);
					drawingItem end = getDIFromUnique(tokens[7]);
					if (start != null && end != null) {
						Vector labels = supportFunctions.splitIntoTokens(tokens[8]);
						Vector symbols = supportFunctions.splitIntoTokens(tokens[12]);
						createConnector(start,end,(String)labels.elementAt(0),(String)labels.elementAt(1),tokens[1],Integer.parseInt((String)symbols.elementAt(0)),Integer.parseInt((String)symbols.elementAt(1)),Integer.parseInt(tokens[11]),false);
					} else {
						displayDialog("Invalid Connector");
					}
				  } else {
					drawingItem d = addDrawingItem(getEntity(),Integer.parseInt(tokens[0]),Integer.parseInt(tokens[2]),Integer.parseInt(tokens[3]),tokens[6],tokens[7],fill,getColorCode(tokens[4]));
					d.setID(tokens[1]);
					d.setUnique(tokens[9]);
					d.setStrokeWidth(Integer.parseInt(tokens[10]));
					d.setRotAngle(Integer.parseInt(tokens[13]));
					d.setTransformBoundingBox(getDCBoundingRect());
					int layer = Integer.parseInt(tokens[11]);
					d.setLayer(layer);
					if (layerMan.getLayer("Layer " + String.valueOf(layer)) == null) {
					layerMan.addNewLayer("Layer " + String.valueOf(layer));
					}
				}
			  }
			  dcNum = v.size();
			  loading = false;
			  paint();
		  }
		  public void saveDrawingItems() {}
		  public void createMenu() {
			  dcConnectorMenu = new PopupMenu("Connector_Menu");
			  MenuItem item = new MenuItem("Delete Connector");
			  item.addActionListener(this);
			  dcConnectorMenu.add(item);
			  item = new MenuItem("Connector Properties");
			  item.addActionListener(this);
			  dcConnectorMenu.add(item);


			  dcMenu = new PopupMenu("Drawing_Canvas");
			  item = new MenuItem("Cut");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  item = new MenuItem("Copy");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  item = new MenuItem("Paste");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  dcMenu.addSeparator();
			  item = new MenuItem("Undo");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  item = new MenuItem("Redo");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  dcMenu.addSeparator();
				
				cbPictureFrame = new CheckboxMenuItem("Show Picture Frame",false);
				cbPictureFrame.addItemListener(this);
				dcMenu.add(cbPictureFrame);
				dcMenu.addSeparator();
				//item = new MenuItem("Add GC Sheet");
				//item.addActionListener(this);
				//dcMenu.add(item);
				//item = new MenuItem("Delete GC Sheet");
				//item.addActionListener(this);
				//dcMenu.add(item);
				item = new MenuItem("Switch GC Sheet");
				item.addActionListener(this);
				dcMenu.add(item);
				dcMenu.addSeparator();
			  
			  item = new MenuItem("Layers");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  item = new MenuItem("Add Connector");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  item = new MenuItem("Virtual Message");
			  item.addActionListener(this);
			  dcMenu.add(item);
			  dcMenu = customCreateMenu(dcMenu);
		  }
		  public PopupMenu customCreateMenu(PopupMenu menu) {
				int count = menu.getItemCount();
				for (int i=0;i<count;i++) {
					MenuItem mi = menu.getItem(i);
					//String label = mi.getLabel();
				}
				return menu;
		  }
		  public void customUpdateMenu(PopupMenu menu) {
			getMenuItem(menu,"Paste").setEnabled(clipboardDrawingItems.size() != 0);
			getMenuItem(menu,"Cut").setEnabled(selectedDrawingItems.size() != 0);
			getMenuItem(menu,"Copy").setEnabled(selectedDrawingItems.size() != 0);
			getMenuItem(menu,"Undo").setEnabled(undoIndex > -1);
			getMenuItem(menu,"Redo").setEnabled(undoIndex > undoDrawingItems.size() - 1);
			cbPictureFrame.setState(bDrawPictureFrame);		  
		  }
		  public void itemStateChanged(ItemEvent evt) {
			  if (evt.getSource() == cbPictureFrame) {
				  TRACE("Changed show picture frame state",4);
				  bDrawPictureFrame = cbPictureFrame.getState();
			  }
			  if (evt.getSource() == cbItem) {
				  dcFilled = cbItem.getState();
			  }
			  if (evt.getSource() == cbGrid) {
				  gridVisible = cbGrid.getState();
			  }
			  paint();
		  }
		  public void writeVirtualMsg(String entity,String type,String p1,String p2) {
			  //if (systemUserReg.getUseDatabase()) {
				  systemMysql.executeSQLQuery("INSERT INTO sysehsmsg (sysEHSMsgID,sysEHSMsgEntity,sysEHSMsgType,sysEHSMsgParam1,sysEHSMsgParam2) VALUES (null,'"+entity+"','"+type+"','"+p1+"','"+p2+"')","");
			  //}
		  }
		  public String readVirtualMsg() { // called by the DC thread every few seconds for a multi user canvas
			  String msg = "";
			  if (bVirtualMsgProcessing) {return msg;}
			  //if (systemUserReg.getUseDatabase()) {
				  msg = systemMysql.executeSQLQuery("SELECT sysEHSMsgID,sysEHSMsgEntity,sysEHSMsgType,sysEHSMsgParam1,sysEHSMsgParam2 FROM sysehsmsg WHERE sysEHSMsgEntity='"+getEntity()+"' AND sysEHSMsgID>"+String.valueOf(dcLastMsgID)+" LIMIT 1","");
			  //} 
			  if (msg.length() == 0) {return msg;}
			  
			  TRACE("Read Virtual Msg: "+msg,4);
			  Vector v = supportFunctions.splitIntoTokens(msg);
			  String[] tokens = new String[v.size()];
			  v.copyInto(tokens);
			  dcLastMsgID = Integer.parseInt(tokens[0]);
			  processVirtualMsg(tokens[1],tokens[2],tokens[3],tokens[4]);
			  return msg;
		  }
		 public void processCustomVirtualMsg(String entity,String msgType,String param1,String param2) {
			int msgID = Integer.parseInt(msgType);
			switch (msgID) {
				case DCRefresh:
					//loadDrawingItems();
					break;
				}
		 }
		  public void processVirtualMsg(String entity,String msgType,String param1,String param2) {
			TRACE("Process Virtual Msg: E="+entity+", Type="+msgType+", P1="+param1+", P2="+param2,4);
			if (param1.equals(dcSubEntity)) { // ignore our own virtual messages
 				TRACE("Ignored own virtual msg",4);
				return;
			} 
			boolean bProcessed = false;
			bVirtualMsgProcessing = true;
			int msgID = Integer.parseInt(msgType);
				switch (msgID) {
					case DCMsg:
						displayHTMLPanel("<html><body><center><font size='+1'>"+param2+"</font></center></body></html>");
						bProcessed = true;
						break;
				}
			
			if (!bProcessed) {
				processCustomVirtualMsg(entity,msgType,param1,param2);
			}			
			bVirtualMsgProcessing = false;
		}
	}

	
	public class HDLDrawingItemPort {
		public String	name;
		public String   type;
		public String	mode;
		public Point	ptPort;
		
		public HDLDrawingItemPort() {}
		public HDLDrawingItemPort(String name,String mode,String type) {
			this.name = name;
			this.type = type;
			this.mode = mode;
			ptPort = null;
		}
	}
	public class HDLDrawingItem extends drawingItem {
		private	Rectangle		boundingRect;
		private	int				umlDIWidth = 100;
		private	int				umlDIHeight = 100;
		private	Vector 			ports = new Vector();
		private int				iLevel;
		private	String			path;
		private	String 			entity;

		public HDLDrawingItem() {}
		public HDLDrawingItem(String id,int orgX,int orgY,String p1,String p2,String p3,String p4,boolean fill,Color c) {
			super(dcTypeHDL,id,orgX,orgY,p1,p2,p3,p4,fill,c);

			iLevel = -1;
			iSheet = 1;
			boundingRect = new Rectangle(orgX,orgY,umlDIWidth,umlDIHeight);
			
			setEntity(p1);
			Vector v = supportFunctions.splitIntoTokens(p2,";");
			for (int i=0;i<v.size();i++) {
				String tmp = (String)v.elementAt(i);
				Vector v1 = supportFunctions.splitIntoTokens(tmp,",");
				ports.addElement(new HDLDrawingItemPort((String)v1.elementAt(0),(String)v1.elementAt(1),(String)v1.elementAt(2)));
			}
			setPath(p3);
			
			processHDLPorts(); // calculation positions of HDL ports on HDL drawing item
		}
		public Point getHDLPortPoint(String name) {
			for (int i=0;i<ports.size();i++) {
				HDLDrawingItemPort port = (HDLDrawingItemPort)ports.elementAt(i);
				if (port.name.equals(name)) {return port.ptPort;}
			}
			
			return (Point)null;
		}
		public void processHDLPorts() {
			Rectangle r = getBoundingRect();
			int inYCord = r.y + (3 * charWidth);
			int outYCord = r.y + (4 * charWidth);
			int xCord = 0;
			for (int i=0;i<ports.size();i++) {
				HDLDrawingItemPort port = (HDLDrawingItemPort)ports.elementAt(i);
				if (port.mode.equals("in")) {
					xCord = r.x + 3;
					port.ptPort = new Point(xCord,inYCord);
					inYCord = inYCord + (2 * charWidth);
				} else {
					xCord = r.x + r.width;
					port.ptPort = new Point(xCord,outYCord);
					outYCord = outYCord + (2 * charWidth);
				}
			}
		}
		public Vector getPorts() {return ports;}
		public String getEntity() {return entity;}
		public void setEntity(String s) {entity = s;}
		public String getPath() {return path;}
		public void setPath(String s) {path = s;}
		public int getLevel() {return iLevel;}
		public void setLevel(int i) {iLevel = i;}
		public String getUserDefinedName() {return entity;}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
			// do nothing here as UML drawing item is of a fixed size
		}
		public void paint(Graphics2D g2d,boolean focus) {
			setupPaint(g2d,focus);
			g2d.setColor(Color.green);
			g2d.fillRect((int)boundingRect.getX(),(int)boundingRect.getY(),(int)boundingRect.getWidth(),(int)boundingRect.getHeight());
			boxCenterText(g2d,Color.green,getUserDefinedName(),(int)boundingRect.getX(),(int)boundingRect.getY(),(int)boundingRect.getWidth(),1 * charHeight,false);
			g2d.setColor(Color.black);
			for (int i=0;i<ports.size();i++) {
				HDLDrawingItemPort port = (HDLDrawingItemPort)ports.elementAt(i);
				if (port.mode.equals("in")) {
					g2d.drawString(port.name,port.ptPort.x,port.ptPort.y);
				} else {
					g2d.drawString(port.name,port.ptPort.x-(charWidth * port.name.length()),port.ptPort.y);
				}
			}
			teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			// do nothing here as UML drawing item is of a fixed size
		}
		public Rectangle getBoundingRect() {
			  return boundingRect;
		}
		public void moveTo(Point p) {
			Point ptOldOrgin = getOrigin();
			setOrigin(p);
			boundingRect = new Rectangle(diOriginX,diOriginY,boundingRect.width,boundingRect.height);
			setTransformBoundingBox(new Rectangle(0,0,dcMaxX,dcMaxY));
			for (int i=0;i<ports.size();i++) {
				HDLDrawingItemPort port = (HDLDrawingItemPort)ports.elementAt(i);
				Point ptOrg = port.ptPort;
				port.ptPort = new Point((p.x - ptOldOrgin.x) + ptOrg.x,(p.y - ptOldOrgin.y) + ptOrg.y);
			}
		}
	}
	public class HDLConnDrawingItem extends drawingItem {
		private	Rectangle		boundingRect;
		private	String			connEntity;
		private String 			connPort;
		private String			connList;
		private String 			connName;
		
		public HDLConnDrawingItem() {}
		public HDLConnDrawingItem(String id,int orgX,int orgY,String p1,String p2,String p3,String p4,boolean fill,Color c) {
			super(dcTypeHDLConn,id,orgX,orgY,p1,p2,p3,p4,fill,c);

			connName = p1;
			connEntity = p2;
			connPort = p3;
			connList = p4;
			
			setUserDefinedName(connName);
			boundingRect = new Rectangle(orgX,orgY,4*charWidth,2*charWidth);
		}
		public String getPortNetList() {return connList;}
		public String getUserDefinedName() {return connName;}
		public String getEntity() {return connEntity; }
		public String getPort() {return connPort;}
		public String getName() {return connName;}
		public void outlinePaint(Graphics2D g2d,int dcLastX,int dcLastY,int xCord,int yCord,boolean dcFilled) {
			// do nothing here as UML drawing item is of a fixed size
		}
		public void paint(Graphics2D g2d,boolean focus) {
			setupPaint(g2d,focus);
			Rectangle r = getBoundingRect();
			g2d.drawOval(r.x,r.y,2*charWidth,2*charWidth);
			g2d.drawLine(r.x+(2*charWidth),r.y+charWidth,r.x+(4*charWidth),r.y+charWidth);
			teardownPaint(g2d,focus);
		}
		public void fitToRectangle(Rectangle r) {
			// do nothing here as UML drawing item is of a fixed size
		}
		public Rectangle getBoundingRect() {
			  return boundingRect;
		}
		public void moveTo(Point p) {
			setOrigin(p);
			boundingRect = new Rectangle(diOriginX,diOriginY,boundingRect.width,boundingRect.height);
			setTransformBoundingBox(new Rectangle(0,0,dcMaxX,dcMaxY));
		}
	}
	public class HDLDrawingCanvas extends drawingCanvas {
		   public HDLDrawingCanvas(String entity,int maxX,int maxY,int spaceX,int spaceY,boolean gVisible) {
			   super(entity,maxX,maxY,spaceX,spaceY,gVisible);
		   }
		   public void beforePainting(Graphics2D g2d) {;}
		   public void customOutlineDrawingItem(Graphics2D g2d,int type) {
		   }
		   public drawingItem createCustomDrawingItem(String entity,int type,String id,int x,int y,String p1,String p2,String p3,String p4,boolean fill,Color c) {
				if (type == dcTypeHDL) {
					HDLDrawingItem d = new HDLDrawingItem(id,x,y,p1,p2,p3,p4,fill,c);
					return d;				
				}
				if (type == dcTypeHDLConn) {
					HDLConnDrawingItem d = new HDLConnDrawingItem(id,x,y,p1,p2,p3,p4,fill,c);
					return d;				
				}
				
				return (drawingItem)null;
		   }
	}
	public class scrollableDrawingCanvas {
		  private HDLDrawingCanvas  	dC;
		  private ScrollPane		  	sPane;
		  private Adjustable			bottomSB,rightSB;
		  
		  public scrollableDrawingCanvas() {
			  this("",dcMaxX,dcMaxY,dcGridSpaceX,dcGridSpaceY,true);
		  }
		  public scrollableDrawingCanvas(String entity,int maxX,int maxY,int spaceX,int spaceY,boolean visible) {
			  dC = new HDLDrawingCanvas(entity,maxX,maxY,spaceX,spaceY,visible);
			  sPane = new ScrollPane();
			  sPane.add(dC);
			  bottomSB = sPane.getHAdjustable();
			  rightSB = sPane.getVAdjustable();
		  }
		  public Point getGCTopLeftCords() {return sPane.getScrollPosition();}
		  public void setGCTopLeftCords(Point pt) {sPane.setScrollPosition(pt);}
		  public Adjustable getBottomSB() {return bottomSB;}
		  public Adjustable getRightSB() {return rightSB;}
		  public void paint(Graphics g) {dC.paint(g);}
		  public drawingCanvas getDC() {return dC;}
		  public ScrollPane getComponent() {return sPane;}
		  public void update(Graphics g) {paint(g);}
		  public void paint() {paint(getGraphics());}
		  public void setSize(Dimension d) {dcMaxX=(int)d.getWidth();dcMaxY=(int)d.getHeight();dC.setSize(d);}
		  public Dimension getSize() {return dC.getSize();}
	}
	
	public void deleteHelpTopics(String product) {
		systemMysql.executeSQLQuery("DELETE FROM sysehshelptopics WHERE sysEHSHelpProduct='"+product+"'","");
	}
	public void updateHelpTopics(String product,String url,boolean helpReplace) {
		msg2Dialog msgD = displayModelessStatusDialog("Updating Help Topics");
		
		if (helpReplace) {deleteHelpTopics(product);}

		xmlDataFile helpItems = new xmlDataFile();
		if (helpItems.openXMLDataFile(supportFunctions.getPathFilenameNoExt(exHelpFile),"ehshelpsystem",false)) {
			org.w3c.dom.Element root = helpItems.getRootElement();
			org.w3c.dom.Document doc = helpItems.getXMLDocument();
			NodeList n = executeXPathExpr(doc,"/ehshelpsystem/ehshelp");
			for (int i=0;i<n.getLength();i++) {
				org.w3c.dom.Element e = (org.w3c.dom.Element)n.item(i);
				String title = e.getAttribute("title");
				String keywords = e.getAttribute("keywords");
				String helpText = ((org.w3c.dom.Text)e.getFirstChild()).getData().trim(); ;
				TRACE("updateHelpTopics:Title="+title+",Keywords="+keywords+",HelpText="+helpText,4);					
				systemMysql.executeSQLQuery("INSERT INTO sysehshelptopics (sysEHSHelpID,sysEHSHelpProduct,sysEHSHelpTitle,sysEHSHelpText,sysEHSHelpKeywords) VALUES (null,'"+product+"','"+title+"','"+helpText+"','"+keywords+"')","");
			}
		} else {
			displayDialog("Can not open help.xml");
		}
		
		msgD.destory();
		msgD.dispose();
	}
	
	public void displayFAQ(String product) {
		JTextArea ta = new JTextArea("",8,40);
		ta.setBackground(new Color(255,255,170));
		ta.setWrapStyleWord(true);
		JPanel p = new JPanel();
		JScrollPane sp = new JScrollPane(ta);
		p.add(sp);
		supportFunctions.displayTextFile(exFAQFile,ta);
		displayPanelDialog(p,product + " - FAQ");
	}
	Vector helpTopics = new Vector();
	Vector helpTitles = new Vector();
	public int getRankedHelpTopics(String product,String keywords) {
		String data = systemMysql.executeSQLQuery("SELECT sysEHSHelpID FROM sysehshelptopics WHERE sysEHSHelpProduct='" + product + "' AND " + posSearchStr(keywords),"");
		Vector v = supportFunctions.splitIntoTokens(data);
		helpTitles.removeAllElements();
		helpTopics.removeAllElements();
		for (int i=0;i<v.size();i++) {
			String data1 = systemMysql.executeSQLQuery("SELECT sysEHSHelpTitle,sysEHSHelpText FROM sysehshelptopics WHERE sysEHSHelpID="+(String)v.elementAt(i),"");
			if (data1.length() != 0) {
				Vector v1 = supportFunctions.splitIntoTokens(data1);
				helpTitles.add((String)v1.elementAt(0));
				helpTopics.add((String)v1.elementAt(1));
			}
		}
		return helpTopics.size();
	}
	public void displayHelpTopics(int numMatches,JTextArea ta) {
		ta.setText(String.valueOf(numMatches) + " Matches Found" + "\n\n");
		for (int i=0;i<numMatches;i++) {
			ta.append(String.valueOf(i+1) + ". " + (String)helpTitles.elementAt(i) + "\n");
			ta.append((String)helpTopics.elementAt(i));
			ta.append("\n\n");
		}
	}
	
	class drawingItemSelection implements Transferable
	{  public drawingItemSelection(drawingItem d) 
	   {  this.d= d;
	   }
	   
	   public DataFlavor[] getTransferDataFlavors() 
	   {  return flavors;
	   }

	   public boolean isDataFlavorSupported(DataFlavor flavor) 
	   {  return flavor.equals(drawingItemFlavor);
	   }
	   
	   public synchronized Object getTransferData
	      (DataFlavor flavor) 
	      throws UnsupportedFlavorException
	   {  if(flavor.equals(drawingItemFlavor)) 
	      {  return d;
	      }
	      else 
	      {  throw new UnsupportedFlavorException(flavor);
	      }
	   }

	   public final DataFlavor drawingItemFlavor
	      = new DataFlavor(drawingItem.class, "Drawing Item");

	   private DataFlavor[] flavors = { drawingItemFlavor }; 
	   private drawingItem d;
	}
	class ImageSelection implements Transferable
	{  public ImageSelection(Image image) 
	   {  theImage = image;
	   }
	   
	   public DataFlavor[] getTransferDataFlavors() 
	   {  return flavors;
	   }

	   public boolean isDataFlavorSupported(DataFlavor flavor) 
	   {  return flavor.equals(imageFlavor);
	   }
	   
	   public synchronized Object getTransferData
	      (DataFlavor flavor) 
	      throws UnsupportedFlavorException
	   {  if(flavor.equals(imageFlavor)) 
	      {  return theImage;
	      }
	      else 
	      {  throw new UnsupportedFlavorException(flavor);
	      }
	   }

	   public final DataFlavor imageFlavor
	      = new DataFlavor(java.awt.Image.class, "AWT Image");

	   private DataFlavor[] flavors = { imageFlavor }; 
	   private Image theImage;
	}
	public final DataFlavor serializableFlavor
	      = new DataFlavor(java.io.Serializable.class, 
	      "Serializable Object");

	private DataFlavor[] flavors 
	      = { serializableFlavor }; 
	class SerializableSelection implements Transferable
	{  public SerializableSelection(Serializable object) 
	   {  theObject = object;
	   }
	   
	   public boolean isDataFlavorSupported(DataFlavor flavor) 
	   {  return flavor.equals(serializableFlavor);
	   }
	   
	   public synchronized Object getTransferData
	      (DataFlavor flavor) 
	      throws UnsupportedFlavorException
	   {  if(flavor.equals(serializableFlavor)) 
	      {  return theObject;
	      }
	      else 
	      {  throw new UnsupportedFlavorException(flavor);
	      }
	   }

	   public DataFlavor[] getTransferDataFlavors() 
	   {  return flavors;
	   }

	   private Serializable theObject;
	}

	class MimeClipboard extends Clipboard
	{  public MimeClipboard(Clipboard cb) 
	   {  super("MIME/" + cb.getName());
	      clip = cb;
	   }

	   public synchronized void setContents(Transferable contents, 
	      ClipboardOwner owner) 
	   {  if (contents instanceof SerializableSelection) 
	      {  try
	         {  DataFlavor flavor 
	               = serializableFlavor;
	            Serializable obj = (Serializable)
	               contents.getTransferData(flavor);
	            String enc = encode(obj);
	            String header = "Content-type: " 
	               + flavor.getMimeType()
	               + "\nContent-length: " 
	               + enc.length() + "\n\n";
	            StringSelection selection 
	               = new StringSelection(header + enc);
	            clip.setContents(selection, owner);
	         }
	         catch(UnsupportedFlavorException e)
	         {}
	         catch(IOException e)
	         {}
	      }
	      else clip.setContents(contents, owner);
	   }

	   public synchronized Transferable getContents
	      (Object requestor) 
	   {  Transferable contents = clip.getContents(requestor);

	      if (contents instanceof StringSelection)
	      {  String data = null;
	         try  
	         {  data = (String)contents.getTransferData
	               (DataFlavor.stringFlavor);
	         }
	         catch(UnsupportedFlavorException e)
	         { return contents; }
	         catch(IOException e)
	         { return contents; }

	         if (!data.startsWith("Content-type: "))
	            return contents;
	         int start = -1;
	         // skip three newlines
	         for (int i = 0; i < 3; i++)
	         {  start = data.indexOf('\n', start + 1);
	            if (start < 0) return contents;
	          }
	         Serializable obj = decode(data, start);
	         SerializableSelection selection
	            = new SerializableSelection(obj);
	         return selection;
	      }
	      else return contents;
	   }

	   private String encode(Serializable obj)
	   {  try
	      {  StringBuffer sbuf = new StringBuffer();
	         Base64OutputStream bout
	            = new Base64OutputStream(sbuf);
	         ObjectOutputStream out
	            = new ObjectOutputStream(bout);
	         out.writeObject(obj);
	         out.flush();
	         return sbuf.toString();
	      }  
	      catch(Exception e)
	      {  return "";
	      } 
	   }

	   private Serializable decode(String s, int start)
	   {  try
	      {  Base64InputStream bin
	            = new Base64InputStream(s, start);
	         ObjectInputStream in
	            = new ObjectInputStream(bin);
	         Object obj = in.readObject();
	         return (Serializable)obj;
	      }  
	      catch(Exception e)
	      {  return null;
	      } 
	   }

	   private Clipboard clip;
	}

	/* BASE64 encoding encodes 3 bytes into 4 characters.
   |11111122|22223333|33444444|
   Each set of 6 bits is encoded according to the 
   toBase64 map. If the number of input bytes is not
   a multiple of 3, then the last group of 4 characters
   is padded with one or two = signs. Each output line
   is at most 76 characters.
*/
public String base64Encode(Serializable obj) {
	try {
		StringBuffer sBuf = new StringBuffer();
		Base64OutputStream bOut = new Base64OutputStream(sBuf);
		ObjectOutputStream out = new ObjectOutputStream(bOut);
		out.writeObject(obj);
		out.flush();
		return sBuf.toString();
	} catch (Exception e) {return "";}
}
public Serializable base64Decode(String s,int start) {
	try {
		Base64InputStream bIn = new Base64InputStream(s,start);
		ObjectInputStream in = new ObjectInputStream(bIn);
		Object obj = in.readObject();
		return (Serializable)obj;
	} catch (Exception e) {return null;}
}
class Base64OutputStream extends OutputStream
{  public Base64OutputStream(StringBuffer sb)
   {  sbuf = sb;
   }

   public void write(int c) throws IOException
   {  inbuf[i] = c;
      i++;
      if (i == 3)
      {  sbuf.append(toBase64[(inbuf[0] & 0xFC) >> 2]);
         sbuf.append(toBase64[((inbuf[0] & 0x03) << 4) |
            ((inbuf[1] & 0xF0) >> 4)]);
         sbuf.append(toBase64[((inbuf[1] & 0x0F) << 2) |
            ((inbuf[2] & 0xC0) >> 6)]);
         sbuf.append(toBase64[inbuf[2] & 0x3F]);   
         col += 4;
         i = 0;
         if (col >= 76)
         {  sbuf.append('\n');
            col = 0;
         }
      }
   }

   public void flush()
   {  if (i == 1)
      {  sbuf.append(toBase64[(inbuf[0] & 0xFC) >> 2]);
         sbuf.append(toBase64[(inbuf[0] & 0x03) << 4]);
         sbuf.append('=');
         sbuf.append('=');
      }
      else if (i == 2)
      {  sbuf.append(toBase64[(inbuf[0] & 0xFC) >> 2]);
         sbuf.append(toBase64[((inbuf[0] & 0x03) << 4) |
            ((inbuf[1] & 0xF0) >> 4)]);
         sbuf.append(toBase64[(inbuf[1] & 0x0F) << 2]);
         sbuf.append('=');
      }
      sbuf.append('\n');
   }

   private char[] toBase64 =
   {  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
      'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
      'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
      'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
      'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
      'w', 'x', 'y', 'z', '0', '1', '2', '3',
      '4', '5', '6', '7', '8', '9', '+', '/'
   };
   
   StringBuffer sbuf;
   int col = 0;
   int i = 0;
   int[] inbuf = new int[3];
}

class Base64InputStream extends InputStream
{  public Base64InputStream(String s, int start)
   {  str = s;
      pos = start;
      i = 0;
   }

   public int read() 
   {  while (pos < str.length() && 
         Character.isWhitespace(str.charAt(pos)))
      {  pos++;
      }
      if (pos >= str.length()) return -1;
      if (i == 0)
      {  int ch1 = str.charAt(pos) & 0x7F;
         int ch2 = str.charAt(pos + 1) & 0x7F;
         i++;
         return (fromBase64[ch1] << 2)
            | (fromBase64[ch2] >> 4);
      }
      else if (i == 1)
      {  int ch1 = str.charAt(pos + 1) & 0x7F;
         int ch2 = str.charAt(pos + 2) & 0x7F;
         if (ch2 == '=') return -1;
         i++;
         return ((fromBase64[ch1] & 0x0F) << 4)
            | (fromBase64[ch2] >> 2);
      }
      else
      {  int ch1 = str.charAt(pos + 2) & 0x7F;
         int ch2 = str.charAt(pos + 3) & 0x7F;
         if (ch2 == '=') return -1;
         i = 0;
         pos += 4;
         return ((fromBase64[ch1] & 0x03) << 6)
            | fromBase64[ch2];
      }
   }

   private int[] fromBase64 =
   {  -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, 62, -1, -1, -1, 63,
      52, 53, 54, 55, 56, 57, 58, 59,
      60, 61, -1, -1, -1, -1, -1, -1,
      -1,  0,  1,  2,  3,  4,  5,  6,
       7,  8,  9, 10, 11, 12, 13, 14,
      15, 16, 17, 18, 19, 20, 21, 22,
      23, 24, 25, -1, -1, -1, -1, -1,
      -1, 26, 27, 28, 29, 30, 31, 32,
      33, 34, 35, 36, 37, 38, 39, 40,
      41, 42, 43, 44, 45, 46, 47, 48,
      49, 50, 51, -1, -1, -1, -1, -1
   };

   String str;
   int pos;
   int i;
}
	public class JDBCTableModel extends DefaultTableModel {
		Object[][] contents;
		String[] columnNames;
		Class[] columnClasses;

		public JDBCTableModel (java.sql.Connection conn,
				   String tableName)
			throws SQLException {
			super();
			getTableContents (conn, tableName);

		}
		protected void getTableContents (java.sql.Connection conn,
					 String tableName)
			throws SQLException {

		// get metadata: what columns exist and what
		// types (classes) are they?
		DatabaseMetaData meta = conn.getMetaData();
		//System.out.println ("got meta = " + meta);
		ResultSet results =
			meta.getColumns (null, null, tableName, null) ;
		//System.out.println ("got column results");
		ArrayList colNamesList = new ArrayList();
		ArrayList colClassesList = new ArrayList();
		while (results.next()) {
			colNamesList.add (results.getString ("COLUMN_NAME")); 
			//System.out.println ("name: " + 
			//	results.getString ("COLUMN_NAME"));
			int dbType = results.getInt ("DATA_TYPE");
			switch (dbType) {
			case Types.INTEGER:
		colClassesList.add (java.lang.Integer.class); break; 
			case Types.FLOAT:
		colClassesList.add (java.lang.Float.class); break; 
			case Types.DOUBLE: 
			case Types.REAL:
		colClassesList.add (java.lang.Double.class); break; 
			case Types.DATE: 
			case Types.TIME: 
			case Types.TIMESTAMP:
		colClassesList.add (java.sql.Date.class); break; 
			default:
		colClassesList.add (String.class); break; 
			}; 
			//System.out.println ("type: " +
			//	results.getInt ("DATA_TYPE"));
			}
			columnNames = new String [colNamesList.size()];
			colNamesList.toArray (columnNames);
			columnClasses = new Class [colClassesList.size()];
			colClassesList.toArray (columnClasses);
			
			// get all data from table and put into
			// contents array

			java.sql.Statement statement =
		conn.createStatement ();
			results = statement.executeQuery ("SELECT * FROM " +
						  tableName);
			ArrayList rowList = new ArrayList();
			while (results.next()) {
		ArrayList cellList = new ArrayList(); 
		for (int i = 0; i<columnClasses.length; i++) { 
			Object cellValue = null;


			if (columnClasses[i] == String.class) 
		cellValue = results.getString (columnNames[i]); 
			else if (columnClasses[i] == java.lang.Integer.class) 
		cellValue = new java.lang.Integer ( 
				results.getInt (columnNames[i])); 
			else if (columnClasses[i] == java.lang.Float.class) 
		cellValue = new java.lang.Float ( 
				results.getInt (columnNames[i])); 
			else if (columnClasses[i] == java.lang.Double.class) 
		cellValue = new java.lang.Double ( 
				results.getDouble (columnNames[i]));
			else if (columnClasses[i] == java.sql.Date.class) 
		cellValue = results.getDate (columnNames[i]); 
			else 
		System.out.println ("Can't assign " + 
				columnNames[i]);
			cellList.add (cellValue);
		}// for
		Object[] cells = cellList.toArray();
		rowList.add (cells);
		
	} // while
	// finally create contents two-dim array
	contents = new Object[rowList.size()] [];
	for (int i=0; i<contents.length; i++)

		contents[i] = (Object []) rowList.get (i);
	//System.out.println ("Created model with " +
	//		   contents.length + " rows");

	// close stuff
	results.close();
	statement.close();

	}
	// AbstractTableModel methods
	public int getRowCount() {
		return contents.length;
	}

	public int getColumnCount() {
		if (contents.length == 0)
			return 0;
		else
			return contents[0].length;
		}

		public Object getValueAt (int row, int column) {
			return contents [row][column];
		}

		// overrides methods for which AbstractTableModel
		// has trivial implementations

		public Class getColumnClass (int col) {
			return columnClasses [col];
		}

		public String getColumnName (int col) { 
			return columnNames [col]; 
		} 
	}
	/**
	 * Displays a tree showing all the elements in a text Document. Selecting
	 * a node will result in reseting the selection of the JTextComponent.
	 * This also becomes a CaretListener to know when the selection has changed
	 * in the text to update the selected item in the tree.
	 *
	 * @author Scott Violet
	 * @version 1.16 07/26/04
	 */
	public class ElementTreePanel extends JPanel implements CaretListener, DocumentListener, PropertyChangeListener, TreeSelectionListener {
	    /** Tree showing the documents element structure. */
	    protected JTree             tree;
	    /** Text component showing elemenst for. */
	    protected JTextComponent    editor;
	    /** Model for the tree. */
	    protected ElementTreeModel  treeModel;
	    /** Set to true when updatin the selection. */
	    protected boolean           updatingSelection;
	    
	    public ElementTreePanel(JTextComponent editor) {
	        this.editor = editor;
	        
	        Document document = editor.getDocument();
	        
	        // Create the tree.
	        treeModel = new ElementTreeModel(document);
	        tree = new JTree(treeModel) {
	            public String convertValueToText(Object value, boolean selected,boolean expanded, boolean leaf,int row, boolean hasFocus) {
	                // Should only happen for the root
	                if(!(value instanceof Element))
	                    return value.toString();
	                
	                Element        e = (Element)value;
	                AttributeSet   as = e.getAttributes().copyAttributes();
	                String         asString;
	                
	                if(as != null) {
	                    StringBuffer       retBuffer = new StringBuffer("[");
	                    Enumeration        names = as.getAttributeNames();
	                    
	                    while(names.hasMoreElements()) {
	                        Object        nextName = names.nextElement();
	                        
	                        if(nextName != StyleConstants.ResolveAttribute) {
	                            retBuffer.append(" ");
	                            retBuffer.append(nextName);
	                            retBuffer.append("=");
	                            retBuffer.append(as.getAttribute(nextName));
	                        }
	                    }
	                    retBuffer.append(" ]");
	                    asString = retBuffer.toString();
	                } else
	                    asString = "[ ]";
	                
	                if(e.isLeaf())
	                    return e.getName() + " [" + e.getStartOffset() +
	                            ", " + e.getEndOffset() +"] Attributes: " + asString;
	                return e.getName() + " [" + e.getStartOffset() +
	                        ", " + e.getEndOffset() + "] Attributes: " +
	                        asString;
	            }
	        };
	        tree.addTreeSelectionListener(this);
	        tree.setDragEnabled(true);
	        // Don't show the root, it is fake.
	        tree.setRootVisible(false);
	        // Since the display value of every node after the insertion point
	        // changes every time the text changes and we don't generate a change
	        // event for all those nodes the display value can become off.
	        // This can be seen as '...' instead of the complete string value.
	        // This is a temporary workaround, increase the needed size by 15,
	        // hoping that will be enough.
	        tree.setCellRenderer(new DefaultTreeCellRenderer() {
	            public Dimension getPreferredSize() {
	                Dimension retValue = super.getPreferredSize();
	                if(retValue != null)
	                    retValue.width += 15;
	                return retValue;
	            }
	        });
	        // become a listener on the document to update the tree.
	        document.addDocumentListener(this);
	        
	        // become a PropertyChangeListener to know when the Document has
	        // changed.
	        editor.addPropertyChangeListener(this);
	        
	        // Become a CaretListener
	        editor.addCaretListener(this);
	        
	        // configure the panel and frame containing it.
	        setLayout(new BorderLayout());
	        add(new JScrollPane(tree), BorderLayout.CENTER);
	        
	        // Add a label above tree to describe what is being shown
	        JLabel     label = new JLabel("Elements that make up the current document", SwingConstants.CENTER);
	        
	        label.setFont(new Font("Dialog", Font.BOLD, 14));
	        add(label, BorderLayout.NORTH);
	        
	        setPreferredSize(new Dimension(400, 400));
	    }
	    
	    /**
	     * Resets the JTextComponent to <code>editor</code>. This will update
	     * the tree accordingly.
	     */
	    public void setEditor(JTextComponent editor) {
	        if (this.editor == editor) {
	            return;
	        }
	        
	        if (this.editor != null) {
	            Document      oldDoc = this.editor.getDocument();
	            
	            oldDoc.removeDocumentListener(this);
	            this.editor.removePropertyChangeListener(this);
	            this.editor.removeCaretListener(this);
	        }
	        this.editor = editor;
	        if (editor == null) {
	            treeModel = null;
	            tree.setModel(null);
	        } else {
	            Document   newDoc = editor.getDocument();
	            
	            newDoc.addDocumentListener(this);
	            editor.addPropertyChangeListener(this);
	            editor.addCaretListener(this);
	            treeModel = new ElementTreeModel(newDoc);
	            tree.setModel(treeModel);
	        }
	    }
	    
	    // PropertyChangeListener
	    
	    /**
	     * Invoked when a property changes. We are only interested in when the
	     * Document changes to reset the DocumentListener.
	     */
	    public void propertyChange(PropertyChangeEvent e) {
	        if (e.getSource() == getEditor() &&
	                e.getPropertyName().equals("document")) {
	            JTextComponent      editor = getEditor();
	            Document            oldDoc = (Document)e.getOldValue();
	            Document            newDoc = (Document)e.getNewValue();
	            
	            // Reset the DocumentListener
	            oldDoc.removeDocumentListener(this);
	            newDoc.addDocumentListener(this);
	            
	            // Recreate the TreeModel.
	            treeModel = new ElementTreeModel(newDoc);
	            tree.setModel(treeModel);
	        }
	    }
	    
	    
	    // DocumentListener
	    
	    /**
	     * Gives notification that there was an insert into the document.  The
	     * given range bounds the freshly inserted region.
	     *
	     * @param e the document event
	     */
	    public void insertUpdate(DocumentEvent e) {
	        updateTree(e);
	    }
	    
	    /**
	     * Gives notification that a portion of the document has been
	     * removed.  The range is given in terms of what the view last
	     * saw (that is, before updating sticky positions).
	     *
	     * @param e the document event
	     */
	    public void removeUpdate(DocumentEvent e) {
	        updateTree(e);
	    }
	    
	    /**
	     * Gives notification that an attribute or set of attributes changed.
	     *
	     * @param e the document event
	     */
	    public void changedUpdate(DocumentEvent e) {
	        updateTree(e);
	    }
	    
	    // CaretListener
	    
	    /**
	     * Messaged when the selection in the editor has changed. Will update
	     * the selection in the tree.
	     */
	    public void caretUpdate(CaretEvent e) {
	        if(!updatingSelection) {
	            JTextComponent     editor = getEditor();
	            int                selBegin = Math.min(e.getDot(), e.getMark());
	            int                end = Math.max(e.getDot(), e.getMark());
	            Vector             paths = new Vector();
	            TreeModel          model = getTreeModel();
	            Object             root = model.getRoot();
	            int                rootCount = model.getChildCount(root);
	            
	            // Build an array of all the paths to all the character elements
	            // in the selection.
	            for(int counter = 0; counter < rootCount; counter++) {
	                int            start = selBegin;
	                
	                while(start <= end) {
	                    TreePath    path = getPathForIndex(start, root,
	                            (Element)model.getChild(root, counter));
	                    Element     charElement = (Element)path.
	                            getLastPathComponent();
	                    
	                    paths.addElement(path);
	                    if(start >= charElement.getEndOffset())
	                        start++;
	                    else
	                        start = charElement.getEndOffset();
	                }
	            }
	            
	            // If a path was found, select it (them).
	            int               numPaths = paths.size();
	            
	            if(numPaths > 0) {
	                TreePath[]    pathArray = new TreePath[numPaths];
	                
	                paths.copyInto(pathArray);
	                updatingSelection = true;
	                try {
	                    getTree().setSelectionPaths(pathArray);
	                    getTree().scrollPathToVisible(pathArray[0]);
	                } finally {
	                    updatingSelection = false;
	                }
	            }
	        }
	    }
	    
	    // TreeSelectionListener
	    
	    /**
	     * Called whenever the value of the selection changes.
	     * @param e the event that characterizes the change.
	     */
	    public void valueChanged(TreeSelectionEvent e) {
	        JTree       tree = getTree();
	        
	        if(!updatingSelection && tree.getSelectionCount() == 1) {
	            TreePath      selPath = tree.getSelectionPath();
	            Object        lastPathComponent = selPath.getLastPathComponent();
	            
	            if(!(lastPathComponent instanceof DefaultMutableTreeNode)) {
	                Element       selElement = (Element)lastPathComponent;
	                
	                updatingSelection = true;
	                try {
	                    getEditor().select(selElement.getStartOffset(),
	                            selElement.getEndOffset());
	                } finally {
	                    updatingSelection = false;
	                }
	            }
	        }
	    }
	    
	    // Local methods
	    
	    /**
	     * @return tree showing elements.
	     */
	    protected JTree getTree() {
	        return tree;
	    }
	    
	    /**
	     * @return JTextComponent showing elements for.
	     */
	    protected JTextComponent getEditor() {
	        return editor;
	    }
	    
	    /**
	     * @return TreeModel implementation used to represent the elements.
	     */
	    public DefaultTreeModel getTreeModel() {
	        return treeModel;
	    }
	    
	    /**
	     * Updates the tree based on the event type. This will invoke either
	     * updateTree with the root element, or handleChange.
	     */
	    protected void updateTree(DocumentEvent event) {
	        updatingSelection = true;
	        try {
	            TreeModel        model = getTreeModel();
	            Object           root = model.getRoot();
	            
	            for(int counter = model.getChildCount(root) - 1; counter >= 0;
	            counter--) {
	                updateTree(event, (Element)model.getChild(root, counter));
	            }
	        } finally {
	            updatingSelection = false;
	        }
	    }
	    
	    /**
	     * Creates TreeModelEvents based on the DocumentEvent and messages
	     * the treemodel. This recursively invokes this method with children
	     * elements.
	     * @param event indicates what elements in the tree hierarchy have
	     * changed.
	     * @param element Current element to check for changes against.
	     */
	    protected void updateTree(DocumentEvent event, Element element) {
	        DocumentEvent.ElementChange ec = event.getChange(element);
	        
	        if (ec != null) {
	            Element[]       removed = ec.getChildrenRemoved();
	            Element[]       added = ec.getChildrenAdded();
	            int             startIndex = ec.getIndex();
	            
	            // Check for removed.
	            if(removed != null && removed.length > 0) {
	                int[]            indices = new int[removed.length];
	                
	                for(int counter = 0; counter < removed.length; counter++) {
	                    indices[counter] = startIndex + counter;
	                }
	                getTreeModel().nodesWereRemoved((TreeNode)element, indices,
	                        removed);
	            }
	            // check for added
	            if(added != null && added.length > 0) {
	                int[]            indices = new int[added.length];
	                
	                for(int counter = 0; counter < added.length; counter++) {
	                    indices[counter] = startIndex + counter;
	                }
	                getTreeModel().nodesWereInserted((TreeNode)element, indices);
	            }
	        }
	        if(!element.isLeaf()) {
	            int        startIndex = element.getElementIndex
	                    (event.getOffset());
	            int        elementCount = element.getElementCount();
	            int        endIndex = Math.min(elementCount - 1,
	                    element.getElementIndex
	                    (event.getOffset() + event.getLength()));
	            
	            if(startIndex > 0 && startIndex < elementCount &&
	                    element.getElement(startIndex).getStartOffset() ==
	                    event.getOffset()) {
	                // Force checking the previous element.
	                startIndex--;
	            }
	            if(startIndex != -1 && endIndex != -1) {
	                for(int counter = startIndex; counter <= endIndex; counter++) {
	                    updateTree(event, element.getElement(counter));
	                }
	            }
	        } else {
	            // Element is a leaf, assume it changed
	            getTreeModel().nodeChanged((TreeNode)element);
	        }
	    }
	    
	    /**
	     * Returns a TreePath to the element at <code>position</code>.
	     */
	    protected TreePath getPathForIndex(int position, Object root,
	            Element rootElement) {
	        TreePath         path = new TreePath(root);
	        Element          child = rootElement.getElement
	                (rootElement.getElementIndex(position));
	        
	        path = path.pathByAddingChild(rootElement);
	        path = path.pathByAddingChild(child);
	        while(!child.isLeaf()) {
	            child = child.getElement(child.getElementIndex(position));
	            path = path.pathByAddingChild(child);
	        }
	        return path;
	    }
	    
	    
	    /**
	     * ElementTreeModel is an implementation of TreeModel to handle displaying
	     * the Elements from a Document. AbstractDocument.AbstractElement is
	     * the default implementation used by the swing text package to implement
	     * Element, and it implements TreeNode. This makes it trivial to create
	     * a DefaultTreeModel rooted at a particular Element from the Document.
	     * Unfortunately each Document can have more than one root Element.
	     * Implying that to display all the root elements as a child of another
	     * root a fake node has be created. This class creates a fake node as
	     * the root with the children being the root elements of the Document
	     * (getRootElements).
	     * <p>This subclasses DefaultTreeModel. The majority of the TreeModel
	     * methods have been subclassed, primarily to special case the root.
	     */
	    public class ElementTreeModel extends DefaultTreeModel {
	        protected Element[]         rootElements;
	        
	        public ElementTreeModel(Document document) {
	            super(new DefaultMutableTreeNode("root"), false);
	            rootElements = document.getRootElements();
	        }
	        
	        /**
	         * Returns the child of <I>parent</I> at index <I>index</I> in
	         * the parent's child array.  <I>parent</I> must be a node
	         * previously obtained from this data source. This should
	         * not return null if <i>index</i> is a valid index for
	         * <i>parent</i> (that is <i>index</i> >= 0 && <i>index</i>
	         * < getChildCount(<i>parent</i>)).
	         *
	         * @param   parent  a node in the tree, obtained from this data source
	         * @return  the child of <I>parent</I> at index <I>index</I>
	         */
	        public Object getChild(Object parent, int index) {
	            if(parent == root)
	                return rootElements[index];
	            return super.getChild(parent, index);
	        }
	        
	        
	        /**
	         * Returns the number of children of <I>parent</I>.  Returns 0
	         * if the node is a leaf or if it has no children.
	         * <I>parent</I> must be a node previously obtained from this
	         * data source.
	         *
	         * @param   parent  a node in the tree, obtained from this data source
	         * @return  the number of children of the node <I>parent</I>
	         */
	        public int getChildCount(Object parent) {
	            if(parent == root)
	                return rootElements.length;
	            return super.getChildCount(parent);
	        }
	        
	        
	        /**
	         * Returns true if <I>node</I> is a leaf.  It is possible for
	         * this method to return false even if <I>node</I> has no
	         * children.  A directory in a filesystem, for example, may
	         * contain no files; the node representing the directory is
	         * not a leaf, but it also has no children.
	         *
	         * @param   node    a node in the tree, obtained from this data source
	         * @return  true if <I>node</I> is a leaf
	         */
	        public boolean isLeaf(Object node) {
	            if(node == root)
	                return false;
	            return super.isLeaf(node);
	        }
	        
	        /**
	         * Returns the index of child in parent.
	         */
	        public int getIndexOfChild(Object parent, Object child) {
	            if(parent == root) {
	                for(int counter = rootElements.length - 1; counter >= 0;
	                counter--) {
	                    if(rootElements[counter] == child)
	                        return counter;
	                }
	                return -1;
	            }
	            return super.getIndexOfChild(parent, child);
	        }
	        
	        /**
	         * Invoke this method after you've changed how node is to be
	         * represented in the tree.
	         */
	        public void nodeChanged(TreeNode node) {
	            if(listenerList != null && node != null) {
	                TreeNode         parent = node.getParent();
	                
	                if(parent == null && node != root) {
	                    parent = root;
	                }
	                if(parent != null) {
	                    int        anIndex = getIndexOfChild(parent, node);
	                    
	                    if(anIndex != -1) {
	                        int[]        cIndexs = new int[1];
	                        
	                        cIndexs[0] = anIndex;
	                        nodesChanged(parent, cIndexs);
	                    }
	                }
	            }
	        }
	        
	        /**
	         * Returns the path to a particluar node. This is recursive.
	         */
	        protected TreeNode[] getPathToRoot(TreeNode aNode, int depth) {
	            TreeNode[]              retNodes;
	            
	            /* Check for null, in case someone passed in a null node, or
	               they passed in an element that isn't rooted at root. */
	            if(aNode == null) {
	                if(depth == 0)
	                    return null;
	                else
	                    retNodes = new TreeNode[depth];
	            } else {
	                depth++;
	                if(aNode == root)
	                    retNodes = new TreeNode[depth];
	                else {
	                    TreeNode parent = aNode.getParent();
	                    
	                    if(parent == null)
	                        parent = root;
	                    retNodes = getPathToRoot(parent, depth);
	                }
	                retNodes[retNodes.length - depth] = aNode;
	            }
	            return retNodes;
	        }
	    }
	}	
}




